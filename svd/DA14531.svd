<?xml version="1.0" encoding="ascii"?>
<!-- File naming: Dialog_D2632AB.svd -->
<!--
  Copyright (C) 2019 Dialog Semiconductor.
  This computer program includes Confidential, Proprietary Information  
  of Dialog Semiconductor. All Rights Reserved.

  Purpose: System Viewer Description (SVD) Example (Schema Version 1.1)
           This is a description of a none-existent and incomplete device
		   for demonstration purposes only.

  Generated by cmsis-svd (version 0.2), d.d. November 08, 2019 - 10:12:42
 -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <vendor>Dialog</vendor>                   				    <!-- device vendor name -->
  <vendorID>ARM</vendorID>                                        <!-- device vendor short name -->
  <name>DA14531</name>                                          <!-- name of part-->
  <series>DA14531</series>                                         <!-- device series the device belongs to -->
  <version>1.2</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>DA14531</description>
  <licenseText><!-- this license text will appear in header file. \n forces line breaks -->
  Copyright (C) 2019 Dialog Semiconductor.\n
    This computer program includes Confidential, Proprietary Information  \n
    of Dialog Semiconductor. All Rights Reserved. \n
    \n
    Dialog GmbH (DLG) is supplying this software for use with Cortex-M\n
    processor based microcontroller, but can be equally used for other\n
    suitable  processor architectures. This file can be freely distributed.\n
    Modifications to this file shall be clearly marked.\n
    \n
    THIS SOFTWARE IS PROVIDED  AS IS .  NO WARRANTIES, WHETHER EXPRESS, IMPLIED\n
    OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.\n
    ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR\n
    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
</licenseText>
  <cpu><!-- details about the cpu embedded in the device (SVD version 1.2,  see https://www.keil.com/pack/doc/CMSIS/SVD/html/group__cpu_section__gr.html) -->
    <name>CM0</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
		
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
																																									 and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->
	
  <peripherals>
	<peripheral>  
  <name>NVIC</name>
  <version>1.0</version>
  <description>Cortex M0 NVIC registers</description>
  <groupName>NVIC</groupName>
  <baseAddress>0xE000E100</baseAddress>
  <size>0</size>
  <addressBlock>
		<offset>0</offset>
		<size>0x321</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>ISER</name>
	  <description>Interrupt set-enable register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[21:21]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[22:22]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[23:23]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[24:24]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[25:25]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[26:26]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[27:27]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[28:28]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[29:29]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[30:30]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICER</name>
	  <description>Interrupt clear-enable register</description>
	  <addressOffset>0x00000080</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[21:21]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[22:22]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[23:23]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[24:24]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[25:25]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[26:26]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[27:27]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[28:28]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[29:29]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[30:30]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ISPR</name>
	  <description>Interrupt set-pending register</description>
	  <addressOffset>0x00000100</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[21:21]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[22:22]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[23:23]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[24:24]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[25:25]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[26:26]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[27:27]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[28:28]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[29:29]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[30:30]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICPR</name>
	  <description>Interrupt clear-pending register</description>
	  <addressOffset>0x00000180</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[21:21]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[22:22]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[23:23]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[24:24]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[25:25]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[26:26]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[27:27]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[28:28]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[29:29]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[30:30]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR0</name>
	  <description>Interrupt priority register 0</description>
	  <addressOffset>0x00000300</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn_prio</name>
		  <description>BLE_WAKEUP_LP_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn_prio</name>
		  <description>BLE_GEN_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn_prio</name>
		  <description>FTDF_WAKEUP_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn_prio</name>
		  <description>FTDF_GEN_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR1</name>
	  <description>Interrupt priority register 1</description>
	  <addressOffset>0x00000304</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>RFCAL_IRQn_prio</name>
		  <description>RFCAL_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>COEX_IRQn_prio</name>
		  <description>COEX_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>CRYPTO_IRQn_prio</name>
		  <description>CRYPTO_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>MRM_IRQn_prio</name>
		  <description>MRM_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR2</name>
	  <description>Interrupt priority register 2</description>
	  <addressOffset>0x00000308</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>UART_IRQn_prio</name>
		  <description>UART_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn_prio</name>
		  <description>UART2_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn_prio</name>
		  <description>I2C_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C2_IRQn_prio</name>
		  <description>I2C2_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR3</name>
	  <description>Interrupt priority register 3</description>
	  <addressOffset>0x0000030C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SPI_IRQn_prio</name>
		  <description>SPI_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI2_IRQn_prio</name>
		  <description>SPI2_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn_prio</name>
		  <description>ADC_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn_prio</name>
		  <description>KEYBRD_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR4</name>
	  <description>Interrupt priority register 4</description>
	  <addressOffset>0x00000310</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>IRGEN_IRQn_prio</name>
		  <description>IRGEN_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn_prio</name>
		  <description>WKUP_GPIO_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM0_IRQn_prio</name>
		  <description>SWTIM0_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM1_IRQn_prio</name>
		  <description>SWTIM1_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR5</name>
	  <description>Interrupt priority register 5</description>
	  <addressOffset>0x00000314</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>QUADEC_IRQn_prio</name>
		  <description>QUADEC_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>USB_IRQn_prio</name>
		  <description>USB_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn_prio</name>
		  <description>PCM_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn_prio</name>
		  <description>SRC_IN_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR6</name>
	  <description>Interrupt priority register 6</description>
	  <addressOffset>0x00000318</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SRC_OUT_IRQn_prio</name>
		  <description>SRC_OUT_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>VBUS_IRQn_prio</name>
		  <description>VBUS_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn_prio</name>
		  <description>DMA_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RF_DIAG_IRQn_prio</name>
		  <description>RF_DIAG_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR7</name>
	  <description>Interrupt priority register 7</description>
	  <addressOffset>0x0000031C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>TRNG_IRQn_prio</name>
		  <description>TRNG_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DCDC_IRQn_prio</name>
		  <description>DCDC_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn_prio</name>
		  <description>XTAL16RDY_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RESERVED31_IRQn_DONT_USE</name>
		  <description>RESERVED31_IRQn[7:0] bits (Reserved)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
  <name>SCB</name>
  <version>1.0</version>
  <description>Cortex M0 SCB registers</description>
  <groupName>SCB</groupName>
  <baseAddress>0xE000ED00</baseAddress>
  <size>0</size>
  <addressBlock>
		<offset>0</offset>
		<size>0x29</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>CPUID</name>
	  <description>CPUID base register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x410CC200</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>REVISION</name>
		  <description>REVISION[3:0] bits (Revision number)</description>
		  <bitRange>[3:0]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>PARTNO</name>
		  <description>PARTNO[11:0] bits (Part number of the processor core)</description>
		  <bitRange>[15:4]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>CONSTANT</name>
		  <description>CONSTANT[3:0] bits (Reads as 0xF)</description>
		  <bitRange>[19:16]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>VARIANT</name>
		  <description>VARIANT[3:0] bits (Variant number)</description>
		  <bitRange>[23:20]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>IMPLEMENTER</name>
		  <description>IMPLEMENTER[7:0] bits (Implementer code)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-only</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICSR</name>
	  <description>Interrupt control and state register</description>
	  <addressOffset>0x00000004</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>VECTACTIVE</name>
		  <description>VECTACTIVE[5:0] bits (Active vector)</description>
		  <bitRange>[5:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>VECTPENDING</name>
		  <description>VECTPENDING[5:0] bits (Pending vector)</description>
		  <bitRange>[17:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ISRPENDING</name>
		  <description>Interrupt pending flag, excluding NMI and Faults</description>
		  <bitRange>[22:22]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSTCLR</name>
		  <description>SysTick exception clear-pending bit</description>
		  <bitRange>[25:25]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSTSET</name>
		  <description>SysTick exception set-pending bit</description>
		  <bitRange>[26:26]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSVCLR</name>
		  <description>PendSV clear-pending bit</description>
		  <bitRange>[27:27]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSVSET</name>
		  <description>PendSV set-pending bit</description>
		  <bitRange>[28:28]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>NMIPENDSET</name>
		  <description>NMI set-pending bit</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>AIRCR</name>
	  <description>Application interrupt and reset control register</description>
	  <addressOffset>0x0000000C</addressOffset>
	  <size>32</size>
	  <access>read-only</access>
	  <resetValue>0xFA050000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>VECTRESET</name>
		  <description>Reserved for Debug use</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>VECTCLRACTIVE</name>
		  <description>Reserved for Debug use</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>SYSRESETREQ</name>
		  <description>System reset request</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>ENDIANESS</name>
		  <description>Data endianness bit</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>VECTKEY</name>
		  <description>VECTKEY[15:0] bits (Register key)</description>
		  <bitRange>[31:16]</bitRange>
		  <access>read-only</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SCR</name>
	  <description>System control register</description>
	  <addressOffset>0x00000010</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SLEEPONEXIT</name>
		  <description>Configures sleep-on-exit when returning from Handler mode to Thread mode</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SLEEPDEEP</name>
		  <description>Controls whether the processor uses sleep or deep sleep</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SEVEONPEND</name>
		  <description>Send event on pending bit</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>CCR</name>
	  <description>Configuration and control register</description>
	  <addressOffset>0x00000014</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000204</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>UNALIGN_TRP</name>
		  <description>Enables unaligned access traps</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>STKALIGN</name>
		  <description>Configures stack alignment on exception entry</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SHPR2</name>
	  <description>System handler priority register 2</description>
	  <addressOffset>0x0000001C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>PRI_11</name>
		  <description>PRI_11[7:0] bits (Priority of system handler 11, SVCall)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SHPR3</name>
	  <description>System handler priority register 3</description>
	  <addressOffset>0x00000020</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>PRI_14</name>
		  <description>PRI_14[7:0] bits (Priority of system handler 14, PendSV)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PRI_15</name>
		  <description>PRI_15[7:0] bits (Priority of system handler 15, SysTick exception)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
  <name>SysTick</name>
  <version>1.0</version>
  <description>Cortex M0 SysTick registers</description>
  <groupName>SYSTICK</groupName>
  <baseAddress>0xE000E010</baseAddress>
  <size>0</size>
  <addressBlock>
		<offset>0</offset>
		<size>0x11</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>CTRL</name>
	  <description>SysTick Control and Status register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000004</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>ENABLE</name>
		  <description>SysTick Counter enable</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>TICKINT</name>
		  <description>SysTick exception request enable</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>CLKSOURCE</name>
		  <description>Clock source selection</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>COUNTFLAG</name>
		  <description>Timer counted to 0 since last time this was read</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>LOAD</name>
	  <description>SysTick Reload value register</description>
	  <addressOffset>0x00000004</addressOffset>
	  <size>32</size>
	  <access>read-write<!--==(HARDCODED)==--></access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>RELOAD</name>
		  <description>RELOAD[23:0] bits (Reload value)</description>
		  <bitRange>[23:0]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>VAL</name>
	  <description>SysTick Current value register</description>
	  <addressOffset>0x00000008</addressOffset>
	  <size>32</size>
	  <access>read-write<!--==(HARDCODED)==--></access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>CURRENT</name>
		  <description>CURRENT[23:0] bits (Current counter value)</description>
		  <bitRange>[23:0]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>CALIB</name>
	  <description>SysTick Calibration value register</description>
	  <addressOffset>0x0000000C</addressOffset>
	  <size>32</size>
	  <access>read-only<!--==(HARDCODED)==--></access>
	  <resetValue>0x00002328</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>TENMS</name>
		  <description>TENMS[23:0] bits (Calibration value)</description>
		  <bitRange>[23:0]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>SKEW</name>
		  <description>Indicates whether the TENMS value is exact</description>
		  <bitRange>[30:30]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>NOREF</name>
		  <description>Indicates that a separate reference clock is provided</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-only</access>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
	<name>adplldig</name>
	<version>1.0</version>
	<description>adplldig registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40003000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>152</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>ADPLL_ACC_CTRL_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>EN_CMF_AVG</name>
	
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLIP_MOD_TUNE_0_TX</name>
	
	<bitRange>[28:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLIP_MOD_TUNE_0_RX</name>
	
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_ANATST_CTRL_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ANATSTSPARE</name>
	
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ANATSTEN</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_ANATST_RD_REG</name>
	
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ANATSTSPARE_IN</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_ANA_CTRL_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0215807b</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DTC_LDO_DMY</name>
	
	<bitRange>[28:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VPASETTLE</name>
	
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_OFFSET</name>
	
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DTC_EN</name>
	
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DTCOFFSET</name>
	
	<bitRange>[14:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TGLDETEN</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_CKDCOMOD</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKDCOMOD</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKPHV</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKTDC</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_INV</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_CKVIN_EN</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_DTCIN_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_ATTR_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>PWR_MODE_TX</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PWR_MODE_RX</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_CN_CTRL_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x09620100</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CH0</name>
	
	<bitRange>[28:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SGN</name>
	
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CS</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CN</name>
	
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_DCOAMP_CAL_CTRL_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x77770011</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCOAMPIC_LP_TX</name>
	
	<bitRange>[31:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPIC_LP_RX</name>
	
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPIC_HP_TX</name>
	
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPIC_HP_RX</name>
	
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOAMPTM</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AMPCALEN</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KMEDIUM</name>
	
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KCOARSE</name>
	
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_DCO_RD_REG</name>
	
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x1c000007</resetValue>
	<resetMask>0x3fffffff</resetMask>
	<fields><field>
	<name>DCOAMP</name>
	
	<bitRange>[29:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOMOD</name>
	
	<bitRange>[25:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOFINE</name>
	
	<bitRange>[12:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOMEDIUM</name>
	
	<bitRange>[6:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCOCOARSE</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_DIV_CTRL_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0198ff03</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXDIV_TRIM</name>
	
	<bitRange>[25:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDIV_TRIM</name>
	
	<bitRange>[16:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDIV_FB_EN_TX</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDIV_FB_EN_RX</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FBDIV_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_FIF_CTRL1_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000400</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FIFRX_1M</name>
	
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_FIF_CTRL2_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FIFTX</name>
	
	<bitRange>[29:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FIFRX_OFFSET</name>
	
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_FREQMEAS_RD_REG</name>
	
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x21000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MEASDONE_OUT</name>
	
	<bitRange>[29:29]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>QUALMONDET</name>
	
	<bitRange>[26:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDCBUB</name>
	
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PHVSA0</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PHVSA1</name>
	
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQDIFF</name>
	
	<bitRange>[22:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_FSM_CTRL_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x08f8ae84</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TVPASETTLE</name>
	
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TSETTLE</name>
	
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TPASETTLE</name>
	
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMOD</name>
	
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TFINE</name>
	
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMEDIUM</name>
	
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TCOARSE</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_INIT_CTRL_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000005</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCOMODIC</name>
	
	<bitRange>[28:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOFINEIC</name>
	
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOMEDIUMIC</name>
	
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCOCOARSEIC</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDCO_CAL_CTRL1_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00009b9b</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KDCOLF_IN_1M</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOHFIC_1M</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDCO_CAL_CTRL2_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x4c14000a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>KDCOESTDEV</name>
	
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOCALTX</name>
	
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOCALRX</name>
	
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOLFCALEN</name>
	
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TKDCOCAL</name>
	
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDCOCN_IC</name>
	
	<bitRange>[22:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KMOD_ALPHA_1M</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDCO_RD_REG</name>
	
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>CAL_KDCOCAL</name>
	
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDCOCN</name>
	
	<bitRange>[22:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDCO_HF_OUT</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDCO_HF_INT</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDTCTDC_CAL_CTRL1_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>KDTCIC</name>
	
	<bitRange>[31:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCN_IC</name>
	
	<bitRange>[22:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTC_PIPELINE_BYPASS</name>
	
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KTDC_IN</name>
	
	<bitRange>[14:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTC_ALPHA</name>
	
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDTCTDC_CAL_CTRL2_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00007f50</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PHRDLY_EXTRA</name>
	
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TKDTCCAL</name>
	
	<bitRange>[14:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PHRDLY</name>
	
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KTDCCALEN</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALLG</name>
	
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCAL_INV</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALMOD1P</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALMOD</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KDTCCALEN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_KDTC_RD_REG</name>
	
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>CAL_KDTCCAL</name>
	
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDTC_ALPHA_COMP</name>
	
	<bitRange>[24:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDTCCN</name>
	
	<bitRange>[15:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>KDTC_OUT</name>
	
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_LF_CTRL1_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000818c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FINEKZ</name>
	
	<bitRange>[15:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINEK</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINETAU</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_LF_CTRL2_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x1ca2879e</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RST_TAU_EN</name>
	
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODKZ</name>
	
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODK</name>
	
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODTAU</name>
	
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODK_TUNE</name>
	
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODTAU_TUNE</name>
	
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_MISC_CTRL_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000da</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PHR_FRAC_PRESET_VAL</name>
	
	<bitRange>[23:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENFCWMOD</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENRESIDUE</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODDLY</name>
	
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESDLY</name>
	
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DLYFCWDT</name>
	
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_MON_CTRL_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00fc0f83</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>QUALMONFRCEN</name>
	
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QUALMONTRHLD</name>
	
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QUALMONWND</name>
	
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QUALMONMOD</name>
	
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOLD_STATE</name>
	
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMEAS_MODE</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENRFMEAS</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMREN</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TFREQMEAS</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_OVERRULE_CTRL1_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OVR_DTC_OH_WR</name>
	
	<bitRange>[31:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DTC_OH_SEL</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMP_WR</name>
	
	<bitRange>[20:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMP_SEL</name>
	
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMPHOLD_WR</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOAMPHOLD_SEL</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RDYFORDIV_WR</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RDYFORDIV_SEL</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_VPAEN_WR</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_VPAEN_SEL</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_SRESETN_WR</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_SRESETN_SEL</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ENPAIN_WR</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ENPAIN_SEL</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXBIT_WR</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXBIT_SEL</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ACTIVE_WR</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_ACTIVE_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_OVERRULE_CTRL2_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OVR_DCOMOD_WR</name>
	
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOMOD_SEL</name>
	
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOFINE_WR</name>
	
	<bitRange>[22:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOFINE_SEL</name>
	
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOMEDIUM_WR</name>
	
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOMEDIUM_SEL</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOCOARSE_WR</name>
	
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_DCOCOARSE_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_OVERRULE_CTRL3_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>OVR_RXDIV_FB_EN_WR</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXDIV_FB_EN_SEL</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_FBDIV_EN_WR</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_FBDIV_EN_SEL</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_TXDIV_EN_WR</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_TXDIV_EN_SEL</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXDIV_EN_WR</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVR_RXDIV_EN_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_PLLFCWDT_RD_REG</name>
	
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00258800</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>PLLFCWDT</name>
	
	<bitRange>[22:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_RFPT_CTRL_REG</name>
	
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>RFPT_RATE</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CKRFPT</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFPT_MUX</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_SDMOD_CTRL_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000039</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SDMMODETX</name>
	
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDMMODERX</name>
	
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ADPLL_TUNESTATE_RD_REG</name>
	
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>TMRVAL</name>
	
	<bitRange>[13:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TUNE_STATE</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ADPLL_TXMOD_CTRL_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>INV_CKMODEXT</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_MODE</name>
	
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EO_PACKET_DIS</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MOD_INDEX</name>
	
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_DATA_INV</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BT_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ANAMISC</name>
	<version>1.0</version>
	<description>ANAMISC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_REF_CNT_REG</name>
	<description>Count value for oscillator calibration</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REF_CNT_VAL</name>
	<description>Indicates the calibration time, with a decrement counter to 1. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_SEL_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>EXT_CNT_EN_SEL</name>
	<description>0 : Enable XTAL_CNT counter by the REF_CLK selected by REF_CLK_SEL.
1 : Enable XTAL_CNT counter from an external input.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CAL_START</name>
	<description>Writing a '1' starts a calibration of the clock selected by CLK_REF_SEL_REG[REF_CLK_SEL]. This bit is cleared when calibration is finished, and CLK_REF_VAL is ready. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CLK_SEL</name>
	<description>Select clock input for calibration:
0x0 : RC32K
0x1 : RC32M
0x2 : XTAL32K
0x3 : RCX</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_H_REG</name>
	<description>XTAL32M reference cycles, higher 16 bits</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the number of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_L_REG</name>
	<description>XTAL32M reference cycles, lower 16 bits</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the number of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>BLE</name>
	<version>1.0</version>
	<description>BLE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>532</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BLE_ACTSCANSTAT_REG</name>
	<description>Active scan register</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00010001</resetValue>
	<resetMask>0x01ff01ff</resetMask>
	<fields><field>
	<name>BACKOFF</name>
	<description>Active scan mode back-off counter initialization value. </description>
	<bitRange>[24:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UPPERLIMIT</name>
	<description>Active scan mode upper limit counter value. </description>
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_ADVCHMAP_REG</name>
	<description>Advertising Channel Map</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>ADVCHMAP</name>
	<description>Advertising Channel Map, defined as per the advertising connection settings. Contains advertising channels index 37 to 39. If ADVCHMAP[i] equals:
0: Do not use data channel i+37.
1: Use data channel i+37. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ADVTIM_REG</name>
	<description>Advertising Packet Interval</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>ADVINT</name>
	<description>Advertising Packet Interval defines the time interval in between two ADV_xxx packet sent. Value is in us.
Value to program depends on the used Advertising Packet type and the device filtering policy. </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESCNTL_REG</name>
	<description>Start AES register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>AES_MODE</name>
	<description>0: Cipher mode
1: Decipher mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AES_START</name>
	<description>Writing a 1 starts AES-128 ciphering/deciphering process.
This bit is reset once the process is finished (i.e. ble_crypt_irq interrupt occurs, even masked) </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY127_96_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY127_96</name>
	<description>AES encryption 128-bit key. Bit 127 down to 96 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY31_0_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY31_0</name>
	<description>AES encryption 128-bit key. Bit 31 down to 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY63_32_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY63_32</name>
	<description>AES encryption 128-bit key. Bit 63 down to 32 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY95_64_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY95_64</name>
	<description>AES encryption 128-bit key. Bit 95 down to 64 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESPTR_REG</name>
	<description>Pointer to the block to encrypt/decrypt</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>AESPTR</name>
	<description>Pointer to the memory zone where the block to cipher/decipher using AES-128 is stored. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BASETIMECNTCORR_REG</name>
	<description>Base Time Counter</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>BASETIMECNTCORR</name>
	<description>Base Time Counter correction value. </description>
	<bitRange>[26:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BASETIMECNT_REG</name>
	<description>Base time reference counter</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>BASETIMECNT</name>
	<description>Value of the 625us base time reference counter. Updated each time SAMPCLK is written. Used by the SW in order to synchronize with the HW </description>
	<bitRange>[26:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_BDADDRL_REG</name>
	<description>BLE device address LSB register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BDADDRL</name>
	<description>Bluetooth Low Energy Device Address. LSB part.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BDADDRU_REG</name>
	<description>BLE device address MSB register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>PRIV_NPUB</name>
	<description>Bluetooth Low Energy Device Address privacy indicator
0: Public Bluetooth Device Address
1: Private Bluetooth Device Address </description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BDADDRU</name>
	<description>Bluetooth Low Energy Device Address. MSB part. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BLEMPRIO0_REG</name>
	<description>Coexistence interface Priority 0 Register</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3489adef</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLEM7</name>
	<description>Set Priority value for Passive Scanning </description>
	<bitRange>[31:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM6</name>
	<description>Set Priority value for Non-Connectable Advertising </description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM5</name>
	<description>Set Priority value for Connectable Advertising BLE message </description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM4</name>
	<description>Set Priority value for Active Scanning BLE message </description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM3</name>
	<description>Set Priority value for Initiating (Scanning) BLE message </description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM2</name>
	<description>Set Priority value for Data Channel transmission BLE message </description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM1</name>
	<description>Set Priority value for LLCP BLE message </description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLEM0</name>
	<description>Set Priority value for Initiating (Connection Request Response) BLE message </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BLEMPRIO1_REG</name>
	<description>Coexistence interface Priority 1 Register</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x30000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLEMDEFAULT</name>
	<description>Set default priority value for other BLE message than those defined above </description>
	<bitRange>[31:28]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_CNTL2_REG</name>
	<description>BLE Control Register 2</description>
	<addressOffset>0x00000200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLE_PHY_ERR_MSK_N</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_ARP_ERR_MSK_N</name>
	<description>When cleared to &quot;0&quot; then it masks the BLE_ARP_ERR_STAT in order to not trigger a BLE_ERROR_IRQ.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_ARP_PHY_ERR_STAT</name>
	<description>When set to &quot;1&quot; then an error occured in BLE ARP sub-block and the BLE_GEN_IRQ will be aserted.
It will be set if the ARP_ERROR or PHY_ERROR will be asserted and if the BLE_ARP_ERR_MSK is set to &quot;1&quot;.
Writing the value &quot;1&quot; will acknowledge and clear this field.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_RSSI_SEL</name>
	<description>0: (default) Select Peak-hold RSSI value during the SYNC_FOUND event:
CS-&gt;RXRSSI[7:0] = RF_RSSI_RESULT_REG-&gt;RSSI_LATCHED_RD[9:2].
1: Select the Average RSSI value during the SYNC_FOUND event:
CS-&gt;RXRSSI[7:0] = RF_RSSI_RESULT_REG-&gt;RSSI_AVG_RD[9:2].</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPLPSTAT</name>
	<description>The status of the BLE_WAKEUP_LP_IRQ. The Interrupt Service Routine of BLE_WAKEUP_LP_IRQ should return only when the WAKEUPLPSTAT is cleared.
Note that BLE_WAKEUP_LP_IRQ is automatically acknowledged after the power up of the Radio Subsystem, plus one Low Power Clock period. </description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SW_RPL_SPI</name>
	<description>Keep to 0. </description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BB_ONLY</name>
	<description>Keep to 0.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_PTI_SOURCE_SEL</name>
	<description>0: Provide to COEX block the PTI value indicated by the Control Structure. Recommended value is &quot;0&quot;.
1: Provide to COEX block the PTI value generated dynamically by the BLE core, which is based on the PTI of the Control Structure.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_CLK_SEL</name>
	<description>BLE Clock Select.
Specifies the BLE master clock absolute frequency in MHz.
Typical values are 16 and 8.
Value depends on the selected XTAL frequency and the value of CLK_RADIO_REG[BLE_DIV] bitfield. For example, if XTAL oscillates at 16MHz and CLK_RADIO_REG[BLE_DIV] = 1 (divide by 2), then BLE master clock frequency is 8MHz and BLE_CLK_SEL should be set to value 8.
The selected BLE master clock frequency (affected by BLE_DIV and BLE_CLK_SEL) must be modified and set only during the initialization time, i.e. before setting BLE_RWBLECNTL_REG[RWBLE_EN] to 1.
Refer also to BLE_RWBLECONF_REG[CLK_SEL].</description>
	<bitRange>[14:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_PWRDN_ALLOW</name>
	<description>This active high signal indicates when it is allowed for the BLE core (embedded in the Radio sub-System power domain) to be powered down.
After the assertion of the BLE_DEEPSLCNTL_REG[DEEP_SLEEP_ON] a hardware sequence based on the Low Power clock will cause the assertion of RADIO_PWRDN_ALLOW. The RADIO_PWRDN_ALLOW will be cleared to &quot;0&quot; when the BLE core exits from the sleep state, i.e. when the BLE_SLP_IRQ will be asserted.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MON_LP_CLK</name>
	<description>The SW can only write a &quot;0&quot; to this bit.
Whenever a positive edge of the low power clock used by the BLE Timers is detected, then the HW will automatically set this bit to &quot;1&quot;. This functionality will not work if BLE Timer is in reset state (refer to CLK_RADIO_REG[BLE_LP_RESET]).
This bit can be used for SW synchronization, to debug the low power clock, etc.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BLE_CLK_STAT</name>
	<description>0: BLE uses low power clock
1: BLE uses master clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BLE_DIAG_OVR</name>
	<description>1: Overrule BLE_DIAG.
0: BLE_DIAG is not overruled.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMACCERRMSK</name>
	<description>Exchange Memory Access Error Mask:
When cleared to &quot;0&quot; the EM_ACC_ERR will not cause an BLE_ERROR_IRQ interrupt.
When set to &quot;1&quot; an BLE_ERROR_IRQ will be generated as long as EM_ACC_ERR is &quot;1&quot;. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMACCERRACK</name>
	<description>Exchange Memory Access Error Acknowledge.
When the SW writes a &quot;1&quot; to this bit then the EMACCERRSTAT bit will be cleared.
When the SW writes &quot;0&quot; it will have no affect.
The read value is always &quot;0&quot;. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EMACCERRSTAT</name>
	<description>Exchange Memory Access Error Status:
The bit is read-only and can be cleared only by writing a &quot;1&quot; at EMACCERRACK bitfield.
This bit will be set to &quot;1&quot; by the hardware when the controller will access an EM page that is not mapped according to the EM_MAPPING value.
When this bit is &quot;1&quot; then the BLE_ERROR_IRQ will be asserted as long as EMACCERRMSK is &quot;1&quot;. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_COEXIFCNTL0_REG</name>
	<description>Coexistence interface Control 0 Register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x003300f3</resetMask>
	<fields><field>
	<name>WLCRXPRIOMODE</name>
	<description>Defines Bluetooth Low Energy packet ble_rx mode behavior.
00: Rx indication excluding Rx Power up delay (starts when correlator is enabled)
01: Rx indication including Rx Power up delay
10: Rx High priority indicator
11: n/a</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCTXPRIOMODE</name>
	<description>Defines Bluetooth Low Energy packet ble_tx mode behavior
00: Tx indication excluding Tx Power up delay
01: Tx indication including Tx Power up delay
10: Tx High priority indicator
11: n/a</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLANTXMSK</name>
	<description>Determines how wlan_tx impact BLE Tx and Rx
00: wlan_tx has no impact (default mode)
01: wlan_tx can stop BLE Tx, no impact on BLE Rx
10: wlan_tx can stop BLE Rx, no impact on BLE Tx
11: wlan_tx can stop both BLE Tx and BLE Rx</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLANRXMSK</name>
	<description>Determines how wlan_rx impact BLE Tx and Rx
00: wlan_rx has no impact
01: wlan_rx can stop BLE Tx, no impact on BLE Rx (default mode)
10: wlan_rx can stop BLE Rx, no impact on BLE Tx
11: wlan_rx can stop both BLE Tx and BLE Rx</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYNCGEN_EN</name>
	<description>Determines whether ble_sync is generated or not.
0: ble_sync pulse not generated
1: ble_sync pulse generated</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>COEX_EN</name>
	<description>Enable / Disable control of the MWS/WLAN Coexistence control
0: Coexistence interface disabled
1: Coexistence interface enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_COEXIFCNTL1_REG</name>
	<description>Coexistence interface Control 1 Register</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1f1f7f7f</resetMask>
	<fields><field>
	<name>WLCPRXTHR</name>
	<description>Applies on ble_rx if WLCRXPRIOMODE equals 10
Determines the threshold for Rx priority setting.
If ble_pti[3:0] output value is greater than WLCPRXTHR, then Rx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface </description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCPTXTHR</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10
Determines the threshold for priority setting.
If ble_pti[3:0] output value is greater than WLCPTXTHR, then Tx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface </description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCPDURATION</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10
Applies on ble_rx if WLCRXPRIOMODE equals 10
Determines how many s the priority information must be maintained
Note that if WLCPDURATION = 0x00, then Tx/Rx priority levels are maintained till Tx/Rx EN are de-asserted. </description>
	<bitRange>[14:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLCPDELAY</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10.
Applies on ble_rx if WLCRXPRIOMODE equals 10.
Determines the delay (in us) in Tx/Rx enables rises the time Bluetooth Low energy Tx/Rx priority has to be provided . </description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_CURRENTRXDESCPTR_REG</name>
	<description>Rx Descriptor Pointer for the Receive Buffer Chained List</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ETPTR</name>
	<description>Exchange Table Pointer that determines the starting point of the Exchange Table</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CURRENTRXDESCPTR</name>
	<description>Rx Descriptor Pointer that determines the starting point of the Receive Buffer Chained List </description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEBUGADDMAX_REG</name>
	<description>Upper limit for the memory zone</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>REG_ADDMAX</name>
	<description>Upper limit for the Register zone indicated by the reg_inzone flag </description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EM_ADDMAX</name>
	<description>Upper limit for the Exchange Memory zone indicated by the em_inzone flag </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEBUGADDMIN_REG</name>
	<description>Lower limit for the memory zone</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>REG_ADDMIN</name>
	<description>Lower limit for the Register zone indicated by the reg_inzone flag </description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EM_ADDMIN</name>
	<description>Lower limit for the Exchange Memory zone indicated by the em_inzone flag </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLCNTL_REG</name>
	<description>Deep-Sleep control register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>EXTWKUPDSB</name>
	<description>External Wake-Up disable
0: RW-BLE Core can be woken by external wake-up
1: RW-BLE Core cannot be woken up by external wake-up </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_STAT</name>
	<description>Indicator of current Deep Sleep clock mux status:
0: RW-BLE Core is not yet in Deep Sleep Mode
1: RW-BLE Core is in Deep Sleep Mode (only low_power_clk is running) </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SOFT_WAKEUP_REQ</name>
	<description>Wake Up Request from BLE Software. Applies when system is in Deep Sleep Mode. It wakes up the BLE Core when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_CORR_EN</name>
	<description>625us base time reference integer and fractional part correction. Applies when system has been woken-up from Deep Sleep Mode. It enables Fine Counter and Base Time counter when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DEEP_SLEEP_ON</name>
	<description>0: BLE Core in normal active mode
1: Request RW-BLE Core to switch in deep sleep mode.
This bit is reset on DEEP_SLEEP_STAT falling edge. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DEEP_SLEEP_IRQ_EN</name>
	<description>Always set to &quot;3&quot; when DEEP_SLEEP_ON is set to &quot;1&quot;.
It controls the generation of BLE_WAKEUP_LP_IRQ. </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLSTAT_REG</name>
	<description>Duration of the last deep sleep phase register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEEPSLDUR</name>
	<description>Actual duration of the last deep sleep phase measured in low_power_clk clock cycle. DEEPSLDUR is set to zero at the beginning of the deep sleep phase, and is incremented at each low_power_clk clock cycle until the end of the deep sleep phase. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLWKUP_REG</name>
	<description>Time (measured in Low Power clock cycles) in Deep Sleep Mode before waking-up the device</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEEPSLTIME</name>
	<description>Determines the time in low_power_clk clock cycles to spend in Deep Sleep Mode before waking-up the device. This ensures a maximum of 37 hours and 16mn sleep mode capabilities at 32kHz. This ensures a maximum of 36 hours and 16mn sleep mode capabilities at 32.768kHz </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGCNTL2_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x0000020c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG7_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG7</name>
	<description>Only relevant when DIAG7_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG7. </description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6</name>
	<description>Only relevant when DIAG6_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG6. </description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5</name>
	<description>Only relevant when DIAG5_EN= 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG5.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4</name>
	<description>Only relevant when DIAG4_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG4.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGCNTL3_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x00000210</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG7_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG7_BIT</name>
	<description>Selects which bit from the DIAG7 word will be forwarded to bit 7 of the BLE DIagnostic Port.</description>
	<bitRange>[30:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG6_BIT</name>
	<description>Selects which bit from the DIAG6 word will be forwarded to bit 6 of the BLE DIagnostic Port.</description>
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG5_BIT</name>
	<description>Selects which bit from the DIAG5 word will be forwarded to bit 5 of the BLE DIagnostic Port.</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG4_BIT</name>
	<description>Selects which bit from the DIAG4 word will be forwarded to bit 4 of the BLE DIagnostic Port.</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG3_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG3_BIT</name>
	<description>Selects which bit from the DIAG3 word will be forwarded to bit 3 of the BLE DIagnostic Port.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2_BIT</name>
	<description>Selects which bit from the DIAG2 word will be forwarded to bit 2 of the BLE DIagnostic Port.</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1_BIT</name>
	<description>Selects which bit from the DIAG1 word will be forwarded to bit 1 of the BLE DIagnostic Port.</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0_BIT</name>
	<description>Selects which bit from the DIAG0 word will be forwarded to bit 0 of the BLE DIagnostic Port.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGCNTL_REG</name>
	<description>Diagnostics Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG3_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG3</name>
	<description>Only relevant when DIAG3_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG3. </description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2</name>
	<description>Only relevant when DIAG2_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG2. </description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1</name>
	<description>Only relevant when DIAG1_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG1. </description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0</name>
	<description>Only relevant when DIAG0_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG0. </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGSTAT_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG3STAT</name>
	<description>Directly connected to ble_dbg3[7:0] output. Debug use only. </description>
	<bitRange>[31:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG2STAT</name>
	<description>Directly connected to ble_dbg2[7:0] output. Debug use only. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG1STAT</name>
	<description>Directly connected to ble_dbg1[7:0] output. Debug use only. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG0STAT</name>
	<description>Directly connected to ble_dbg0[7:0] output. Debug use only. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_EM_BASE_REG</name>
	<description>Exchange Memory Base Register</description>
	<addressOffset>0x00000208</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLE_EM_BASE_16_10</name>
	<description>The physical address on the system memory map of the base of the Exchange Memory.</description>
	<bitRange>[16:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ENBPRESET_REG</name>
	<description>Time in low power oscillator cycles register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TWEXT</name>
	<description>Minimum and recommended value is &quot;TWIRQ_RESET + 1&quot;.
In the case of wake-up due to an external wake-up request, TWEXT specifies the time delay in low power oscillator cycles to deassert BLE_WAKEUP_LP_IRQ.
Refer also to GP_CONTROL_REG[BLE_WAKEUP_REQ].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<bitRange>[31:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TWIRQ_SET</name>
	<description>Minimum value is &quot;TWIRQ_RESET + 1&quot;.
Time in low power oscillator cycles to set BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<bitRange>[20:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TWIRQ_RESET</name>
	<description>Recommended value is 1.
Time in low power oscillator cycles to reset BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...32 ms] for 32kHz; [0...31.25 ms] for 32.768kHz. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ERRORTYPESTAT_REG</name>
	<description>Error Type Status registers</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>CONCEVTIRQ_ERROR</name>
	<description>Indicates whether two consecutive and concurrent ble_event_irq have been generated, and not acknowledged in time by the BLE Software.
0: No error
1: Error occurred</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXDATA_PTR_ERROR</name>
	<description>Indicates whether Rx data buffer pointer value programmed is null: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXDATA_PTR_ERROR</name>
	<description>Indicates whether Tx data buffer pointer value programmed is null during Advertising / Scanning / Initiating events, or during Master / Slave connections with non-null packet length: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXDESC_EMPTY_ERROR</name>
	<description>Indicates whether Rx Descriptor pointer value programmed in register is null: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXDESC_EMPTY_ERROR</name>
	<description>Indicates whether Tx Descriptor pointer value programmed in Control Structure is null during Advertising / Scanning / Initiating events: this is a major programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSFORMAT_ERROR</name>
	<description>Indicates whether CS-FORMAT has been programmed with an invalid value: this is a major software programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LLCHMAP_ERROR</name>
	<description>Indicates Link Layer Channel Map error, happens when actual number of CS-LLCHMAP bit set to one is different from CS-NBCHGOOD at the beginning of Frequency Hopping process
0: No error
1: Error occurred </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADV_UNDERRUN</name>
	<description>Indicates Advertising Interval Under run, occurs if time between two consecutive Advertising packet (in Advertising mode) is lower than the expected value.
0: No error
1: Error occurred </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IFS_UNDERRUN</name>
	<description>Indicates Inter Frame Space Under run, occurs if IFS time is not enough to update and read Control Structure/Descriptors, and/or White List parsing is not finished and/or Decryption time is too long to be finished on time
0: No error
1: Error occurred </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WHITELIST_ERROR</name>
	<description>Indicates White List Timeout error, occurs if White List parsing is not finished on time
0: No error
1: Error occurred</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_CNTL_APFM_ERROR</name>
	<description>Indicates Anticipated Pre-Fetch Mechanism error: happens when 2 consecutive events are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.
0: No error
1: Error occured </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_SCHDL_APFM_ERROR</name>
	<description>Indicates Anticipated Pre-Fetch Mechanism error: happens when 2 consecutive events are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.
0: No error
1: Error occured </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_SCHDL_ENTRY_ERROR</name>
	<description>Indicates Event Scheduler faced Invalid timing programing on two consecutive ET entries (e.g first one with 624s offset and second one with no offset)
0: No error
1: Error occurred </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVT_SCHDL_EMACC_ERROR</name>
	<description>Indicates Event Scheduler Exchange Memory access error, happens when Exchange Memory accesses are not served in time, and blocks the Exchange Table entry read
0: No error
1: Error occurred</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RADIO_EMACC_ERROR</name>
	<description>Indicates Radio Controller Exchange Memory access error, happens when Exchange Memory accesses are not served in time and data are corrupted.
0: No error
1: Error occurred </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKTCNTL_EMACC_ERROR</name>
	<description>Indicates Packet Controller Exchange Memory access error, happens when Exchange Memory accesses are not served in time and Tx/Rx data are corrupted
0: No error
1: Error occurred </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXCRYPT_ERROR</name>
	<description>Indicates real time decryption error, happens when AES-CCM decryption is too slow compared to Packet Controller requests. A 16-bytes block has to be decrypted prior the next block is received by the Packet Controller
0: No error
1: Error occurred </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXCRYPT_ERROR</name>
	<description>Indicates Real Time encryption error, happens when AES-CCM encryption is too slow compared to Packet Controller requests. A 16-bytes block has to be encrypted and prepared on Packet Controller request, and needs to be ready before the Packet Controller has to send ti
0: No error
1: Error occurred </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_FINECNTCORR_REG</name>
	<description>Phase correction value register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>FINECNTCORR</name>
	<description>Phase correction value for the 625us reference counter (i.e. Fine Counter) in us. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_FINETIMECNT_REG</name>
	<description>Fine time reference counter</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>FINECNT</name>
	<description>Value of the current s fine time reference counter. Updated each time SAMPCLK is written. Used by the SW in order to synchronize with the HW, and obtain a more precise sleep duration </description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_FINETIMTGT_REG</name>
	<description>Fine Timer Target value</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>FINETARGET</name>
	<description>Fine Timer Target value on which a ble_finetgtim_irq must be generated. This timer has a precision of 625 usec: interrupt is generated only when FINETARGET = BASETIMECNT </description>
	<bitRange>[26:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_GROSSTIMTGT_REG</name>
	<description>Gross Timer Target value</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>GROSSTARGET</name>
	<description>Gross Timer Target value on which a ble_grosstgtim_irq must be generated. This timer has a precision of 10ms: interrupt is generated only when GROSSTARGET[22:0] = BASETIMECNT[26:4] and BASETIMECNT[3:0] = 0. </description>
	<bitRange>[22:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_INTACK_REG</name>
	<description>Interrupt acknowledge register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SWINTACK</name>
	<description>SW triggered interrupt acknowledgement bit
Software writing 1 acknowledges the SW triggered interrupt. This bit resets SWINTSTAT and SWINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EVENTAPFAINTACK</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt acknowledgement bit
Software writing 1 acknowledges the End of event / Anticipated Pre-Fetch Abort interrupt. This bit resets EVENTAPFAINTSTAT and EVENTAPFAINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FINETGTIMINTACK</name>
	<description>Fine Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Fine Timer interrupt. This bit resets FINETGTIMINTSTAT and FINETGTIMINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>GROSSTGTIMINTACK</name>
	<description>Gross Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Gross Timer interrupt. This bit resets GROSSTGTIMINTSTAT and GROSSTGTIMINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>ERRORINTACK</name>
	<description>Error interrupt acknowledgement bit
Software writing 1 acknowledges the Error interrupt. This bit resets ERRORINTSTAT and ERRORINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CRYPTINTACK</name>
	<description>Encryption engine interrupt acknowledgement bit Software writing 1 acknowledges the Encryption engine interrupt. This bit resets CRYPTINTSTAT and CRYPTINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EVENTINTACK</name>
	<description>End of Event interrupt acknowledgment bit
Software writing 1 acknowledges the End of Advertising / Scanning / Connection interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SLPINTACK</name>
	<description>End of Deep Sleep interrupt acknowledgment bit
Software writing 1 acknowledges the End of Sleep Mode interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RXINTACK</name>
	<description>Packet Reception interrupt acknowledgment bit
Software writing 1 acknowledges the Rx interrupt. This bit resets RXINTSTAT and RXINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CSCNTINTACK</name>
	<description>625us base time reference interrupt acknowledgment bit
Software writing 1 acknowledges the CLKN interrupt. This bit resets CLKINTSTAT and CLKINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>BLE_INTCNTL_REG</name>
	<description>Interrupt controller register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000811f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CSCNTDEVMSK</name>
	<description>CSCNT interrupt mask during event. This bit allows to enable CSCNT interrupt generation during events (i.e. advertising, scanning, initiating, and connection)
0: CSCNT Interrupt not generated during events.
1: CSCNT Interrupt generated during events. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWINTMSK</name>
	<description>SW triggered interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EVENTAPFAINTMSK</name>
	<description>End of event / anticipated pre-fetch abort interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINETGTIMINTMSK</name>
	<description>Fine Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GROSSTGTIMINTMSK</name>
	<description>Gross Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERRORINTMSK</name>
	<description>Error Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTINTMSK</name>
	<description>Encryption engine Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EVENTINTMSK</name>
	<description>End of event Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SLPINTMSK</name>
	<description>Sleep Mode Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXINTMSK</name>
	<description>Rx Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CSCNTINTMSK</name>
	<description>625us Base Time Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_INTRAWSTAT_REG</name>
	<description>Interrupt raw status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SWINTRAWSTAT</name>
	<description>SW triggered interrupt raw status
0: No SW triggered interrupt.
1: A SW triggered interrupt is pending. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTAPFAINTRAWSTAT</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt raw status
0: No End of Event interrupt.
1: An End of Event interrupt is pending. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FINETGTIMINTRAWSTAT</name>
	<description>Fine Target Timer Error interrupt raw status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GROSSTGTIMINTRAWSTAT</name>
	<description>Gross Target Timer interrupt raw status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ERRORINTRAWSTAT</name>
	<description>Error interrupt raw status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTINTRAWSTAT</name>
	<description>Encryption engine interrupt raw status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTINTRAWSTAT</name>
	<description>End of Event interrupt raw status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLPINTRAWSTAT</name>
	<description>Sleep interrupt raw status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXINTRAWSTAT</name>
	<description>Packet Reception interrupt raw status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSCNTINTRAWSTAT</name>
	<description>625us base time reference interrupt raw status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_INTSTAT_REG</name>
	<description>Interrupt status register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SWINTSTAT</name>
	<description>SW triggered interrupt status
0: No SW triggered interrupt.
1: A SW triggered interrupt is pending </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTAPFAINTSTAT</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt status
0: No End of Event interrupt.
1: An End of Event interrupt is pending. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FINETGTIMINTSTAT</name>
	<description>Masked Fine Target Timer Error interrupt status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GROSSTGTIMINTSTAT</name>
	<description>Masked Gross Target Timer interrupt status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ERRORINTSTAT</name>
	<description>Masked Error interrupt status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTINTSTAT</name>
	<description>Masked Encryption engine interrupt status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTINTSTAT</name>
	<description>Masked End of Event interrupt status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLPINTSTAT</name>
	<description>Masked Sleep interrupt status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXINTSTAT</name>
	<description>Masked Packet Reception interrupt status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSCNTINTSTAT</name>
	<description>Masked 625us base time reference interrupt status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RADIOCNTL0_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>BLE_RADIOCNTL1_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XRFSEL</name>
	<description>Extended radio selection field, Must be set to &quot;2&quot;.</description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RADIOCNTL2_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>BLE_RADIOCNTL3_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x7fffffff</resetMask>
	
</register><register>
	<name>BLE_RADIOPWRUPDN_REG</name>
	<description>RX/TX power up/down phase register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d203d2</resetValue>
	<resetMask>0x7fff0fff</resetMask>
	<fields><field>
	<name>RTRIP_DELAY</name>
	<description>Defines round trip delay value. This value correspond to the addition of data latency in Tx and data latency in Rx. Value is in usec.</description>
	<bitRange>[30:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXPWRUP</name>
	<description>This register holds the length in s of the RX power up phase for the current radio device. Default value is 210 usec (reset value). Operating range depends on the selected radio. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPWRDN</name>
	<description>This register extends the length in s of the TX power down phase for the current radio device. Default value is 3 usec (reset value). Operating range depends on the selected radio. </description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPWRUP</name>
	<description>This register holds the length in s of the TX power up phase for the current radio device. Default value is 210 usec (reset value). Operating range depends on the selected radio. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RFTESTCNTL_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>INFINITERX</name>
	<description>Applicable in RF Test Mode only
0: Normal mode of operation
1: Infinite Rx window </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXPKTCNTEN</name>
	<description>Applicable in RF Test Mode only
0: Rx packet count disabled
1: Rx packet count enabled, and reported in CS-RXCCMPKTCNT and BLE_RFTESTRXSTAT_REG[RXPKTCNT] on RF abort command </description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INFINITETX</name>
	<description>Applicable in RF Test Mode only
0: Normal mode of operation.
1: Infinite Tx packet / Normal start of a packet but endless payload </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXLENGTHSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Normal mode of operation: TxDESC-TXADVLEN controls the Tx packet payload size
1: Uses BLE_RFTESTCNTL_REG[TXLENGTH] packet length (can support up to 512 bytes transmit) </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRBSTYPE</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload are PRBS9 type
1: Tx Packet Payload are PRBS15 type </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPLDSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload source is the Control Structure
1: Tx Packet Payload are PRBS generator </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPKTCNTEN</name>
	<description>Applicable in RF Test Mode only
0: Tx packet count disabled
1: Tx packet count enabled, and reported in CS-TXCCMPKTCNT and BLE_RFTESTTXSTAT_REG[TXPKTCNT] on RF abort command </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXLENGTH</name>
	<description>Applicable only for Tx/Rx RF Test mode, and valid when BLE_RFTESTCNTL_REG[TXLENGTHSRC] = 1
Tx packet length in number of byte </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RFTESTRXSTAT_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXPKTCNT</name>
	<description>Reports number of correctly received packet during Test Modes (no sync error, no CRC error).
Value is valid if BLE_RFTESTCNTL_REG[RXPKTCNTEN] is set</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RFTESTTXSTAT_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXPKTCNT</name>
	<description>Reports number of transmitted packet during Test Modes.
Value is valid if BLE_RFTESTCNTL_REG[TXPKTCNTEN] is set</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RWBLECNTL_REG</name>
	<description>BLE Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MASTER_SOFT_RST</name>
	<description>Reset the complete BLE Core except registers and timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[31:31]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>MASTER_TGSOFT_RST</name>
	<description>Reset the timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[30:30]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>REG_SOFT_RST</name>
	<description>Reset the complete register block, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.
Note that INT STAT will not be cleared, so the user should also write to BLE_INTACK_REG after the SW Reset</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWINT_REQ</name>
	<description>Forces the generation of ble_sw_irq when written with a 1, and proper masking is set. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[28:28]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RFTEST_ABORT</name>
	<description>Abort the current RF Testing defined as per CS-FORMAT when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.
Note that when RFTEST_ABORT is requested:
1) In case of infinite Tx, the Packet Controller FSM stops at the end of the current byte in process, and processes accordingly the packet CRC.
2) In case of Infinite Rx, the Packet Controller FSM either stops as the end of the current Packet reception (if Access address has been detected), or simply stop the processing switching off the RF.</description>
	<bitRange>[26:26]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>ADVERT_ABORT</name>
	<description>Abort the current Advertising event when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[25:25]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SCAN_ABORT</name>
	<description>Abort the current scan window when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<bitRange>[24:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>MD_DSB</name>
	<description>0: Normal operation of MD bits management
1: Allow a single Tx/Rx exchange whatever the MD bits are.
value forced by SW from Tx Descriptorvalue just saved in Rx Descriptor during reception</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SN_DSB</name>
	<description>0: Normal operation of Sequence number
1: Sequence Number Management disabled:
value forced by SW from Tx Descriptorvalue ignored in Rx, where no SN error reported.</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NESN_DSB</name>
	<description>0: Normal operation of Acknowledge
1: Acknowledge scheme disabled:
value forced by SW from Tx Descriptorvalue ignored in Rx, where no NESN error reported.</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPT_DSB</name>
	<description>0: Normal operation. Encryption / Decryption enabled.
1: Encryption / Decryption disabled.
Note that if CS-CRYPT_EN is set, then MIC is generated, and only data encryption is disabled, meaning data sent are plain data.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WHIT_DSB</name>
	<description>0: Normal operation. Whitening enabled.
1: Whitening disabled.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRC_DSB</name>
	<description>0: Normal operation. CRC removed from data stream.
1: CRC stripping disabled on Rx packets, CRC replaced by 0x000 in Tx.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOP_REMAP_DSB</name>
	<description>0: Normal operation. Frequency Hopping Remapping algorithm enabled.
1: Frequency Hopping Remapping algorithm disabled</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADVERTFILT_EN</name>
	<description>Advertising Channels Error Filtering Enable control
0: BLE Core reports all errors to RW-BLE Software
1: BLE Core reports only correctly received packet, without error to RW-BLE Software</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RWBLE_EN</name>
	<description>0: Disable BLE Core Exchange Table pre-fetch mechanism.
1: Enable BLE Core Exchange table pre-fetch mechanism.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXWINSZDEF</name>
	<description>Default Rx Window size in us. Used when device:

is master connectedperforms its second receipt.0 is not a valid value. Recommended value is 10 (in decimal).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYNCERR</name>
	<description>Indicates the maximum number of errors allowed to recognize the synchronization word.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RWBLECONF_REG</name>
	<description>Configuration register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0f02001f</resetValue>
	<resetMask>0x3f7f3f7f</resetMask>
	<fields><field>
	<name>ADD_WIDTH</name>
	<description>Value of the RW_BLE_ADDRESS_WIDTH parameter concerted into binary.</description>
	<bitRange>[29:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFIF</name>
	<description>Radio Interface ID </description>
	<bitRange>[22:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_SEL</name>
	<description>Operating Frequency (in MHz) </description>
	<bitRange>[13:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DECIPHER</name>
	<description>0: AES deciphering not present</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMMODE</name>
	<description>0: BLE Core is used as a standalone BLE device </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INTMODE</name>
	<description>1: Interrupts are trigger level generated, i.e. stays active at 1 till acknowledgement </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COEX</name>
	<description>1: WLAN Coexistence mechanism present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USEDBG</name>
	<description>1: Diagnostic port instantiated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USECRYPT</name>
	<description>1: AES-CCM Encryption block present </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSWIDTH</name>
	<description>Processor bus width:
1: 32 bits </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXMICVAL</name>
	<description>AES-CCM plain MIC value. Valid on once MIC has been extracted from Rx packet. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_SAMPLECLK_REG</name>
	<description>Samples the Base Time Counter</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SAMP</name>
	<description>Writing a 1 samples the Base Time Counter value in BASETIMECNT register. Resets at 0 when action is performed. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>BLE_SWPROFILING_REG</name>
	<description>Software Profiling register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SWPROFVAL</name>
	<description>Software Profiling register: used by BLE Software for profiling purpose: this value is copied on Diagnostic port </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_TIMGENCNTL_REG</name>
	<description>Timing Generator Register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>APFM_EN</name>
	<description>Controls the Anticipated pre-Fetch Abort mechanism
0: Disabled
1: Enabled </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PREFETCHABORT_TIME</name>
	<description>Defines the instant in usec at which immediate abort is required after anticipated pre-fetch abort.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PREFETCH_TIME</name>
	<description>Defines Exchange Table pre-fetch instant in us </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_TXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXMICVAL</name>
	<description>AES-CCM plain MIC value. Valid on when MIC has been calculated (in Tx) </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_VERSION_REG</name>
	<description>Version register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07010000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TYP</name>
	<description>BLE Core Type</description>
	<bitRange>[31:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>REL</name>
	<description>BLE Core version Major release number.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UPG</name>
	<description>BLE Core upgrade Upgrade number.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUILD</name>
	<description>BLE Core Build Build number.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_WLNBDEV_REG</name>
	<description>Devices in white list</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>NBPRIVDEV</name>
	<description>Number of private devices in the white list.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NBPUBDEV</name>
	<description>Number of public devices in the white list. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_WLPRIVADDPTR_REG</name>
	<description>Start address of private devices list</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WLPRIVADDPTR</name>
	<description>Start address pointer of the private devices white list. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_WLPUBADDPTR_REG</name>
	<description>Start address of public devices list</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WLPUBADDPTR</name>
	<description>Start address pointer of the public devices white list. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHIP_VERSION</name>
	<version>1.0</version>
	<description>CHIP_VERSION registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>254</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CHIP_ID1_REG</name>
	<description>Chip identification register 1.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID1</name>
	<description>First character of device type &quot;2632&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID2_REG</name>
	<description>Chip identification register 2.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000036</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID2</name>
	<description>Second character of device type &quot;2632&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID3_REG</name>
	<description>Chip identification register 3.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000033</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID3</name>
	<description>Third character of device type &quot;2632&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID4_REG</name>
	<description>Chip identification register 4.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID4</name>
	<description>Fourth character of device type &quot;2632&quot; in ASCII.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_REVISION_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_REVISION</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_SWC_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CHIP_SWC</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST1_REG</name>
	
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_LAYOUT_REVISION</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST2_REG</name>
	
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CHIP_METAL_OPTION</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_AON</name>
	<version>1.0</version>
	<description>CRG_AON registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>242</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GP_DATA_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>ANA_SPARE</name>
	
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DISABLE_CLAMP_OVERRULE</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_GP_DATA</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>HIBERN_CTRL_REG</name>
	<description>Hibernation control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>HIBERN_WKUP_MASK</name>
	<description>Selects which pin to wakeup from</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HIBERN_WKUP_POLARITY</name>
	<description>Selects the polarity of the wakeup source. The polarity must be chosen such that the ANA_STATUS_REG[CLKLESS_WAKEUP_STAT] is '1'. Any change on the selected GPIOs will make the CLKLESS_WAKEUP_STAT go to '0', and wakeup the system from hibernation.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HIBERNATION_ENABLE</name>
	<description>Enables the hibernation mode when sleeping
0: deep sleep mode, PD_SLP remains on
1: hibernation mode, PD_SLP goes off. REMAP_ADR0 needs to be set to the correct source to boot from before going to sleep.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>HWR_CTRL_REG</name>
	<description>Hardware Reset control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DISABLE_HWR</name>
	<description>Disables the RST functionality on P00</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>PAD_LATCH_EN</name>
	<description>Controls the state retention of the pads.
0: latches are closed, pads retain their state.
1: latches are open, new control values have immediate effect</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_AON_CTRL_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>FORCE_RUNNING_COMP_DIS</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RET_TRIM</name>
	<description>VDD clamp level setting for hibernation mode</description>
	<bitRange>[13:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMP_VCONT_SLP_DISABLE</name>
	<description>Disable vcont comparator in SLP</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_MODE_FORCE</name>
	<description>0x:automatic selection of boost mode
11: force boost mode
10: force buck mode</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_VBAT_DISABLE</name>
	<description>Do not charge vbat high in boost mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_LOW_SPEED_FORCE</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_HIGH_SPEED_FORCE</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_RST_MASK</name>
	<description>Mask rst from por_vbat_high</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_RST_MASK</name>
	<description>Mask rst from por_vbat_low</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_HL_CONNECT_RES_CTRL</name>
	<description>00: OFF
01: Forced ON
10: Active: automatic control, Sleep: forced ON
11: Automatic control</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RAM_LPMX_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>RAMx_LPMX</name>
	<description>RAM[3:1] Transparent Light Sleep (TLS) Core Enable for System RAMs. Assert low to enable the TLS core feature, which will result in lower leakage current.
In case VDD is below 0.81V, it is necessary to hold this pin high to maintain data retention.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_STAT_REG</name>
	<description>Reset status register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>WDOGRESET_STAT</name>
	<description>Indicates that a Watchdog has happened.
This bit is also set with a PowerOn Reset</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWRESET_STAT</name>
	<description>Indicates that a SW Reset has been requested.
The SW reset is requested by SYS_CTRL_REG[SW_RESET] or SCB-&gt;AIRCR inside the ARM.
This bit is also set with a PowerOn Reset</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HWRESET_STAT</name>
	<description>Indicates that a HW Reset has happened
This bit is also set with a PowerOn Reset</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PORESET_STAT</name>
	<description>Indicates that a PowerOn Reset has happened</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_VDD_REG</name>
	
	<addressOffset>0x000000f0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>LDOS_DISABLE</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TEST_VDD</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_TIM</name>
	<version>1.0</version>
	<description>CRG_TIM registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50004200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>80</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_RTCDIV_REG</name>
	<description>Divisor for RTC 100Hz clock</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00051ea8</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>RTC_RESET_REQ</name>
	<description>Reset request for the RTC module</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_ENABLE</name>
	<description>Enable for the 100 Hz generation for the RTC block</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_DENOM</name>
	<description>Selects the denominator for the fractional division:
0b0: 1000
0b1: 1024</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_INT</name>
	<description>Integer divisor part for RTC 100Hz generation</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_FRAC</name>
	<description>Fractional divisor part for RTC 100Hz generation.
if RTC_DIV_DENOM=1, &lt;RTC_DIV_FRAC&gt; out of 1024 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;
If RTC_DIV_DENOM=0, &lt;RTC_DIV_FRAC&gt; out of 1000 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_TOP</name>
	<version>1.0</version>
	<description>CRG_TOP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>86</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>ANA_STATUS_REG</name>
	<description>Status bit of analog (power management) circuits</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>CLKLESS_WAKEUP_STAT</name>
	<description>Indicates the output of the Clockless wakeup XOR tree. If this signal is '0', the chip will wake up.
Use the HIBERN_WKUP_POLARITY bit to set the value to '1' before going into hibernation mode.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FORCE_RUNNING</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_GPADC_OK</name>
	<description>Indicates that LDO_GPADC output is OK </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_XTAL_OK</name>
	<description>Indicates that LDO_XTAL output is OK </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_SELECTED</name>
	<description>0: Buck mode detected
1: Boost mode detected</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>POR_VBAT_HIGH</name>
	<description>Output of VBAT_HIGH supply rail voltage monitoring circuit.
0: Voltage level on VBAT_HIGH is lower than POR VBAT_HIGH threshold VTH_L (rail not ok, will result in reset if not masked)
1: Voltage level on VBAT_HIGH is higher than POR VBAT_HIGH threshold VTH_H (rail ok, reset released) </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>POR_VBAT_LOW</name>
	<description>Output of VBAT_LOW supply rail voltage monitoring circuit.
0: Voltage level on VBAT_LOW is lower than POR VBAT_LOW threshold VTH_L (rail not ok, will result in reset if not masked)
1: Voltage level on VBAT_LOW is higher than POR VBAT_LOW threshold VTH_H (rail ok, reset released) </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BANDGAP_OK</name>
	<description>Indicates that BANDGAP is OK </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBAT_HIGH_NOK</name>
	<description>Indicates that VBAT_HIGH &lt; VBAT_LOW -50 mV </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBAT_HIGH_OK</name>
	<description>Indicates that VBAT_HIGH &gt; VBAT_LOW +50 mV </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCDC_OK</name>
	<description>Indicates that VBAT_LOW (buck mode) or VBAT_HIGH (boost mode) is OK </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_LOW_OK</name>
	<description>Indicates that LDO_LOW output is OK
(only valid for high current mode) </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_CORE_OK</name>
	<description>Indicates that LDO_CORE output is OK </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BANDGAP_REG</name>
	<description>Bandgap trimming</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>BGR_ITRIM</name>
	<description>Trim setting for bandgap bias current
10000 -&gt; -25%
....
11111 -&gt; ~0%
00000 -&gt; ~0% (typ)
...
01111 -&gt; +32%</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_TRIM</name>
	<description>Trim setting for bandgap voltage
10000 -&gt; -6.4%
....
11111 -&gt; ~0%
00000 -&gt; ~0% (typ)
...
01111 -&gt; +5.8%</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_AMBA_REG</name>
	<description>HCLK, PCLK, divider and clock gates</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>OTP_ENABLE</name>
	<description>Clock enable for OTP controller </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCLK_DIV</name>
	<description>APB interface clock (PCLK). Divider is cascaded with HCLK_DIV. PCLK is HCLK divided by:
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HCLK_DIV</name>
	<description>AHB interface and microprocessor clock (HCLK). HCLK is source clock divided by:
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_CTRL_REG</name>
	<description>Clock control register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>RUNNING_AT_XTAL32M</name>
	<description>Indicates that the XTAL32M clock is used as clock, and may not be switched off </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_RC32M</name>
	<description>Indicates that the RC32M clock is used as clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_LP_CLK</name>
	<description>Indicates that either the LP_CLK is being used as system clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LP_CLK_SEL</name>
	<description>Sets the clock source of the LowerPower clock
0x0: RC32K
0x1: RCX
0x2: XTAL32K through the oscillator with an external Crystal.
0x3: XTAL32K through an external square wave generator (set PID of P0[3] to FUNC_GPIO)
Change this setting before using this clock, and while RUNNING_AT_LP_CLK == 0.</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_DISABLE</name>
	<description>Setting this bit instantaneously disables the 32 MHz crystal oscillator. Also, after sleep/wakeup cycle, the oscillator will not be enabled. This bit may not be set to '1'when &quot;RUNNING_AT_XTAL32M is '1' to prevent deadlock. After resetting this bit, wait for XTAL32M_SETTLED or XTAL32M_TRIM_READY to become '1' before switching to XTAL32M clock source. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CLK_SEL</name>
	<description>Selects the clock source.
0x0: XTAL32M (check the XTAL32M_SETTLED and XTAL32M_TRIM_READY bits!!)
0x1: RC32M
0x2/0x3: LP_CLK</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_FREQ_TRIM_REG</name>
	<description>Xtal frequency trimming register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTAL32M_TRIM</name>
	<description>Xtal frequency fine trimming register.
0x00: highest frequency
0xFF: lowest frequency </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_PER_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000800</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>QUAD_ENABLE</name>
	<description>Enable the Quadrature clock </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enable SPI clock </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART1_ENABLE</name>
	<description>Enable UART1 clock </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enable UART2 clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enable I2C clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPCT_ENABLE</name>
	<description>Enable Wakeup CaptureTimer clock </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_ENABLE</name>
	<description>Enable TIMER0 and TIMER2 clock </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_DIV</name>
	<description>Division factor for TIMER0
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RADIO_REG</name>
	<description>Radio PLL control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLE_ENABLE</name>
	<description>Enable the BLE core clocks </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_LP_RESET</name>
	<description>Reset for the BLE LP timer </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_DIV</name>
	<description>Division factor for BLE core blocks
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8
The programmed frequency should not be lower than 8 MHz and not faster than the programmed CPU clock frequency. Refer also to BLE_CNTL2_REG[BLE_CLK_SEL].</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCU_ENABLE</name>
	<description>Enable the RF control Unit clock </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RC32K_REG</name>
	<description>32 kHz RC oscillator register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000e</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>RC32K_TRIM</name>
	<description>0000 = lowest frequency
0111 = default
1111 = highest frequency </description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_DISABLE</name>
	<description>Instantly disables the 32kHz RC oscillator
Sleep cycles cannot happen with this clock disabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RC32M_REG</name>
	<description>Fast RC control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000078e</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>RC32M_COSC</name>
	<description>C-adjust of RC-oscillator
A higher value of COSC results in a lower frequency</description>
	<bitRange>[10:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_RANGE</name>
	<description>Coarse adjust
A higher value of RANGE results in a higher frequency, values 2 and 3 are equal</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_BIAS</name>
	<description>Bias adjustment</description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_DISABLE</name>
	<description>Instantly disables the 32MHz RC oscillator
Disabling of the oscillator during sleep happens automatically.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCX_REG</name>
	<description>RCX-oscillator control register</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000afc</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RCX_BIAS</name>
	<description>LDO bias current.
0x0: minimum
0xF: maximum</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_C0</name>
	<description>Add unit capacitance to RC-time delay.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_CADJUST</name>
	<description>Adjust capacitance part of RC-time delay.
0x00: minimum capacitance
0x1F: maximum capacitance</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_RADJUST</name>
	<description>Adjust resistance part of RC-time delay. Lower resistance increases power consumption.
0x0: maximum resistance
0x1: minimum resistance</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_ENABLE</name>
	<description>Enable the RCX oscillator</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_XTAL32K_REG</name>
	<description>32 kHz XTAL oscillator register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000002e</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>XTAL32K_XTAL1_BIAS_DISABLE</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_DISABLE_AMPREG</name>
	<description>Setting this bit disables the amplitude regulation of the XTAL32kHz oscillator.
Set this bit to '1' for an external clock to XTAL32Kp
Keep this bit '0' with a crystal between XTAL32Kp and XTAL32Km</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_CUR</name>
	<description>Bias current for the 32kHz XTAL oscillator. 0000 is minimum, 1111 is maximum, 0011 is default. For each application there is an optimal setting for which the start-up behavior is optimal </description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_RBIAS</name>
	<description>Setting for the bias resistor. 00 is maximum, 11 is minimum. Prefered setting will be provided by Dialog </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_ENABLE</name>
	<description>Enables the 32kHz XTAL oscillator.
Also set GP_DATA_REG[P03_P04_FILT_DIS] = 1 for lowest current consumption.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_CTRL_REG</name>
	<description>Power Management Unit control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>MAP_BANDGAP_EN</name>
	<description>Enable wakeup diagnostics mapping. When set, these functions are mapped (please set direction to output)
P0[2]: BANDGAP_ENABLE
P0[1]: Power WOKENUP
Note: P0[2] assigned also to SWD_CLK, thus the debugger must be detached before entering into sleep mode with MAP_BANDGAP_EN=1. Refer also to SYS_STAT_REG-&gt;DBG_IS_UP.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_COPY_DIV</name>
	<description>Sets the HCLK division during OTP mirroring </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_SLEEP</name>
	<description>Put the digital part of the radio in powerdown </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SLEEP</name>
	<description>Put PD_TIM in powerdown </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_ON_WAKEUP</name>
	<description>Perform a Hardware Reset after waking up. Booter will be started. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_SLEEP_REG</name>
	<description>Bandgap refresh interval during sleep</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000080</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>BG_REFRESH_INTERVAL</name>
	<description>Defines the refresh interval of reference voltages (bandgap activation and sampling), in units of 2ms.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_PIN_REG</name>
	<description>Selects a GPIO pin for POR generation</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>POR_PIN_POLARITY</name>
	<description>0: Active Low
1: Active High
Note: This applies only for the GPIO pin. Reset pad has a fixed polarity
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_PIN_SELECT</name>
	<description>Selects the GPIO which is used for POR generation.
0x0: GPIO pin POReset disabled
0x1: P0_0
0x2: P0_1
...
0xB: P0_10
0xC: P0_11
0xD - 0xF: reserved</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_TIMER_REG</name>
	<description>Time for POR to happen</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000018</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>POR_TIME</name>
	<description>Time for the POReset to happen.
Formula:
Time = POR_TIME x 4096 x RC32k clock period
Default value: ~3 seconds
When set to 0x00, the POR TIMER is disabled.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_CTRL_REG</name>
	<description>Power management control</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VBAT_HL_CONNECT_MODE</name>
	<description>Sets the control mode fo the switch between VBAT_HIGH and VBAT_LOW
0: Manual (default)
1: Automatic (boost mode only)</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_HYST_DIS</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_HYST_SEL</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_HIGH_DISABLE</name>
	<description>Disable por_vbat_high circuit</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_HYST_DIS</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_HYST_SEL</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VBAT_LOW_DISABLE</name>
	<description>Disable por_vbat_low circuit</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CP_DISABLE</name>
	<description>Disables LDO_CORE charge-pump circuit</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_HOLD_FORCE</name>
	<description>Forces LDO references in HOLD mode
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_LOW_CTRL_REG</name>
	<description>00: High-current mode in active, LDO_LOW OFF in sleep
01: LDO_LOW OFF
10: Low-current mode in active, Low-current mode in sleep
11: High-current mode in active, Low-current mode in sleep</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_DISABLE</name>
	<description>Disables LDO_CORE</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_ENABLE</name>
	<description>LDO_CORE_RETENTION
0: Disabled
1: Enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_HL_CONNECT</name>
	<description>Switch between VBAT_HIGH and VBAT_LOW
0: Open
1: Closed</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMP_VBAT_HIGH_OK_ENABLE</name>
	<description>Enable cmp_vbat_high_ok</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMP_VBAT_HIGH_NOK_ENABLE</name>
	<description>Enable cmp_vbat_high_nok</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_LEVEL_REG</name>
	<description>Power management level and trim settings</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001a3e</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>DCDC_TRIM</name>
	<description>Delta from DCDC_LEVEL nominal value
000: -75 mV
001: -50 mV
010: -25 mV
011: 0 (default)
100: +25 mV
101: +50 mV
110: +75 mV
111: +100 mV</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_LEVEL</name>
	<description>00: 1.1 V
01: 1.8 V (default)
10: 2.5 V
11: 3.0 V</description>
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_CUR_TRIM</name>
	
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_XTAL_TRIM</name>
	<description>Delta from 0.9 V nominal value
000: -75 mV
001: -50 mV
010: -25 mV
011: 0 (default)
100: +25 mV
101: +50 mV
110: +75 mV
111: +100 mV</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_LOW_TRIM</name>
	<description>Delta from 1.1 V nominal value
000: -75 mV
001: -50 mV
010: -25 mV
011: 0 (default)
100: +25 mV
101: +50 mV
110: +75 mV
111: +100 mV (coldboot)</description>
	<bitRange>[3:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_LEVEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RAM_PWR_CTRL_REG</name>
	<description>Control power state of System RAMS</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RAM3_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_PWR_CTRL</name>
	<description>Power state control of the individual RAMs. May only change when the memory isn't accessed.
When in Active or Sleep mode:
0x0: Normal operation
0x1: Normal operation
0x2: Retained (no access possible)
0x3: Off (memory content corrupted)
When in Extended Sleep, Deep Sleep or Hibernation mode
0x0: Retained
0x1: Off (memory content corrupted)
0x2: Retained
0x3: Off (memory content corrupted)</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_CTRL_REG</name>
	<description>System Control register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x000087ff</resetMask>
	<fields><field>
	<name>SW_RESET</name>
	<description>Writing a '1' to this bit will reset the device, except for:
SYS_CTRL_REG
CLK_FREQ_TRIM_REG
... </description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIMEOUT_DISABLE</name>
	<description>Disables timeout in Power statemachine. By default, the statemachine continues if after 2 ms the blocks are not started up. This can be read back from
ANA_STATUS_REG. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEBUGGER_ENABLE</name>
	<description>Enable the debugger. This bit is set by the booter according to the OTP header. If not set, the SWDIO and SW_CLK can be used as gpio ports.
0x0: no debugger enabled.
0x1: SW_CLK = P0[2], SW_DIO=P0[5]
0x2: SW_CLK = P0[2], SW_DIO=P0[1]
0x3: SW_CLK = P0[2], SW_DIO=P0[10]</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_RESET_REQ</name>
	<description>Reset request for the OTP controller. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_COPY</name>
	<description>Enables OTP to SysRAM copy action after waking up PD_SYS </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_PHASE</name>
	<description>Sets the development phase mode.

If this bit is set, in combination with the OTP_COPY bit, the OTP DMA will emulate the OTP mirroring to System RAM.
No actual writing to RAM is done, but the exact same amount of time is spend as if the mirroring would take place. This is to mimic the behavior as if the System Code is already in OTP, and the mirroring takes place after waking up, but the (development) code still resides in an external source.
If this bit is set to '0' and OTP_COPY='1', then the OTP DMA will actually do the OTP mirroring at wakeup.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_ADR0</name>
	<description>Controls which memory is located at address 0x0000 for execution.
0x0: ROM
0x1: OTP
0x2: RAM (SysRAM1)
0x3: RAM (SysRAM3, 28 kBytes offset)
This bitfield only takes affect after a Software Reset.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_STAT_REG</name>
	<description>System status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000045</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTAL32M_SETTLED</name>
	<description>Indicates that XTAL32M has had its settle time, as defined by TRIM_CTRL_REG[XTAL_SETTLE_N]</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_TRIM_READY</name>
	<description>Indicates that XTAL trimming mechanism is ready, i.e. the trimming equals CLK_FREQ_TRIM_REG. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBG_IS_UP</name>
	<description>Indicates that the SW debugger is attached and in connection with the ARM.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_UP</name>
	<description>Indicates that PD_TIM is functional </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_DOWN</name>
	<description>Indicates that PD_TIM is in power down </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_UP</name>
	<description>Indicates that PD_RAD is functional </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_DOWN</name>
	<description>Indicates that PD_RAD is in power down </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TRIM_CTRL_REG</name>
	<description>Control trimming of the XTAL32M</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003f22</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>XTAL_SETTLE_N</name>
	<description>Designates that the XTAL can be safely used as the CPU clock. When XTAL_CLK_CNT reases this value, the signal XTAL32M_SETTLED bit in the SYS_STAT_REG will be set. Counts in steps of 64 xtal clock-cycles.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL_TRIM_SELECT</name>
	<description>Select which source controls the XTAL trimming
0b00: xtal counter. Starts XTAL32M_START_REG[XTAL32M_START] after COUNT_N * 32 xtal pulses trim is changed to CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b01: xtal OK filter. Starts with CLK_FREQ_TRIM_REG[XTAL32M_START], when xtal amplitude is ramping is changed to CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b10: statically forced off. Only uses CLK_FREQ_TRIM_REG[XTAL32M_TRIM].
0b11: xtal OK filter, 2 stage. Starts with CLK_FREQ_TRIM_REG[XTAL32M_START] switches to CLK_FREQ_TRIM_REG[XTAL32M_RAMP] after timeout (32us), and switches to CLK_FREQ_TRIM_REG[XTAL32M_TRIM] when xtal amplitude is ramping up.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL_COUNT_N</name>
	<description>Defines the number of XTAL cycles to be counted, before the xtal trimming is applied, in steps of 64 cycles.
0x01: 64
0x02: 128
0x3f: 4032</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL0_REG</name>
	<description>Control bits for XTAL32M</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000015</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>XTAL32M_SPARE</name>
	
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_AMPL_TRIM</name>
	<description>Core amplitude trimming</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_CUR_SET</name>
	<description>Core current trim setting</description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_AMPL_REG_NULLBIAS</name>
	<description>Keep bias in ampl detector alive, even when there is a large drive</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCBLOCK_ENABLE</name>
	<description>Enable dcblock/high pass filter circuit</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_START_REG</name>
	<description>Trim values for XTAL32M</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000aa</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL32M_RAMP</name>
	<description>Xtal frequency trimming register.
0x00 : highest frequency
0xFF :lowest frequency</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_START</name>
	<description>Xtal frequency trimming register.
0x0 = highest frequency
0xF = lowest frequency.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TRSTAT_REG</name>
	<description>Read back value of current XTAL trimming</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTAL32M_TRSTAT</name>
	<description>Reads value of the current XTAL trimming</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTALRDY_CTRL_REG</name>
	<description>Control register for XTALRDY IRQ</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTALRDY_CNT</name>
	<description>Number of 32kHz cycles between the crystal is enabled, and the XTALRDY_IRQ is fired. 0x00: no interrupt
</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTALRDY_STAT_REG</name>
	
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>XTALRDY_STAT</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPADC</name>
	<version>1.0</version>
	<description>GPADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GP_ADC_CLEAR_INT_REG</name>
	<description>General Purpose ADC Clear Interrupt Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL2_REG</name>
	<description>General Purpose ADC Second Control Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000210</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_STORE_DEL</name>
	<description>0: Data is stored after handshake synchronisation
1: Data is stored 2 ADC_CLK cycles after internal start trigger
7: Data is stored 8 ADC_CLK cycles after internal start trigger</description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SMPL_TIME</name>
	<description>0: The sample time (switch is closed) is two ADC_CLK cycles
1: The sample time is 1*8 ADC_CLK cycles
2: The sample time is 2*8 ADC_CLK cycles
15: The sample time is 15*8 ADC_CLK cycles</description>
	<bitRange>[12:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONV_NRS</name>
	<description>0: 1 sample is taken or 2 in case ADC_CHOP is active.
1: 2 samples are taken.
2: 4 samples are taken.
7: 128 samples are taken.</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_CM</name>
	<description>Common mode adjust for offset shifter. Input range is CM +/- 450mV.
0: CM = 1.25V (Input range 0.80 - 1.70)
1: CM = 1.30V (Input range 0.85 - 1.75) (default)
2: CM = 1.35V (Input range 0.90 - 1.80)
3: CM = 1.40V (input range 0.95 - 1.85)</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_EN</name>
	<description>0: Disable input shifter
1: Enable input shifter (900mV - 1800mV shifted to 0mV - 900mV)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_I20U</name>
	<description>1: Adds 20uA constant load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_ATTN</name>
	<description>0: No attenuator (input voltages up to 0.9V allowed)
1: Enabling 2x attenuator (input voltages up to 1.8V allowed)
2: Enabling 3x attenuator (input voltages up to 2.7V allowed)
3: Enabling 4x attenuator (input voltages up to 3.6V allowed)
Enabling the attenuator requires a longer sampling time.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL3_REG</name>
	<description>General Purpose ADC Third Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_INTERVAL</name>
	<description>Defines the interval between two ADC conversions in case GP_ADC_CONT is set.
0: No extra delay between two conversions.
1: 1.024 ms interval between two conversions.
2: 2.048 ms interval between two conversions.
255: 261.12 ms interval between two conversions.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN_DEL</name>
	<description>Defines the delay for enabling the ADC after enabling the LDO.
0: Not allowed
1: 4x ADC_CLK period.
n: n*4x ADC_CLK period.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>DIE_TEMP_EN</name>
	<description>Enables the die-temperature sensor. Output can be measured on GPADC input 4.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_GAIN_SEL</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_LDO_HOLD</name>
	<description>0: GPADC LDO tracking bandgap reference
1: GPADC LDO hold sampled bandgap reference</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CHOP</name>
	<description>0: Chopper mode off
1: Chopper mode enabled. Takes two samples with opposite GP_ADC_SIGN to cancel the internal offset voltage of the ADC; Highly recommended for DC-measurements.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SIGN</name>
	<description>0: Default
1: Conversion with opposite sign at input and output to cancel out the internal offset of the ADC and low-frequency</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MUTE</name>
	<description>0: Normal operation
1: Mute ADC input. Takes sample at mid-scale (to dertermine the internal offset and/or noise of the ADC with regards to VDD_REF which is also sampled by the ADC).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SE</name>
	<description>0: Differential mode
1: Single ended mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MINT</name>
	<description>0: Disable (mask) GP_ADC_INT.
1: Enable GP_ADC_INT to ICU.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to GP_ADC_CLEAR_INT_REG.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GP_ADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the GP_ADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in GP_ADC_RESULT_REG. Still GP_ADC_START has to be set to start the execution. The time between conversions is configurable with GP_ADC_INTERVAL.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN</name>
	<description>0: LDO is off and ADC is disabled..
1: LDO is turned on and afterwards the ADC is enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFN_REG</name>
	<description>General Purpose ADC Negative Offset Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFN</name>
	<description>Offset adjust of 'negative' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=1 OR GP_ADC_CHOP=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFP_REG</name>
	<description>General Purpose ADC Positive Offset Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFP</name>
	<description>Offset adjust of 'positive' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=0 OR GP_ADC_CHOP=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_PARAM_DIF_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000000</resetMask>
	
</register><register>
	<name>GP_ADC_PARAM_SE_REG</name>
	
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000000</resetMask>
	
</register><register>
	<name>GP_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_VAL</name>
	<description>Returns the 10 up to 16 bits linear value of the last AD conversion. The upper 10 bits are always valid, the lower 6 bits are only valid in case oversampling has been applied. Two samples results in one extra bit and 64 samples results in six extra bits.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_TRIM_REG</name>
	<description>General Purpose ADC Trim Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000038</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>GP_ADC_LDO_LEVEL</name>
	<description>GPADC LDO level
0: 825mV
1: 850mV
2: 875mV
3: 900mV (reset)
4: 925mV (default)
5: 950mV
6: 975mV
7:1000mV</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_OFFS_SH_VREF</name>
	<description>Offset Shifter common-mode reference fine trimming: 2mV/LSB
Default = mid-scale at 1000</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPIO</name>
	<version>1.0</version>
	<description>GPIO registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>66</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BIST_CTRL_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000480</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SYSRAM3_BIST_ENABLE</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM_BIST_PATTERN</name>
	
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYSRAM12_BIST_BUSY</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM12_BIST_FAIL</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM3_BIST_BUSY</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM3_BIST_FAIL</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ROM_BIST_BUSY</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYSRAM12_BIST_ENABLE</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ROMBIST_ENABLE</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM_BIST_CONFIG</name>
	
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P00_MODE_REG</name>
	<description>P00 Mode Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0  =  GPIO (pin direction determined by &quot;PUPD&quot; field)
1  =  UART1_RX
2  =  UART1_TX
3  =  UART2_RX
4  =  UART2_TX
5  =  SYS_CLK
6  =  LP_CLK
7  =  Reserved
8  =  Reserved
9  =  I2C_SCL
10 = I2C_SDA
11 = PWM5
12 = PWM6
13 = PWM7
14 = Reserved
15 = ADC (only for P0_1, P0_2, P0_6 and P0_7)
16 = PWM0
17 = PWM1
18 = BLE_DIAG (signals mapped to P0[3:0] are also mapped to P0[11:8])
19 = UART1_CTSN
20 = UART1_RTSN
21 = Reserved
22 = Reserved
23 = PWM2
24 = PWM3
25 = PWM4
26 = SPI_DI
27 = SPI_DO
28 = SPI_CLK
29 = SPI_CSN0
30 = SPI_CSN1
31 = Reserved
Note: When a certain input function (like SPI_DI) is selected on more than 1 pins, the pin of the lowest index has the highest priority.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P010_MODE_REG</name>
	<description>P010 Mode Register</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P011_MODE_REG</name>
	<description>P011 Mode Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P01_MODE_REG</name>
	<description>P01 Mode Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P02_MODE_REG</name>
	<description>P02 Mode Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P03_MODE_REG</name>
	<description>P03 Mode Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P04_MODE_REG</name>
	<description>P04 Mode Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P05_MODE_REG</name>
	<description>P05 Mode Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P06_MODE_REG</name>
	<description>P06 Mode Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P07_MODE_REG</name>
	<description>P07 Mode Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P08_MODE_REG</name>
	<description>P08 Mode Register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P09_MODE_REG</name>
	<description>P09 Mode Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID]</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_DATA_REG</name>
	<description>P0 Data input/output Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_DATA</name>
	<description>Sets P0 output register when written ; Returns the value of P0 port when read </description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_DATA_REG</name>
	<description>P0 Reset port pins Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_RESET</name>
	<description>Writing a 1 to P0[x] sets P0[x] to 0.
Writing 0 is discarded, reading returns 0.</description>
	<bitRange>[11:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_SET_DATA_REG</name>
	<description>P0 Set port pins Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_SET</name>
	<description>Writing a 1 to P0[x] sets P0[x] to 1.
Writing 0 is discarded, reading returns 0 </description>
	<bitRange>[11:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>PAD_WEAK_CTRL_REG</name>
	<description>Pad driving strength control Register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PAD_LOW_DRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_x pad.
Bit x controls the driving strength of P0_x, x=0, 1,..., 11.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>ROMBIST_RESULTH_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ROMBIST_RESULTH</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>ROMBIST_RESULTL_REG</name>
	
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ROMBIST_RESULTL</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SCAN_OBSERVE_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SCAN_FEEDBACK_MUX</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL2_REG</name>
	
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ANA_TEST_OUT_PARAM</name>
	
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ANA_TEST_OUT_TO_PIN</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ANA_TEST_OUT_SEL</name>
	
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL3_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RF_TEST_OUT_TO_PIN</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_OUT_PARAM</name>
	
	<bitRange>[12:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENABLE_RFPT</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_OUT_SEL</name>
	
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL4_REG</name>
	
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RF_TEST_IN_TO_PIN</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_IN_PARAM</name>
	
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_TEST_IN_SEL</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TEST_CTRL_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ADPLL_SCAN_COMP_EN</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_SCAN_TEST_EN</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CP_CAP_BIAS_TRIM</name>
	
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_DUMMY_LOAD_ENABLE</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_CAP_BYPASS</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CAP_TEST_EN</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SHOW_DCDC</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SHOW_POWER</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SHOW_CLOCKS</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TESTCTRL0_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003400</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BIAS_SAH_HOLD_OVERRIDE</name>
	
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_FREQ_TRIM_SW2_AMP</name>
	
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_GM_CURRENT</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_HOLD_AMP_REG_OVERRIDE</name>
	
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_I2V_TO_TESTBUS</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_I2V_TO_TESTBUS_10X</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_MAX_CURRENT</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CORE_XTAL_DISCHARGE</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCBLOCK_LV_MODE</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIFFBUF_BYPASS</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSC_TRIM_OPEN_DISABLE</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPIKE_FLT_DISABLE</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TESTCTRL1_REG</name>
	
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>OSC_TRIM_CAP_BIAS</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCLK_SEL_ADPLL_ADC_TO_GPIO</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCLK_ADC_TO_GPIO</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCLK_ADPLL_TO_GPIO</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROG_VREF_SEL</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VARICAP_TEST_SEL_XTAL</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VARICAP_TEST_ENABLE</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_HOLD_OVERRIDE</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DISABLE_TM_CLK</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPREG</name>
	<version>1.0</version>
	<description>GPREG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>14</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BLE_TIMER_REG</name>
	<description>BLE FINECNT sampled value while in deep sleep state.</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLE_TIMER_DATA</name>
	<description>Operation depends on GP_CONTROL_REG-&gt;BLE_TIMER_DATA_CTRL.
If BLE_TIMER_DATA_CTRL = 0 then:
This register is located at the Always On Power Domain and it holds the automatically sampled value of the BLE FINECNT timer
The HW automatically samples the value into this register during the sequence of &quot;BLE Sleep On&quot; and restores automatically the value during the BLE Wake up sequence.
The Software may read and modify the value while the BLE is in Sleep state. While the BLE is awake, the value of the register has no meaning, while changing the value by writing another one will have no effect in the operation of the BLE core.
There is a constraint when the SW performs an write-read sequence where it has to inject a one cycle delay in between (e.g. write-NOP-read) in order to read back the correct value.
If BLE_TIMER_DATA_CTRL is non 0 then write operations have the same effect as when BLE_TIMER_DATA_CTRL=0, while for read operations:
BLE_TIMER_DATA_CTRL= 1: then reading BLE_TIMER_REG returns &quot;deepsldur[9:0]&quot;.
BLE_TIMER_DATA_CTRL= 2: then reading BLE_TIMER_REG returns &quot;deepsltime_samp[9:0]&quot;.
BLE_TIMER_DATA_CTRL= 3: then reading BLE_TIMER_REG returns &quot;{deep_sleep_stat_monitor, deepsltime_samp[18:10]}.
.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DEBUG_REG</name>
	<description>Various debug information register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DEBUGS_FREEZE_EN</name>
	<description>Default '1', freezing of the on-chip timers is enabled when the Cortex-M0Plus is halted in DEBUG State.
If '0', freezing of the on-chip timers is depending on FREEZE_REG when the Cortex-M0Plus is halted in DEBUG State except the watchdog timer. The watchdog timer is always frozen when the Cortex-M0Plus is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_CONTROL_REG</name>
	<description>General purpose system control register.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLE_TIMER_DATA_CTRL</name>
	<description>Refer to BLE_TIMER_REG.</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CPU_DMA_BUS_PRIO</name>
	<description>Controls the CPU DMA system bus priority:
If '0', the CPU has highest priority.
If '1', the DMA has highest priority.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_WAKEUP_LP_IRQ</name>
	<description>The current value of the BLE_WAKEUP_LP_IRQ interrupt request.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BLE_WAKEUP_REQ</name>
	<description>If '1', the BLE wakes up. Must be kept high at least for 1 low power clock period. 
If the BLE is in deep sleep state, then by setting this bit it will cause the wakeup LP IRQ to be asserted with a delay of 3 to 4 low power cycles.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_STATUS_REG</name>
	<description>General purpose system status register.</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CAL_PHASE</name>
	<description>If '1', it designates that the chip is in Calibration Phase i.e. the OTP has been initially programmed but no Calibration has occured. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_CTRL_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000080</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>ARB2_AHB2_WR_BUFF</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB2_AHB_WR_BUFF</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB1_AHB2_WR_BUFF</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB1_AHB_WR_BUFF</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAM_MARGIN</name>
	
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM_DST</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ROM_MARGIN_EN</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ROM_MARGIN_CTRL</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_FREEZE_REG</name>
	<description>Controls unfreezing of various timers/counters.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA continues, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer continues, '0' is discarded. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the the BLE master clock continues, '0' is discarded. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer (TIMER0) continues, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer continues, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_FREEZE_REG</name>
	<description>Controls freezing of various timers/counters.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA is frozen, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer is frozen, '0' is discarded. WATCHDOG_CTRL_REG[NMI_RST] must be '0' to allow the freeze function. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the BLE master clock is frozen, '0' is discarded. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer (TIMER0) is frozen, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer is frozen, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C</name>
	<version>1.0</version>
	<description>I2C registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. Reset value: 0x0</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP2_VERSION</name>
	
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003132</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP2_VERSION</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_PARAM1_REG</name>
	
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_PARAM1</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_PARAM2_REG</name>
	
	<addressOffset>0x000000f6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_PARAM2</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_TYPE2_REG</name>
	
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP2_TYPE</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_TYPE_REG</name>
	
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000140</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_TYPE</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_COMP_VERSION_REG</name>
	
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000302a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_COMP_VERSION</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000007d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s)
Note: The actuall speed depends on the pcb traces capacitance as well as on the values of the external pull-up resistorts. For an exact speed match, trimming might be required, by adjusting the values of I2C_SS_SCL_HCNT_REG, I2C_SS_SCL_LCNT_REG, I2C_FS_SCL_HCNT_REG, I2C_FS_SCL_LCNT_REG registers. The reset values of those registers were calculated with the assumption of 4.3kOhms external pull-up resistors. </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. Reset value: 0x0</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received. STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel. 0 = Transmit DMA disabled 1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. 0 = Receive DMA disabled 1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_ABORT</name>
	<description>0= ABORT not initiated or ABORT done
1= ABORT operation in progress
The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to
an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CTRL_ENABLE</name>
	<description>Controls whether the controller is enabled.
0: Disables the controller (TX and RX FIFOs are held in an erased state)
1: Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver
operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1.
When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1). </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000017</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SDA_HOLD</name>
	<description>SDA Hold time</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000048</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000004f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Slave FSM is in IDLE state so the Slave part of the controller is not Active
1: Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Master FSM is in IDLE state so the Master part of the controller is not Active
1: Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0: Receive FIFO is not full
1: Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0: Receive FIFO is empty
1: Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0: Transmit FIFO is not empty
1: Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0: Transmit FIFO is full
1: Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>This bit indicates whether software performs a General Call or
START BYTE command.
0: ignore bit 10 GC_OR_START and use IC_TAR normally
1: perform special I2C command as specified in GC_OR_START
bit </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1: START BYTE </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>1: Slave lost the bus while transmitting data to a remote master.
I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>1: Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>1: Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>1: User tries to initiate a Master operation with the Master mode disabled. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>1: Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>1: Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>1: the controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1). </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>1: the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>1: This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>1: Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>1: Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>1: Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>KBRD</name>
	<version>1.0</version>
	<description>KBRD registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>22</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GPIO_DEBOUNCE_REG</name>
	<description>debounce counter value for GPIO inputs</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>DEB_ENABLE_KBRD</name>
	<description>enables the debounce counter for the KBRD interface </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE4</name>
	<description>enables the debounce counter for GPIO IRQ4 </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE3</name>
	<description>enables the debounce counter for GPIO IRQ3 </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE2</name>
	<description>enables the debounce counter for GPIO IRQ2 </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE1</name>
	<description>enables the debounce counter for GPIO IRQ1 </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE0</name>
	<description>enables the debounce counter for GPIO IRQ0 </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_VALUE</name>
	<description>Keyboard debounce time if enabled. Generate KEYB_INT after specified time.
Debounce time: N*1 ms. N =0..63</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_INT_LEVEL_CTRL_REG</name>
	<description>high or low level select for GPIO interrupts</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>EDGE_LEVELn4</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ4 </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn3</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ3 </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn2</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ2 </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn1</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ1 </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn0</name>
	<description>0: do not wait for key release after interrupt was reset for GPIO IRQ0, so a new interrupt can be initiated immediately
1: wait for key release after interrupt was reset for IRQ0 </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL4</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ4 </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL3</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ3 </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL2</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ2 </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL1</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ1 </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL0</name>
	<description>0 = selected input will generate GPIO IRQ0 if that input is high.
1 = selected input will generate GPIO IRQ0 if that input is low. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ0_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ0_SEL</name>
	<description>input selection that can generate a GPIO interrupt
1: P0[0] is selected
2: P0[1] is selected
3: P0[2] is selected
4: P0[3] is selected
5: P0[4] is selected
6: P0[5] is selected
7: P0[6] is selected
8: P0[7] is selected
9: P0[8] is selected
10: P0[9] is selected
11: P0[10] is selected
12: P0[11] is selected
all others: no input selected </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ1_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ1</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ1_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ2_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ2</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ2_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ3_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ3</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ3_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ4_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ4</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffcf</resetMask>
	<fields><field>
	<name>KBRD_IRQ4_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_RESET_IRQ_REG</name>
	<description>GPIO interrupt reset register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_KBRD_IRQ</name>
	<description>writing a 1 to this bit will reset the KBRD IRQ.
Reading returns 0. </description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO4_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO4 IRQ.
Reading returns 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO3_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO3 IRQ.
Reading returns 0. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO2_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO2 IRQ.
Reading returns 0. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO1_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO1 IRQ.
Reading returns 0. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO0_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO0 IRQ.
Reading returns 0. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>KBRD_CTRL_REG</name>
	<description>GPIO Kbrd control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>KBRD_REL</name>
	<description>0 = No interrupt on key release
1 = Interrupt also on key release (also debouncing if enabled) </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_LEVEL</name>
	<description>0 = enabled input will generate KBRD IRQ if that input is high.
1 = enabled input will generate KBRD IRQ if that input is low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KEY_REPEAT</name>
	<description>While key is pressed, automatically generate repeating
KEYB_INT after specified time unequal to 0.
Repeat time: N*1 ms. N =1..63, N=0 disables the timer. </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>KBRD_IRQ_IN_SEL0_REG</name>
	<description>GPIO interrupt selection for KBRD_IRQ for P0</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>KBRD_P11_EN</name>
	<description>enable P0[11] for the keyboard interrupt </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P10_EN</name>
	<description>enable P0[10] for the keyboard interrupt </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P09_EN</name>
	<description>enable P0[9] for the keyboard interrupt </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P08_EN</name>
	<description>enable P0[8] for the keyboard interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P07_EN</name>
	<description>enable P0[7] for the keyboard interrupt </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P06_EN</name>
	<description>enable P0[6] for the keyboard interrupt </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P05_EN</name>
	<description>enable P0[5] for the keyboard interrupt </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P04_EN</name>
	<description>enable P0[4] for the keyboard interrupt </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P03_EN</name>
	<description>enable P0[3] for the keyboard interrupt </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P02_EN</name>
	<description>enable P0[2] for the keyboard interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P01_EN</name>
	<description>enable P0[1] for the keyboard interrupt </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P00_EN</name>
	<description>enable P0[0] for the keyboard interrupt </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MBIST_SRAM12</name>
	<version>1.0</version>
	<description>MBIST_SRAM12 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003700</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>MBIST_SRAM12_ADDR_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_ADDR</name>
	<description>Returns the current address register in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM12_RD_LSB_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_LSB_DATA</name>
	<description>Returns the actual LSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM12_RD_MSB_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_MSB_DATA</name>
	<description>Returns the actual MSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM12_STATE_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_STATE</name>
	<description>Returns the current state in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MBIST_SRAM3</name>
	<version>1.0</version>
	<description>MBIST_SRAM3 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003800</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>MBIST_SRAM3_ADDR_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_ADDR</name>
	<description>Returns the current address register in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM3_RD_LSB_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_LSB_DATA</name>
	<description>Returns the actual LSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM3_RD_MSB_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_MSB_DATA</name>
	<description>Returns the actual MSB read data in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>MBIST_SRAM3_STATE_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>MBIST_STATE</name>
	<description>Returns the current state in case of a mismatch.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>OTPC</name>
	<version>1.0</version>
	<description>OTPC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x07f40000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>OTPC_AHBADR_REG</name>
	<description>AHB master start address</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_AHBADR</name>
	<description>It is the AHB address used by the AHB master interface of the controller (the bits [15:2]). The bits [1:0] of the address are considered always as equal to zero.
The value of the register remains unchanged, by the internal logic of the controller. </description>
	<bitRange>[15:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_CELADR_REG</name>
	<description>OTP cell start address</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_CELADR</name>
	<description>Defines a word address inside the OTP cell that will be used during the AREAD mode and the OTP mirroring.</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_MODE_REG</name>
	<description>Mode register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_MODE_PRG_SEL</name>
	<description>Defines the part of the OTP cell that is programmed by the controller during the PROG mode, for each program request that is applied.
0x0 : Both normal and redundancy arrays are programmed. This is the normal way of programming.
0x1 : Only the normal array is programmed.
0x2 : Only the redundancy array is programmed.
0x3 : Reserved
The value of this configuration field can be modified only when the controller is in an inactive mode (DSTBY or STBY). The setting will take effect when will be enabled again the PROG mode.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_HT_MARG_EN</name>
	<description>Defines the temperature condition under which is performed a margin read. It affects only the initial margin read (RINI mode) and the programming verification margin read (PVFY).
0 : Regular temperature condition (less than 85&#176;C)
1 : High temperature condition (85&#176;C or more)
The value of this configuration field can be modified only when the controller is in an inactive mode (DSTBY or STBY). The selection will take effect at the next PVFY or RINI mode that will be enabled. The READ mode is not affected by the setting of this configuration bit.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_USE_TST_ROW</name>
	<description>Selects the memory area of the OTP cell that will be used.
0 - Uses the main memory area of the OTP cell
1 - Uses the test row of the OTP cell
The value of this configuration field can be modified only when the controller is in an inactive mode (DSTBY or STBY). The selection will take effect at the next programming or reading mode that will be enabled.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_MODE</name>
	<description>Defines the mode of operation of the OTPC controller. The encoding of the modes is as follows:
0x0: DSTBY. The OTP memory is in deep standby mode (power supply ON and internal LDO OFF).
0x1: STBY. The OTP memory is powered (power supply ON and internal LDO ON, but is not selected).
0x2: READ. The OTP memory is in the normal read mode.
0x3: PROG. The OTP memory is in programming mode.
0x4: PVFY. The OTP memory is in programming verification mode (margin read after programming).
0x5: RINI. The OTP memory is in initial read mode (initial margin read).
0x6: AREAD. Copying of data from the OTP memory to a system RAM by using the internal DMA. See also the registers OTPC_AHBADR_REG, OTPC_CELADR_REG and OTPC_NWORDS_REG.

Whenever the OTPC_MODE_REG[MODE] is changing, the status bit OTPC_STAT_REG[OTPC_STAT_MRDY] gets the value zero. The new mode will be ready for use when the OTPC_STAT_MRDY become again 1. During the mode transition the OTPC_MODE_REG[MODE] become read only. Do not try to use or change any function of the controller until the OTPC_STAT_MRDY bit to become equal to 1.
The data transferring that is performed by using the AREAD mode is completed when OTPC_STAT_MRDY becomes again 1. The mode change automatically to DSTBY with the completion of the transfer. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_NWORDS_REG</name>
	<description>Number of words</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_NWORDS</name>
	<description>The number of words (minus one) that will be copied by the AREAD mode. During mirroring, this register reflects the amount of data that will be copied. </description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_PADDR_REG</name>
	<description>The address of the word that will be programmed, when the PROG mode is used.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_PADDR</name>
	<description>The OTPC_PADDR_REG and the OTPC_PWORD_REG consist the PBUF buffer that keeps the information that will be programmed in the OTP, by using the PROG mode. The PBUF holds the address (OTPC_PADDR_REG) and the data (OTPC_PWORD_REG) of each of the programming requests that are applied in the OTP memory.
The OTPC_PADDR_REG refers to a word address. The OTPC_PADDR_REG has to be writen after the OTP_PWORD_REG and only if the OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=1. The register is read only for as long the PBUF is not empty (OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=0). A writting to the OTPC_PADDR_REG triggers the controller to start the programming procedure (only if the PROG mode is active).</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_PWORD_REG</name>
	<description>The 32-bit word that will be programmed, when the PROG mode is used.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_PWORD</name>
	<description>The OTPC_PADDR_REG and the OTPC_PWORD_REG consist the PBUF buffer that keeps the information that will be programmed in the OTP memory, by using the PROG mode. The PBUF holds the address (OTPC_PADDR_REG) and the data (OTPC_PWORD_REG) of each of the programming requests that are applied in the OTP memory.
The OTP_PWORD_REG must be written before the OTPC_PADDR_REG and only if OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY] = 1. The register is read only for as long the PBUF is not empty (OTPC_STAT_REG[OTPC_STAT_PBUF_EMPTY]=0). </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_STAT_MRDY</name>
	<description>Indicates the progress of the transition from a mode of operation to a new mode of operation.
0 : There is a transition in progress in a new mode of operation . Wait until the transition to be completed.
1 : The transition to the new mode of operation has been completed. The function that has been enabled by the new mode can be used. A new mode can be applied.
This status bit gets the value zero every time where the OTPC_MODE_REG[MODE] is changing. Do not try to use or change any function of the controller until this status bit to become equal to 1.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PBUF_EMPTY</name>
	<description>Indicates the status of the programming buffer (PBUF).
0 : The PBUF contains the address and the data of a programming request. The OTPC_PADDR_REG and the OTPC_PWORD_REG should not be written as long as this status bit is zero.
1 : The PBUF is empty and a new programming request can be registered in the PBUF by using the OTPC_PADDR_REG and the OTPC_PWORD_REG registers.
This status bit gets the value zero every time where a programming is triggered by the OTPC_PADDR_REG (only if the PROG mode is active).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PRDY</name>
	<description>Indicates the state of the programming process.
0: The controller is busy. A programming is in progress.
1: The logic which performs programming is idle.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>OTPC_TIM1_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0999000f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_TIM1_US_T_CSP</name>
	<description>The number of microseconds (minus one) that are required after the selection of the OTP memory, until to be ready for programming. It must be :
- at least 10us
- no more than 100us</description>
	<bitRange>[30:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_US_T_CS</name>
	<description>The number of microseconds (minus one) that are required after the selection of the OTP memory, until to be ready for any kind of read. It must be at least 10us.</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_US_T_PL</name>
	<description>The number of microseconds (minus one) that are required until to be enabled the LDO of the OTP. It must be at least 10us.</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_RD</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 60ns. This timing parameter refers to the access time of the OTP memory.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_20NS</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval that is at least higher than 20 ns.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM1_CC_T_1US</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval equal to 1us. This setting affects all the timing parameters that refer to microseconds, due to that defines the correspondence of a microsecond to a number of hclk_c clock cycles.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_TIM2_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_TIM2_US_ADD_CC_EN</name>
	<description>Adds an additional hclk_c clock cycle at all the time intervals that count in microseconds.
0 : The extra hclk_c clock cycle is not applied
1 : The extra hclk_c clock cycle is applied</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_SAS</name>
	<description>The number of microseconds (minus one) that are required after the exit from the deep sleep standby mode and before to become ready to enter in an active mode (reading or programming). It must be at least 2us.</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPH</name>
	<description>The number of microseconds (minus one) that are required after the last programming pulse and before to be disabled the programming mode in the OTP memory. It must be:
- at least 5us
- no more than 20us</description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_VDS</name>
	<description>The number of microseconds (minus one) that are required after the enabling of the power supply of the OTP memory and before to become ready for the enabling of the internal LDO. It must be at least 1us.</description>
	<bitRange>[23:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPS</name>
	<description>The number of microseconds (minus one) that are required after the enabling of the programming in the OTP memory and before to be applied the first programming pulse. It must be :
- at least 5us
- no more than 20us</description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PPR</name>
	<description>The number of microseconds (minus one) for recovery after a programming sequence. It must be :
- at least 5us
- no more than 100us</description>
	<bitRange>[14:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PWI</name>
	<description>The number of microseconds (minus one) between two consecutive programming pulses. It must be :
- at least 1us
- no more than 5us</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_TIM2_US_T_PW</name>
	<description>The number of microseconds (minus one) that lasts the programming of each bit. It must be :
- at least 10us
- no more than 20us</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PATCH</name>
	<version>1.0</version>
	<description>PATCH registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40080000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>208</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PATCH_ADDR0_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR10_REG</name>
	
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR11_REG</name>
	
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR12_REG</name>
	
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR13_REG</name>
	
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR14_REG</name>
	
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR15_REG</name>
	
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR16_REG</name>
	
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR17_REG</name>
	
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR18_REG</name>
	
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR19_REG</name>
	
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR1_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR20_REG</name>
	
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_D</name>
	
	<bitRange>[17:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR21_REG</name>
	
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_D</name>
	
	<bitRange>[17:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR2_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR3_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR4_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR5_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR6_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR7_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR8_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_ADDR9_REG</name>
	
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_ADDR_19</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PATCH_ADDR_C</name>
	
	<bitRange>[17:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_DATA20_REG</name>
	
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_DATA</name>
	
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_DATA21_REG</name>
	
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_DATA</name>
	
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PATCH_VALID_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATCH_VALID</name>
	
	<bitRange>[21:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QUADEC</name>
	<version>1.0</version>
	<description>QUADEC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>14</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>QDEC_CLOCKDIV_REG</name>
	<description>Clock divider register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000003e7</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>QDEC_PRESCALER_EN</name>
	<description>0 = no prescaler enabled
1 = in sleep and active mode, quadrature clock is divided by 2</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CLOCKDIV</name>
	<description>Contains the number of the input clock cycles minus one, that are required to generate one logic clock cycle.
Clock divider is bypassed when system runs at LP_CLK</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL2_REG</name>
	<description>Quad Decoder port selection register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000ed1</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>QDEC_CHZ_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHY_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHX_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHZ_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Z
0: none
1: P0[2] -&gt; CHZ_A, P0[5] -&gt; CHZ_B
2: P0[1] -&gt; CHZ_A, P0[4] -&gt; CHZ_B
3: P0[3] -&gt; CHZ_A, P0[10] -&gt; CHZ_B
4: P0[6] -&gt; CHZ_A, P0[7] -&gt; CHZ_B
5: P0[8] -&gt; CHZ_A, P0[9] -&gt; CHZ_B
6: P0[0] -&gt; CHZ_A, P0[11] -&gt; CHZ_B
7: none</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHY_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Y
0: none
1: P0[2] -&gt; CHY_A, P0[5] -&gt; CHY_B
2: P0[1] -&gt; CHY_A, P0[4] -&gt; CHY_B
3: P0[3] -&gt; CHY_A, P0[10] -&gt; CHY_B
4: P0[6] -&gt; CHY_A, P0[7] -&gt; CHY_B
5: P0[8] -&gt; CHY_A, P0[9] -&gt; CHY_B
6: P0[0] -&gt; CHY_A, P0[11] -&gt; CHY_B
7: none</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHX_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel X
0: none
1: P0[2] -&gt; CHX_A, P0[5] -&gt; CHX_B
2: P0[1] -&gt; CHX_A, P0[4] -&gt; CHX_B
3: P0[3] -&gt; CHX_A, P0[10] -&gt; CHX_B
4: P0[6] -&gt; CHX_A, P0[7] -&gt; CHX_B
5: P0[8] -&gt; CHX_A, P0[9] -&gt; CHX_B
6: P0[0] -&gt; CHX_A, P0[11] -&gt; CHX_B
7: none</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL_REG</name>
	<description>Quad Decoder control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000011</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>QDEC_IRQ_THRES</name>
	<description>Defines the number of events on either counter (X or Y or Z) that need to be reached before an interrupt is generated. Events are equal to QDEC_IRQ_THRES+1.</description>
	<bitRange>[10:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_IRQ_STATUS</name>
	<description>1 = Interrupt is occured.
0 = No interrupt pending
Write 1 will clear the pending interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_EVENT_CNT_CLR</name>
	<description>Writing 1 QDEC_EVENT_CNT_REG is cleared</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_IRQ_ENABLE</name>
	<description>0 = interrupt is masked
1 = interrupt is enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_EVENT_CNT_REG</name>
	<description>Event counter register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>QDEC_EVENT_CNT</name>
	<description>Gives the number of events at all channels.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_XCNT_REG</name>
	<description>Counter value of the X Axis</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_X_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_YCNT_REG</name>
	<description>Counter value of the Y Axis</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_Y_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_ZCNT_REG</name>
	<description>Counter value of the Z Axis</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_Z_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFCU</name>
	<version>1.0</version>
	<description>RFCU registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40001000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>188</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RF_ADCI_DC_OFFSET_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00020100</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_I_RD</name>
	
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADC_OFFP_I_RD</name>
	
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_ADCQ_DC_OFFSET_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00020100</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_Q_RD</name>
	
	<bitRange>[17:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADC_OFFP_Q_RD</name>
	
	<bitRange>[8:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_ADC_CTRL1_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00006001</resetMask>
	<fields><field>
	<name>ADC_SIGN</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_MUTE</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_DC_OFFSET_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADC_CTRL2_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_I_WR</name>
	
	<bitRange>[17:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_OFFP_I_WR</name>
	
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADC_CTRL3_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>ADC_OFFN_Q_WR</name>
	
	<bitRange>[17:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_OFFP_Q_WR</name>
	
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADPLLDIG_CTRL_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x00000073</resetMask>
	<fields><field>
	<name>PWR_SW_TIM_CTRL</name>
	
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OPENLOOP_RDY_WR</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OPENLOOP_RDY_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ADPLLDIG_RFMON_CTRL_REG</name>
	
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_RFMON_SPARE</name>
	
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_RFMON_MUX_SEL</name>
	
	<bitRange>[3:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_SYNC_CLK_INV</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_AGC_EXT_LUT_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>AGC_EXT_LUT</name>
	
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ATTR_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0c000820</resetValue>
	<resetMask>0x0f001f28</resetMask>
	<fields><field>
	<name>PA_POWER_SETTING</name>
	
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIA_BIAS</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_BIAS</name>
	
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_POLARITY</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CALSTATE_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CALSTATE</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_CAL_CTRL_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000017</resetMask>
	<fields><field>
	<name>DC_OFFSET_CAL_DIS</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_CAL_CTRL_SPARE</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EO_CAL</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SO_CAL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RF_DIAGIRQ_CTRL_REG</name>
	
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7f7f7f7f</resetMask>
	<fields><field>
	<name>DIAG_BUS3_EDGE_SEL</name>
	
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS3_BIT_SEL</name>
	
	<bitRange>[29:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS3_SEL</name>
	
	<bitRange>[26:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS3_IRQ_MASK</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_EDGE_SEL</name>
	
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_BIT_SEL</name>
	
	<bitRange>[21:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_SEL</name>
	
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS2_IRQ_MASK</name>
	
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_EDGE_SEL</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_BIT_SEL</name>
	
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_SEL</name>
	
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS1_IRQ_MASK</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_EDGE_SEL</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_BIT_SEL</name>
	
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_SEL</name>
	
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG_BUS0_IRQ_MASK</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_DIAGIRQ_STAT_REG</name>
	
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>DIAGIRQ_STAT</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_IFF_CTRL_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00007ff3</resetMask>
	<fields><field>
	<name>IFF_DCOC_DAC_REFCUR_CTRL</name>
	
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_COMPLEX_DIS</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_IFF_CTRL_SPARE</name>
	
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_DCOC_DAC_DIS</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IF_MUTE</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IF_CAL_TRIM</name>
	
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_IO_CTRL_REG</name>
	
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x00000f0f</resetMask>
	<fields><field>
	<name>RFIO_TUNE_CAP_TRIM_TX</name>
	
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_TUNE_CAP_TRIM_RX</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_IRQ_CTRL_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EO_CAL_CLEAR</name>
	
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RF_LDO_CTRL_REG</name>
	
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00190333</resetValue>
	<resetMask>0x3f1f0fff</resetMask>
	<fields><field>
	<name>LDO_DCO_HOLD_OVR_EN</name>
	
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DCO_HOLD_OVR_VAL</name>
	
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_HOLD_OVR_EN</name>
	
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_HOLD_OVR_VAL</name>
	
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_HOLD_OVR_EN</name>
	
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_HOLD_OVR_VAL</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_SMPL_TIME</name>
	
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DCO_CONT_ENABLE</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DCO_LEVEL</name>
	
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_CONT_ENABLE</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_DTC_LEVEL</name>
	
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_CONT_ENABLE</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RADIO_LEVEL</name>
	
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LDO_STATUS_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>ldo_dtc_vref_hold_rd</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_dco_vref_hold_rd</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_radio_vref_hold_rd</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_dtc_en_rd</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ldo_dco_en_rd</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADPLLDIG_LDO_ZERO_EN_RD</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADPLLDIG_LDO_EN_RD</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RADIO_LDO_ZERO_EN_RD</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RADIO_LDO_EN_RD</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RF_LDO_VREF_SEL_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>RF_LDO_DCO_VREF_SEL</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_LDO_DTC_VREF_SEL</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_LDO_RADIO_VREF_SEL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LNA_CTRL1_REG</name>
	
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x01084210</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields><field>
	<name>LNA_TRIM_GAIN4_HP</name>
	
	<bitRange>[24:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN3_HP</name>
	
	<bitRange>[19:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN2_HP</name>
	
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN1_HP</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN0_HP</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LNA_CTRL2_REG</name>
	
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d6b5ad</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields><field>
	<name>LNA_TRIM_GAIN4_LP</name>
	
	<bitRange>[24:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN3_LP</name>
	
	<bitRange>[19:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN2_LP</name>
	
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN1_LP</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_GAIN0_LP</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_LNA_CTRL3_REG</name>
	
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00111114</resetValue>
	<resetMask>0x0333333f</resetMask>
	<fields><field>
	<name>LNA_SPARE</name>
	
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN4_LP</name>
	
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN3_LP</name>
	
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN2_LP</name>
	
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN1_LP</name>
	
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_MODE_GAIN0_LP</name>
	
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_TRIM_CASC</name>
	
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_MIXER_CTRL1_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x010f010f</resetValue>
	<resetMask>0x01ff01ff</resetMask>
	<fields><field>
	<name>MIXER_IP2_DAC_Q_TRIM</name>
	
	<bitRange>[24:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIXER_IP2_DAC_I_TRIM</name>
	
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_MIXER_CTRL2_REG</name>
	
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00010f0f</resetMask>
	<fields><field>
	<name>MIX_CAL_SELECT</name>
	
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_CAL_CAP_WR_2M</name>
	
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_CAL_CAP_WR_1M</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_OVERRULE_REG</name>
	
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>RX_EN_OVR</name>
	
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_EN_OVR</name>
	
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PA_CTRL_REG</name>
	
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000300</resetValue>
	<resetMask>0x0000033f</resetMask>
	<fields><field>
	<name>PA_RAMP_STEP_SPEED</name>
	
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIM_DUTY_NEG</name>
	
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIM_DUTY_POS</name>
	
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_RADIO_INIT_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x010303ff</resetMask>
	<fields><field>
	<name>RADIO_INIT_AUTOCLEAR</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_HCLK_DIS</name>
	
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_REGS_RDY</name>
	
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_HCLK_EN</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_HRESET_N</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_EN_WR</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_EN_SEL</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_PWR_SW1_EN</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_LDO_EN_WR</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_LDO_EN_SEL</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_LDO_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_RFCU_CTRL_REG</name>
	
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RF_RFCU_CLK_DIV</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_SCAN_FEEDBACK_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	
</register><register>
	<name>RF_SPARE_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>RF_SPARE_IN_EN</name>
	
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_SPARE_IN</name>
	
	<bitRange>[27:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RF_SPARE_BITS_HV</name>
	
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_SPARE_BITS</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFCU_POWER</name>
	<version>1.0</version>
	<description>RFCU_POWER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40001200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>400</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RF_ALWAYS_EN1_REG</name>
	
	<addressOffset>0x00000180</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ALW_EN_ADPLLDIG_EN</name>
	
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_RST</name>
	
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_CLK_EN</name>
	
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_DCO_EN</name>
	
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADC_EN</name>
	
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADC_CLK_EN</name>
	
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFF_BIAS_SH_OPEN</name>
	
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFF_EN</name>
	
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_MIX_BIAS_SH_OPEN</name>
	
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_MIX_EN</name>
	
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_CGM_EN</name>
	
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_CORE_EN</name>
	
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PA_EN</name>
	
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PA_RAMP_EN</name>
	
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_BIAS_SH_OPEN</name>
	
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_BIAS_EN</name>
	
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_TX_HARM_EN</name>
	
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_TX_EN</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_RX_EN</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_LDO_LP</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_LDO_ACTIVERDY</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_LDO_ZERO</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LDO_ZERO_EN</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_DCO_LDO_EN</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_DTC_LDO_EN</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_TDC_LDO_EN</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFFADC_LDO_EN</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_IFF_LDO_EN</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_MIX_LDO_EN</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_LNA_LDO_EN</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PA_LDO_EN</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_RFIO_LDO_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ALWAYS_EN2_REG</name>
	
	<addressOffset>0x00000184</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>ALW_EN_SPARE5</name>
	
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE4</name>
	
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE3</name>
	
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE2</name>
	
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_SPARE1</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_RDY_FOR_DIV</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_PHY_RDY4BS</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_SIGDETECT_EN</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_AGC_UNFREEZE_EN</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_DC_PARCAL_EN</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_DEM_EN</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_CAL_EN</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_LOBUF_PA_EN</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLL_PAIN_EN</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ALW_EN_ADPLLDIG_RX_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_10_REG</name>
	
	<addressOffset>0x00000124</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c16</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_11_REG</name>
	
	<addressOffset>0x00000128</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000081a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_12_REG</name>
	
	<addressOffset>0x0000012c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000e1a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_13_REG</name>
	
	<addressOffset>0x00000130</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000220</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_14_REG</name>
	
	<addressOffset>0x00000134</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000a20</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_15_REG</name>
	
	<addressOffset>0x00000138</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000426</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_16_REG</name>
	
	<addressOffset>0x0000013c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000430</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_17_REG</name>
	
	<addressOffset>0x00000140</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000837</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_18_REG</name>
	
	<addressOffset>0x00000144</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000846</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_19_REG</name>
	
	<addressOffset>0x00000148</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000850</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_1_REG</name>
	
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000400</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_20_REG</name>
	
	<addressOffset>0x0000014c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000125a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_21_REG</name>
	
	<addressOffset>0x00000150</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_22_REG</name>
	
	<addressOffset>0x00000154</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_23_REG</name>
	
	<addressOffset>0x00000158</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_24_REG</name>
	
	<addressOffset>0x0000015c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_25_REG</name>
	
	<addressOffset>0x00000160</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_26_REG</name>
	
	<addressOffset>0x00000164</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_27_REG</name>
	
	<addressOffset>0x00000168</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_28_REG</name>
	
	<addressOffset>0x0000016c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_29_REG</name>
	
	<addressOffset>0x00000170</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_2_REG</name>
	
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c00</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_30_REG</name>
	
	<addressOffset>0x00000174</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_31_REG</name>
	
	<addressOffset>0x00000178</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_3_REG</name>
	
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000408</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_4_REG</name>
	
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c08</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_5_REG</name>
	
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000212</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_6_REG</name>
	
	<addressOffset>0x00000114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000a12</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_7_REG</name>
	
	<addressOffset>0x00000118</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000414</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_8_REG</name>
	
	<addressOffset>0x0000011c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c14</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_9_REG</name>
	
	<addressOffset>0x00000120</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000416</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_OFFSET</name>
	
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SET_OFFSET</name>
	
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG0_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG10_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_LDO_ZERO_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_LDO_ZERO_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG11_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000c5</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_LDO_ACTIVERDY_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_ACTIVERDY_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG12_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000018b</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_LDO_LP_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_LDO_LP_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG13_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_RX_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_RX_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG14_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_TX_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_TX_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG15_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_TX_HARM_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_TX_HARM_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG16_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000008f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_BIAS_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_BIAS_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG17_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000210</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RFIO_BIAS_SH_OPEN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFIO_BIAS_SH_OPEN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG18_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001a0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PA_RAMP_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PA_RAMP_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG19_REG</name>
	
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PA_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PA_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG1_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PA_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PA_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG20_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_CORE_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_CORE_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG21_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_CGM_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_CGM_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG22_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>MIX_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG23_REG</name>
	
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>MIX_BIAS_SH_OPEN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_BIAS_SH_OPEN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG24_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFF_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG25_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFF_BIAS_SH_OPEN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_BIAS_SH_OPEN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG26_REG</name>
	
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADC_CLK_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_CLK_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG27_REG</name>
	
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADC_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADC_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG28_REG</name>
	
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_DCO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_DCO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG29_REG</name>
	
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_CLK_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_CLK_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG2_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LNA_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LNA_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG30_REG</name>
	
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000107</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_RST_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_RST_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG31_REG</name>
	
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000149</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG32_REG</name>
	
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_RX_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_RX_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG33_REG</name>
	
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001e0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLLDIG_PAIN_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLLDIG_PAIN_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG34_REG</name>
	
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000001c0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_LOBUF_PA_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_LOBUF_PA_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG35_REG</name>
	
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000294</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>CAL_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CAL_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG36_REG</name>
	
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000011</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>DEM_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG37_REG</name>
	
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE_DEM_DC_PARCAL_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_DC_PARCAL_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG38_REG</name>
	
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000011</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE_DEM_AGC_UNFREEZE_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_AGC_UNFREEZE_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG39_REG</name>
	
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000013</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE_DEM_SIGDETECT_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEM_SIGDETECT_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG3_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>MIX_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIX_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG40_REG</name>
	
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000253</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PHY_RDY4BS_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PHY_RDY4BS_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG41_REG</name>
	
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000c5</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_RDY_FOR_DIV_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_RDY_FOR_DIV_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG42_REG</name>
	
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE1_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE1_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG43_REG</name>
	
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE2_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE2_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG44_REG</name>
	
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE3_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE3_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG45_REG</name>
	
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE4_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE4_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG46_REG</name>
	
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SPARE5_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPARE5_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG4_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFF_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFF_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG5_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>IFFADC_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IFFADC_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG6_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_TDC_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_TDC_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG7_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_DTC_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_DTC_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG8_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000083</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>ADPLL_DCO_LDO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADPLL_DCO_LDO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG9_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>LDO_ZERO_EN_DCF_TX</name>
	
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_ZERO_EN_DCF_RX</name>
	
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PORT_EN_REG</name>
	
	<addressOffset>0x00000188</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>RF_PORT4_TX</name>
	
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT4_RX</name>
	
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT3_TX</name>
	
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT3_RX</name>
	
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT2_TX</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT2_RX</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT1_TX</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT1_RX</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT0_TX</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT0_RX</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RF_PORT_POL_REG</name>
	
	<addressOffset>0x0000018c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>RF_PORT4_POL</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT3_POL</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT2_POL</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT1_POL</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RF_PORT0_POL</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFMON</name>
	<version>1.0</version>
	<description>RFMON registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>22</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RFMON_ADDR_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_ADDR</name>
	
	<bitRange>[15:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_CRV_ADDR_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_CRV_ADDR</name>
	
	<bitRange>[15:2]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RFMON_CRV_LEN_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_CRV_LEN</name>
	
	<bitRange>[13:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RFMON_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_CIRC_EN</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMON_PACK_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_LEN_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_LEN</name>
	
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RFMON_STAT_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RFMON_OFLOW_STK</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFMON_ACTIVE</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RTC</name>
	<version>1.0</version>
	<description>RTC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50004100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>52</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>RTC_ALARM_ENABLE_REG</name>
	<description>RTC Alarm Enable Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RTC_ALARM_MNTH_EN</name>
	<description>Alarm on month enable. Enable to trigger alarm when data specified in Calendar Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_DATE_EN</name>
	<description>Alarm on date enable. Enable to trigger alarm when data specified in Calendar Alarm Register (D_T and D_U) has been reached.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOUR_EN</name>
	<description>Alarm on hour enable. Enable to trigger alarm when data specified in Time Alarm Register (PM, HR_T and HR_U) has been reached.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_MIN_EN</name>
	<description>Alarm on minute enable. Enable to trigger alarm when data specified in Time Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_SEC_EN</name>
	<description>Alarm on second enable. Enable to trigger alarm when data specified in Time Alarm Register (S_T and S_U) has been reached.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOS_EN</name>
	<description>Alarm on hundredths of a second enable. Enable to trigger alarm when data specified in Time Alarm Register (H_T and H_U) has been reached.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_ALARM_REG</name>
	<description>RTC Calendar Alram Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_REG</name>
	<description>RTC Calendar Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x2000010f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_CH</name>
	<description>The value in this register has altered since last read. Read and clear</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_T</name>
	<description>Century tens. Represented in BCD digit (1-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_U</name>
	<description>Century units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_T</name>
	<description>Year tens. Represented in BCD digit (0-9).</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_U</name>
	<description>Year units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DAY</name>
	<description>Day of the week (arbitrary) units. Represented in BCD digit (0-7).</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CONTROL_REG</name>
	<description>RTC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>RTC_CAL_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the calendar value.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the time value.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_EVENT_FLAGS_REG</name>
	<description>RTC Event Flags Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_EVENT_ALRM</name>
	<description>Alarm event flag. Indicate that alarm event occurred since the last reset.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MNTH</name>
	<description>Month rolls over event flag. Indicate that month rolls over event occurred since the last reset.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_DATE</name>
	<description>Date rolls over event flag. Indicate that date rolls over event occurred since the last reset.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOUR</name>
	<description>Hour rolls over event flag. Indicate that hour rolls over event occurred since the last reset.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MIN</name>
	<description>Minute rolls over event flag. Indicate that minute rolls over event occurred since the last reset.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_SEC</name>
	<description>Second rolls over event flag. Indicate that second rolls over event occurred since the last reset.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOS</name>
	<description>Hundredths of a second event flag. Indicate that hundredths of a second rolls over event occurred since the last reset.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_HOUR_MODE_REG</name>
	<description>RTC Hour Mode Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_HMS</name>
	<description>When this field is set high the RTC operates in 12 hour clock mode; otherwise, times are in 24 hour clock format.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_DISABLE_REG</name>
	<description>RTC Interrupt Disable Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_DIS</name>
	<description>Interrupt on alarm disable. Disable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_DIS</name>
	<description>Interrupt on month disable. Disable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_DIS</name>
	<description>Interrupt on date disable. Disable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_DIS</name>
	<description>IInterrupt on hour disable. Disable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_DIS</name>
	<description>Interrupt on minute disable. Disable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_DIS</name>
	<description>Interrupt on second disable. Disable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_DIS</name>
	<description>Interrupt on hundredths of a second disable. Disable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_ENABLE_REG</name>
	<description>RTC Interrupt Enable Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_EN</name>
	<description>Interrupt on alarm enable. Enable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_EN</name>
	<description>Interrupt on month enable. Enable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_EN</name>
	<description>Interrupt on date enable. Enable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_EN</name>
	<description>Interrupt on hour enable. Enable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_EN</name>
	<description>Interrupt on minute enable. Enable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_EN</name>
	<description>Interrupt on second enable. Enable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_EN</name>
	<description>Interrupt on hundredths of a second enable. Enable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_MASK_REG</name>
	<description>RTC Interrupt Mask Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_MSK</name>
	<description>Mask alarm interrupt. It can be cleared (set) by setting corresponding bit (ALRM) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MNTH_INT_MSK</name>
	<description>Mask month interrupt. It can be cleared (set) by setting corresponding bit (MNTH) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_DATE_INT_MSK</name>
	<description>Mask date interrupt. It can be cleared (set) by setting corresponding bit (DATE) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOUR_INT_MSK</name>
	<description>Mask hour interrupt. It can be cleared (set) by setting corresponding bit (HOUR) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MIN_INT_MSK</name>
	<description>Mask minute interrupt. It can be cleared (set) by setting corresponding bit (MIN) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_SEC_INT_MSK</name>
	<description>Mask second interrupt. It can be cleared (set) by setting corresponding bit (SEC) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOS_INT_MSK</name>
	<description>Mask hundredths of a second interrupt. It can be cleared (set) by setting corresponding bit (HOS) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_KEEP_RTC_REG</name>
	<description>RTC Keep RTC Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_KEEP</name>
	<description>Keep RTC. When high, the time and calendar registers and any other registers which directly affect or are affected by the time and calendar registers are NOT reset when software reset is applied. When low, the software reset will reset every register except the keep RTC and control registers.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_STATUS_REG</name>
	<description>RTC Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>RTC_VALID_CAL_ALM</name>
	<description>Valid Calendar Alarm. If cleared then indicates that invalid entry occurred when writing to Calendar Alarm Register.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME_ALM</name>
	<description>Valid Time Alarm. If cleared then indicates that invalid entry occurred when writing to Time Alarm Register.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_CAL</name>
	<description>Valid Calendar. If cleared then indicates that invalid entry occurred when writing to Calendar Register.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME</name>
	<description>Valid Time. If cleared then indicates that invalid entry occurred when writing to Time Register.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_ALARM_REG</name>
	<description>RTC Time Alarm Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_REG</name>
	<description>RTC Time Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_CH</name>
	<description>The value in this register has altered since last read. Read and clear.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SPI</name>
	<version>1.0</version>
	<description>SPI registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>50</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>SPI_CLOCK_REG</name>
	<description>Spi clock register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_MASTER_CLK_MODE</name>
	<description>Should be always 1</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_DIV</name>
	<description>Applicable only in master mode
Defines the spi clock frequency in master only mode
SPI_CLK = module_clk / 2*(SPI_CLK_DIV+1) when SPI_CLK_DIV not 0x7F
if SPI_CLK_DIV=0x7F then SPI_CLK=module_clk</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CONFIG_REG</name>
	<description>Spi control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_SLAVE_EN</name>
	<description>0 = SPI module master mode
1 = SPI module slave mode
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_WORD_LENGTH</name>
	<description>Define the spi word length = 1+ SPI_WORD_LENGTH (range 4 to 32)</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_MODE</name>
	<description>Define the spi mode (CPOL, CPHA)
0 = new data on falling, capture on rising, clk low in idle state
1 = new data on rising, capture on falling, Clk low in idle state
2 = new data on rising, capture on falling, Clk high in idle state
3 = new data on falling, capture on rising Clk high in idle state
</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CS_CONFIG_REG</name>
	<description>Spi cs configuration register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>SPI_CS_SELECT</name>
	<description>Control the cs output in master mode
0 = none slave device selected
1 = selected slave device connected to GPIO with FUNC_MODE=SPI_CS0
2 = selected slave device connected to GPIO with FUNC_MODE=SPI_CS1
4 = selected slave device connected to GPIO with FUNC_MODE=GPIO</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CTRL_REG</name>
	<description>Spi control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_SWAP_BYTES</name>
	<description>0 = normal operation
1 = LSB and MSB are swaped in APB interface
In case of 8bit spi interface, DMA/SPI can be configured in 16bit mode to off load the bus. Enabling SPI_SWAP_BYTES bytes will read/wrte correctly</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CAPTURE_AT_NEXT_EDGE</name>
	<description>0 = SPI captures data at correct clock edge
1 = SPI captures data at next clock edge. (only for Master mode and high clock)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_FIFO_RESET</name>
	<description>0 = Fifo normal operation
1 = Fifo in reset state
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_RX_EN</name>
	<description>applicable only when SPI_RX_EN=1
0 = No DMA request for RX
1 = DMA request when SPI_STATUS_RX_FULL='1'
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_TX_EN</name>
	<description>applicable only when SPI_TX_EN=1
0 = No DMA request for TX
1 = DMA request when SPI_STATUS_TX_EMPTY='1'
</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_RX_EN</name>
	<description>0 = RX path is disabled
1 = RX path is enabled
Note: if master clk async or spi mode=1 or spi mode=3 readonly is not supported</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_EN</name>
	<description>0 = TX path is disabled
1 = TX path is enabled
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_EN</name>
	<description>0 = SPI module is disable
1 = SPI module is enable
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_CONFIG_REG</name>
	<description>Spi fifo configuration register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_RX_TL</name>
	<description>Receive FIFO threshold level in bytes. Control the level of bytes in fifo that triggers the RX_FULL interrupt. IRQ is occurred when fifo level is more or equal to SPI_RX_TL+1. Fifo level is from 0 to 4</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_TL</name>
	<description>Transmit FIFO threshold level in bytes. Control the level of bytes in fifo that triggers the TX_EMPTY interrupt. IRQ is occurred when fifo level is less or equal to SPI_TX_TL. Fifo level is from 0 to 4</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_HIGH_REG</name>
	<description>Spi TX/RX High 16bit word</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_HIGH</name>
	<description>RX/TX fifo data. 16 MSb when spi word is larger than 16bits
This register has to be written before the SPI_FIFO_WRITE_REG
This register has to be read after the SPI_FIFO_READ_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_READ_REG</name>
	<description>Spi RX fifo read register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_READ</name>
	<description>Read from RX fifo. Read access is permit only if SPI_STATUS_RX_EMPTY=0. Returns the 16 LSb</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_STATUS_REG</name>
	<description>SPI RX/TX fifo status register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_TRANSACTION_ACTIVE</name>
	<description>In master mode
0 = spi transaction is inactive
1 = spi transaction is active</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_OVFL</name>
	<description>When 1, receive data is not written to fifo because fifo was full and interrupt is generated. It clears with SPI_CTRL_REG.SPI_FIFO_RESET
</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_TX_FULL</name>
	<description>0 = TX fifo is not full
1 = TX fifo is full
</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_RX_EMPTY</name>
	<description>0 = RX fifo is not empty
1 = RX fifo is empty
</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_TX_FIFO_LEVEL</name>
	<description>Gives the number of bytes in TX fifo</description>
	<bitRange>[11:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_LEVEL</name>
	<description>Gives the number of bytes in RX fifo</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_WRITE_REG</name>
	<description>Spi TX fifo wtite register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_WRITE</name>
	<description>Write to TX fifo. Write access is permit only if SPI_STATUS_TX_FULL is 0</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_IRQ_MASK_REG</name>
	<description>Spi interrupt mask register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>SPI_IRQ_MASK_RX_FULL</name>
	<description>0 = FIFO RX full irq is masked
1 = FIFO RX full irq is enabled
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_IRQ_MASK_TX_EMPTY</name>
	<description>0 = FIFO TX empty irq is masked
1 = FIFO TX empy irq is enabled
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_STATUS_REG</name>
	<description>Spi status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>SPI_STATUS_RX_FULL</name>
	<description>Auto clear
0 = RX fifo level is less than SPI_RX_TL+1
1 = RX fifo level is more or equal to SPI_RX_TL+1
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_TX_EMPTY</name>
	<description>Auto clear
0 = TX fifo level is larger than SPI_TX_TL
1 = TX fifo level is less or equal to SPI_TX_TL
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_TXBUFFER_FORCE_H_REG</name>
	<description>SPI TX buffer force high value</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_TXBUFFER_FORCE_H</name>
	<description>Write directly the tx buffer (2 MSB). It must to be used only in slave mode.
This register has to be written before the SPI_FIFO_WRITE_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_TXBUFFER_FORCE_L_REG</name>
	<description>SPI TX buffer force low value</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_TXBUFFER_FORCE_L</name>
	<description>Write directly the tx buffer (2 LSB). It must to be used only in slave mode</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SYS_WDOG</name>
	<version>1.0</version>
	<description>SYS_WDOG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WATCHDOG_CTRL_REG</name>
	<description>Watchdog control register.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>NMI_RST</name>
	<description>0 = Watchdog timer generates NMI at value 0, and WDOG (SYS) reset at &lt;=-16. Timer can be frozen /resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG].
1 = Watchdog timer generates a WDOG (SYS) reset at value 0 and can not be frozen by Software.
Note that this bit can only be set to 1 by SW and only be reset with a WDOG (SYS) reset or SW reset.
The watchdog is always frozen when the Cortex-M0 is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WATCHDOG_REG</name>
	<description>Watchdog timer register.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WDOG_WEN</name>
	<description>0000.000 = Write enable for Watchdog timer
else Write disable. This filter prevents unintentional presetting the watchdog with a SW run-away. </description>
	<bitRange>[15:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WDOG_VAL_NEG</name>
	<description>0 = Watchdog timer value is positive.
1 = Watchdog timer value is negative. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOG_VAL</name>
	<description>Write: Watchdog timer reload value. Note that all bits 15-9 must be 0 to reload this register.
Read: Actual Watchdog timer value. Decremented by 1 every 10.24 msec. Bit 8 indicates a negative counter value. 2, 1, 0, 1FF16, 1FE16 etc. An NMI or WDOG (SYS) reset is generated under the following conditions:
If WATCHDOG_CTRL_REG[NMI_RST] = 0 then
    If WDOG_VAL = 0 -&gt; NMI (Non Maskable Interrupt)
    if WDOG_VAL = 1F016 -&gt; WDOG reset -&gt; reload FF16
If WATCHDOG_CTRL_REG[NMI_RST] = 1 then
    if WDOG_VAL &lt;= 0 -&gt; WDOG reset -&gt; reload FF16 </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER0</name>
	<version>1.0</version>
	<description>TIMER0 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PWM2_END_CYCLE</name>
	<description>Defines end Cycle for PWM2</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM2_START_CYCLE</name>
	<description>Defines start Cycle for PWM2</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM3_END_CYCLE</name>
	<description>Defines end Cycle for PWM3</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM3_START_CYCLE</name>
	<description>Defines start Cycle for PWM3</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM4_END_CYCLE</name>
	<description>Defines end Cycle for PWM4</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM4_START_CYCLE</name>
	<description>Defines start Cycle for PWM4</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM5_END_CYCLE</name>
	<description>Defines end Cycle for PWM5</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM5_START_CYCLE</name>
	<description>Defines start Cycle for PWM5</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM6_END_CYCLE</name>
	<description>Defines end Cycle for PWM6</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM6_START_CYCLE</name>
	<description>Defines start Cycle for PWM6</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM7_END_CYCLE</name>
	<description>Defines end Cycle for PWM7</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM7_START_CYCLE</name>
	<description>Defines start Cycle for PWM7</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_CTRL_REG</name>
	<description>Timer0 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PWM_MODE</name>
	<description>0 = PWM signals are '1' during high time.
1 = PWM signals send out the (fast) clock divided by 2 during high time. So it will be in the range of 1 to 8 MHz. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CLK_DIV</name>
	<description>1 = Timer0 uses selected clock frequency as is.
0 = Timer0 uses selected clock frequency divided by 10.
Note that this applies only to the ON-counter.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CLK_SEL</name>
	<description>1 = Timer0 uses 16, 8, 4 or 2 MHz (fast) clock frequency.
0 = Timer0 uses LP clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CTRL</name>
	<description>0 = Timer0 is off and in reset state.
1 = Timer0 is running. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_ON_REG</name>
	<description>Timer0 on control register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_ON</name>
	<description>Timer0 On reload value:
If read the actual ON-counter value is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_RELOAD_M_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_M</name>
	<description>Timer0 'high' reload value
If read the actual T0-counter value is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_RELOAD_N_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_N</name>
	<description>Timer0 'low' reload value:
If read the actual T0-counter value is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TRIPLE_PWM_CTRL_REG</name>
	<description>PWM 2,3,4,5,6,7 Control</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>TRIPLE_PWM_CLK_SEL</name>
	<description>1 = Timer2 uses 16, 8, 4 or 2 MHz (fast) clock frequency.
0 = Timer2 uses LP clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HW_PAUSE_EN</name>
	<description>'1' = HW can pause PWM 2,3,4,5,6,7 </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_PAUSE_EN</name>
	<description>'1' = PWM 2 3 4 5 6 7 are paused </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIPLE_PWM_ENABLE</name>
	<description>'1' = enable PWM 2 3 4 5 6 7</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TRIPLE_PWM_FREQUENCY</name>
	<description>Frequency for PWM 2,3,4,5,6 and 7</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>PWM_FREQ</name>
	<description>Defines the frequeancy of PWM 2,3,4,5,,6 and 7. pwm freq = module Frequency / (value+1)
module frequency is the LP_CLK when TRIPLE_PWM_CLK_SEL=0 else is the sys_clk divided by TMR_DIV</description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER1</name>
	<version>1.0</version>
	<description>TIMER1 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50004000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>24</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>TIMER1_CAPCNT1_VALUE_REG</name>
	<description>Timer1 value for event on GPIO1</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>TIMER1_CAPCNT1_RTC_HIGH</name>
	<description>In Counter mode : Not used
In Capture mode: Gives the RTC time stamp (high part) when an IN1 event was occurred </description>
	<bitRange>[21:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_CAPCNT1_VALUE</name>
	<description>In Counter mode : Gives the number of timer clock cycles minus 1 which was measured during TIMER1_IN1_PERIOD_MAX periods of IN1
In Capture mode (TIMER1_IN1_STAMP_TYPE=0) : Gives the Counter value when an IN1 event was occurred
In Capture mode (TIMER1_IN1_STAMP_TYPE=1) : Gives the RTC time stamp (low part) when an IN1 event was occurred </description>
	<bitRange>[10:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER1_CAPCNT2_VALUE_REG</name>
	<description>Timer1 value for event on GPIO2</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>TIMER1_CAPCNT2_RTC_HIGH</name>
	<description>In Counter mode : Not used
In Capture mode: Gives the RTC time stamp (high part) when an IN2 event was occurred </description>
	<bitRange>[21:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_CAPCNT2_VALUE</name>
	<description>In Counter mode : Gives the number of timer clock cycles minus 1 which was measured during TIMER1_IN2_PERIOD_MAX periods of IN2
In Capture mode (TIMER1_IN2_STAMP_TYPE=0) : Gives the Counter value when an IN2 event was occurred
In Capture mode (TIMER1_IN2_STAMP_TYPE=1) : Gives the RTC time stamp (low part) when an IN2 event was occurred </description>
	<bitRange>[10:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER1_CAPTURE_REG</name>
	<description>Timer1 Capture control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields><field>
	<name>TIMER1_IN2_STAMP_TYPE</name>
	<description>0 = On each event store the counter value
1 = On each event store the RTC time stamp</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_PERIOD_MAX</name>
	<description>Gives the number of periods +1 of IN2, in which module counts</description>
	<bitRange>[26:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_IRQ_EN</name>
	<description>1 = Interrupt is generated when capture is occurred or was counted TIMER1_IN2_PERIOD_MAX
0 = Interrupt is masked</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_COUNT_EN</name>
	<description>0 = Capture mode
1 = Count mode</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN2_EVENT_FALL_EN</name>
	<description>0 = Rising edge event
1 = Falling edge event
it should be written when TIMER1_GPIO2_CONF=0 to prevent false events</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_GPIO2_CONF</name>
	<description>0,13,14,15 = IN2 is not used
1..12 = Defines the P0 pin (0..11) module will use as IN2</description>
	<bitRange>[17:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_STAMP_TYPE</name>
	<description>0 = On each event store the counter value
1 = On each event store the RTC time stamp</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_PERIOD_MAX</name>
	<description>Gives the number of periods +1 of IN1, in which module counts</description>
	<bitRange>[12:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_IRQ_EN</name>
	<description>1 = Interrupt is generated when capture is occurred or was counted TIMER1_IN1_PERIOD_MAX
0 = Interrupt is masked</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_COUNT_EN</name>
	<description>0 = Capture mode
1 = Count mode</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IN1_EVENT_FALL_EN</name>
	<description>0 = Rising edge event
1 = Falling edge event
it should be written when TIMER1_GPIO1_CONF=0 to prevent false events</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_GPIO1_CONF</name>
	<description>0,13,14,15 = IN1 is not used
1..12 = Defines the P0 pin (0..11) module will use as IN1</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER1_CLR_EVENT_REG</name>
	<description>Clear event register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>TIMER1_CLR_IN2_EVENT</name>
	<description>Write 1 to clear the TIMER1_IN2_EVENT and TIMER1_IN2_OVRFLW</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_CLR_IN1_EVENT</name>
	<description>Write 1 to clear the TIMER1_IN1_EVENT and TIMER1_IN1_OVRFLW</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_CLR_TIMER_EVENT</name>
	<description>Write 1 to clear the TIMER1_TIMER_EVENT</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER1_CTRL_REG</name>
	<description>Timer1 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>TIMER1_CLK_EN</name>
	<description>0 = timer1 clock is disabled
1 = timer1 clock is enabled</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_USE_SYS_CLK</name>
	<description>0 = Timer1 use the clock LP clock
1 = Timer1 use the system clock</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_FREE_RUN_MODE_EN</name>
	<description>Applicable when timer counts up
1 = timer1 goes to zero when it reaches the max value.
0 = timer1 goes to zero when it reaches the reload value.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_IRQ_EN</name>
	<description>0 = timer1 IRQ masked
1 = timer1 IRQ unmasked</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_COUNT_DOWN_EN</name>
	<description>0 = timer1 counts up
1 = timer1 counts down</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_ENABLE</name>
	<description>0 = Timer1 disabled
1 = Timer1 enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMER1_RELOAD</name>
	<description>Reload or max value in timer mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[10:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER1_STATUS_REG</name>
	<description>Timer1 counter value</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIMER1_IN2_OVRFLW</name>
	<description>1 = New IN2 event occurred while Interrupt was pending.
TIMER1_CAPCNT2_VALUE_REG gives the time stamp of the first event.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_IN1_OVRFLW</name>
	<description>1 = New IN1 event occurred while Interrupt was pending.
TIMER1_CAPCNT1_VALUE_REG gives the time stamp of the first event.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_IN2_EVENT</name>
	<description>1 = Pending Capture 2 interrupt. It has be clear writing 1 to TIMER1_CLR_IN2_EVENT</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_IN1_EVENT</name>
	<description>1 = Pending Capture 1 interrupt. It has be clear writing 1 to TIMER1_CLR_IN1_EVENT</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_TIMER_EVENT</name>
	<description>1 = Pending Timer interrupt. it has be clear writing 1' to TIMER1_CLR_TIMER_EVENT</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIMER1_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[10:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART</name>
	<version>1.0</version>
	<description>UART registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART_CTR_HIGH_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_FAR_REG</name>
	<description>FIFO Access Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>UART_FAR</name>
	<description>Description: Writes will have no effect when FIFO_ACCESS == No, always readable. This register is use to enable a FIFO access mode for testing, so that the receive FIFO can be written by the master and the transmit FIFO can be read by the master when FIFO's are implemented and enabled. When FIFO's are not implemented or not enabled it allows the RBR to be written by the master and the THR to be read by the master. 0 = FIFO access mode disabled 1 = FIFO access mode enabled Note, that when the FIFO access mode is enabled/disabled, the control portion of the receive FIFO and transmit FIFO is reset and the FIFO's are treated as empty.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are implemented and not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IER_DLH_REG</name>
	<description>Interrupt Enable Register/Divisor Latch High</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled. 
Divisor Latch (High): DLH7, Bit 7 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>dlh6_4</name>
	<description>Divisor Latch (High): DLH6 to DLH4, Bits 6 to 4 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set, otherwise, this field is reserved. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH3, Bit 3 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH2, Bit 2 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): DLH1, Bit 1 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): DLH0, Bit 0 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_FIFOSE_RT</name>
	<description>On read
FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled.
On write
RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_TET</name>
	<description>On read
reserved
On Write
TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full </description>
	<bitRange>[5:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_IID3_DMAM</name>
	<description>On Read (Bit3)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1 </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID2_XFIFOR</name>
	<description>On Read (Bit2)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID1_RFIFOE</name>
	<description>On Read (Bit1)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID0_FIFOE</name>
	<description>On Read (Bit0)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit. Writeable only when UART is not busy (USR[0] is zero).
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register(THR) and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are enabled.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high.In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] set to one) and FIFOs enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register/Transmit Holding Register/Divisor Latch Low</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, 16 number of characters of data may be written to the THR before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the Divisor Latch is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.
For the Divisor Latch (High) bits, see register UART_IER_DLH_REG.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_RFL_REG</name>
	<description>Receive FIFO Level</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to
performing a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] = 1) and FIFOs enable (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_UCV_HIGH_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003331</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000352a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_USR_REG</name>
	<description>UART Status Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART2</name>
	<version>1.0</version>
	<description>UART2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART2_CTR_HIGH_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_FAR_REG</name>
	<description>FIFO Access Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>UART_FAR</name>
	<description>Description: Writes will have no effect when FIFO_ACCESS == No, always readable. This register is use to enable a FIFO access mode for testing, so that the receive FIFO can be written by the master and the transmit FIFO can be read by the master when FIFO's are implemented and enabled. When FIFO's are not implemented or not enabled it allows the RBR to be written by the master and the THR to be read by the master. 0 = FIFO access mode disabled 1 = FIFO access mode enabled Note, that when the FIFO access mode is enabled/disabled, the control portion of the receive FIFO and transmit FIFO is reset and the FIFO's are treated as empty.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are implemented and not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IER_DLH_REG</name>
	<description>Interrupt Enable Register/Divisor Latch High</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled. 
Divisor Latch (High): DLH7, Bit 7 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>dlh6_4</name>
	<description>Divisor Latch (High): DLH6 to DLH4, Bits 6 to 4 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set, otherwise, this field is reserved. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH3, Bit 3 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH2, Bit 2 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): DLH1, Bit 1 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): DLH0, Bit 0 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_FIFOSE_RT</name>
	<description>On read
FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled.
On write
RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_TET</name>
	<description>On read
reserved
On Write
TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full </description>
	<bitRange>[5:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_IID3_DMAM</name>
	<description>On Read (Bit3)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1 </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID2_XFIFOR</name>
	<description>On Read (Bit2)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID1_RFIFOE</name>
	<description>On Read (Bit1)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_IID0_FIFOE</name>
	<description>On Read (Bit0)
Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write
FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.Writeable only when UART is not busy (USR[0] is zero).
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits. Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.Writeable only when UART is not busy (USR[0] is zero).
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register(THR) and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register/Transmit Holding Register/Divisor Latch Low</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, 16 number of characters of data may be written to the THR before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the Divisor Latch is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.
For the Divisor Latch (High) bits, see register UART_IER_DLH_REG.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RFL_REG</name>
	<description>Receive FIFO Level</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_UCV_HIGH_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003331</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000352a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_USR_REG</name>
	<description>UART Status Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>WKUP</name>
	<version>1.0</version>
	<description>WKUP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WKUP2_POL_GPIO_REG</name>
	<description>Select the sensitivity polarity for each P1 input</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP2_POL_GPIO</name>
	<description>0 = the enabled input P0x increments the event2 counter if that input goes high
1 = the enabled input P0x increments the event2 counter if that input goes low</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP2_SELECT_GPIO_REG</name>
	<description>Select which inputs from P1 port can trigger wkup counter</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP2_SELECT_GPIO</name>
	<description>0 = input P0x is not enabled for wakeup event counter
1 = input P0x is enabled for wakeup event counter</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_COMPARE_REG</name>
	<description>Number of events before wakeup interrupt</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>WKUP_COMPARE</name>
	<description>Defines the number of events -1 that have to be counted before the wakeup interrupt will be given. value 0 means one event.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_COUNTER_REG</name>
	<description>Actual number of events of the wakeup counter</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EVENT2_VALUE</name>
	<description>This value represents the number of events that have been counted so far. It will be reset by resetting the interrupt. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENT_VALUE</name>
	<description>This value represents the number of events that have been counted so far. It will be reset by resetting the interrupt. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>WKUP_CTRL_REG</name>
	<description>Control register for the wakeup counter</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>WKUP2_ENABLE_IRQ</name>
	<description>0 = no interrupt will be generated
1 = if the event counter2 reaches the value set by WKUP_COMPARE_REG an IRQ will be generated </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_ENABLE_IRQ</name>
	<description>0 = no interrupt will be generated
1 = if the event counter reaches the value set by WKUP_COMPARE_REG an IRQ will be generated </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_SFT_KEYHIT</name>
	<description>0 = no effect
1 = emulate key hit. The event counter and counter2 will increment by 1 (after debouncing if enabled). First make this bit 0 before any new key hit can be sensed. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_DEB_VALUE</name>
	<description>Keyboard debounce time (N*1 ms with N = 1 to 63).
0x0: no debouncing
0x1 to 0x3F: 1 ms to 63 ms debounce time</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_IRQ_STATUS_REG</name>
	<description>Reset wakeup interrupt</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>WKUP2_CNTR_RST</name>
	<description>writing 1 will reset the event2 counter</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WKUP_CNTR_RST</name>
	<description>writing 1 will reset the event counter</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WKUP2_IRQ_STATUS</name>
	<description>Gives 1 when there is a wkup2 pending IRQ. Writing 1 will reset the interrupt. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_IRQ_STATUS</name>
	<description>Gives 1 when there is a wkup pending IRQ. Writing 1 will reset the interrupt. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_GPIO_REG</name>
	<description>Select the sensitivity polarity for each P0 input</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP_POL_GPIO</name>
	<description>0 = the enabled input P0x increments the event counter if that input goes high
1 = the enabled input P0x increments the event counter if that input goes low</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_GPIO_REG</name>
	<description>Select which inputs from P0 port can trigger wkup counter</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_GPIO</name>
	<description>0 = input P0x is not enabled for wakeup event counter
1 = input P0x is enabled for wakeup event counter</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral></peripherals>
</device>
