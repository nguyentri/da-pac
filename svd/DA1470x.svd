<?xml version="1.0" encoding="ascii"?>
<!-- File naming: Dialog_DA1470x.svd -->
<!--
  Copyright (C) 2020 Dialog Semiconductor.
  This computer program includes Confidential, Proprietary Information  
  of Dialog Semiconductor. All Rights Reserved.

  Purpose: System Viewer Description (SVD) Example (Schema Version 1.3)
           This is a description of a none-existent and incomplete device
		   for demonstration purposes only.

  Generated by cmsis-svd (version 0.2), d.d. August 19, 2020 - 11:39:36
 -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.3" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Dialog</vendor>                   				    <!-- device vendor name -->
  <vendorID>ARM</vendorID>                                        <!-- device vendor short name -->
  <name>DA1470x</name>                                          <!-- name of part-->
  <series>DA1470x</series>                                         <!-- device series the device belongs to -->
  <version>1.2</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>D2798AA</description>
  <licenseText><!-- this license text will appear in header file. \n forces line breaks -->
  Copyright (C) 2020 Dialog Semiconductor.\n
  This computer program includes Confidential, Proprietary Information  \n
  of Dialog Semiconductor. All Rights Reserved.
</licenseText>
  <cpu><!-- details about the cpu embedded in the device (SVD version 1.2,  see https://www.keil.com/pack/doc/CMSIS/SVD/html/group__cpu_section__gr.html) -->
    <name>CM33</name>
    <revision>r0p2</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
		<vtorPresent>true</vtorPresent><sauNumRegions>0</sauNumRegions><dspPresent>true</dspPresent>
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
																																									 and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->
	
  <peripherals>
	<peripheral>
	<name>AES_HASH</name>
	<version>1.0</version>
	<description>AES_HASH registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30040000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>260</size>
	<usage>registers</usage>
</addressBlock>
	<interrupt>
	<name>CMAC2SYS</name>
	<description>CMAC and mailbox interrupt request.</description>
	<value>0</value>
</interrupt><interrupt>
	<name>SNC2SYS</name>
	<description>SNC M0+ interrupt to Cortex M33.</description>
	<value>1</value>
</interrupt><interrupt>
	<name>M33_Cache_MRM</name>
	<description>CM33 Cache Miss Rate Monitor interrupt request.</description>
	<value>2</value>
</interrupt><interrupt>
	<name>PDC_M33</name>
	<description>Wakeup IRQ from PDC to CM33.</description>
	<value>3</value>
</interrupt><interrupt>
	<name>KEY_WKUP_GPIO</name>
	<description>Debounced button press interrupt request.</description>
	<value>4</value>
</interrupt><interrupt>
	<name>VBUS</name>
	<description>VBUS presence interrupt request.</description>
	<value>5</value>
</interrupt><interrupt>
	<name>CHARGER_STATE</name>
	<description>Charger State interrupt request.</description>
	<value>6</value>
</interrupt><interrupt>
	<name>CHARGER_ERROR</name>
	<description>Charger Error interrupt request.</description>
	<value>7</value>
</interrupt><interrupt>
	<name>DCDC_BOOST</name>
	<description>DCDC boost controller interrupt request.</description>
	<value>8</value>
</interrupt><interrupt>
	<name>PLL48_LOCK</name>
	<description>PLL48 lock interrupt request. Indicates that the PLL48 is locked at 48MHz.</description>
	<value>9</value>
</interrupt><interrupt>
	<name>CRYPTO</name>
	<description>Crypto interrupt request.</description>
	<value>10</value>
</interrupt><interrupt>
	<name>PLL_LOCK</name>
	<description>PLL lock interrupt request. Indicates that PLL is locked at 160MHz.</description>
	<value>11</value>
</interrupt><interrupt>
	<name>XTAL32M_RDY</name>
	<description>XTAL32M trimmed and ready interrupt request.</description>
	<value>12</value>
</interrupt><interrupt>
	<name>RFDIAG</name>
	<description>Baseband or Radio Diagnostics interrupt request.</description>
	<value>13</value>
</interrupt><interrupt>
	<name>GPIO_P0</name>
	<description>GPIO port 0 toggle interrupt request.</description>
	<value>14</value>
</interrupt><interrupt>
	<name>GPIO_P1</name>
	<description>GPIO port 1 toggle interrupt request.</description>
	<value>15</value>
</interrupt><interrupt>
	<name>GPIO_P2</name>
	<description>GPIO port 2 toggle interrupt request.</description>
	<value>16</value>
</interrupt><interrupt>
	<name>TIMER</name>
	<description>TIMER interrupt request.</description>
	<value>17</value>
</interrupt><interrupt>
	<name>TIMER2</name>
	<description>TIMER2 interrupt request.</description>
	<value>18</value>
</interrupt><interrupt>
	<name>TIMER3</name>
	<description>TIMER3 interrupt request.</description>
	<value>19</value>
</interrupt><interrupt>
	<name>TIMER4</name>
	<description>TIMER4 interrupt request.</description>
	<value>20</value>
</interrupt><interrupt>
	<name>TIMER5</name>
	<description>TIMER5 interrupt request.</description>
	<value>21</value>
</interrupt><interrupt>
	<name>TIMER6</name>
	<description>TIMER6 interrupt request.</description>
	<value>22</value>
</interrupt><interrupt>
	<name>RTC</name>
	<description>RTC interrupt request.</description>
	<value>23</value>
</interrupt><interrupt>
	<name>RTC_EVENT</name>
	<description>RTC event interrupt request.</description>
	<value>24</value>
</interrupt><interrupt>
	<name>CAPTIMER</name>
	<description>GPIO triggered Timer Capture interrupt request.</description>
	<value>25</value>
</interrupt><interrupt>
	<name>ADC</name>
	<description>General Purpose Analog-Digital Converter interrupt request.</description>
	<value>26</value>
</interrupt><interrupt>
	<name>ADC2</name>
	<description>Application Analog-Digital Converter interrupt request.</description>
	<value>27</value>
</interrupt><interrupt>
	<name>DMA</name>
	<description>General Purpose DMA interrupt request.</description>
	<value>28</value>
</interrupt><interrupt>
	<name>UART</name>
	<description>UART interrupt request.</description>
	<value>29</value>
</interrupt><interrupt>
	<name>UART2</name>
	<description>UART2 interrupt request.</description>
	<value>30</value>
</interrupt><interrupt>
	<name>UART3</name>
	<description>UART3 interrupt request.</description>
	<value>31</value>
</interrupt><interrupt>
	<name>SPI</name>
	<description>SPI interrupt request.</description>
	<value>32</value>
</interrupt><interrupt>
	<name>SPI2</name>
	<description>SPI2 interrupt request.</description>
	<value>33</value>
</interrupt><interrupt>
	<name>SPI3</name>
	<description>SPI3 interrupt request.</description>
	<value>34</value>
</interrupt><interrupt>
	<name>I2C</name>
	<description>I2C interrupt request.</description>
	<value>35</value>
</interrupt><interrupt>
	<name>I2C2</name>
	<description>I2C2 interrupt request.</description>
	<value>36</value>
</interrupt><interrupt>
	<name>I2C3</name>
	<description>I2C3 interrupt request.</description>
	<value>37</value>
</interrupt><interrupt>
	<name>I3C</name>
	<description>I3C interrupt request.</description>
	<value>38</value>
</interrupt><interrupt>
	<name>USB</name>
	<description>USB interrupt request.</description>
	<value>39</value>
</interrupt><interrupt>
	<name>PCM</name>
	<description>PCM interrupt request.</description>
	<value>40</value>
</interrupt><interrupt>
	<name>SRC_IN</name>
	<description>SRC input interrupt request.</description>
	<value>41</value>
</interrupt><interrupt>
	<name>SRC_OUT</name>
	<description>SRC output interrupt request.</description>
	<value>42</value>
</interrupt><interrupt>
	<name>SRC2_IN</name>
	<description>SRC2 input interrupt request.</description>
	<value>43</value>
</interrupt><interrupt>
	<name>SRC2_OUT</name>
	<description>SRC2 output interrupt request.</description>
	<value>44</value>
</interrupt><interrupt>
	<name>VAD</name>
	<description>VAD interrupt request.</description>
	<value>45</value>
</interrupt><interrupt>
	<name>eMMC</name>
	<description>eMMC controller interrupt request.</description>
	<value>46</value>
</interrupt><interrupt>
	<name>SDIO</name>
	<description>SDIO controller interrupt request.</description>
	<value>47</value>
</interrupt><interrupt>
	<name>GPU</name>
	<description>GPU interrupt request to Cortex M33.</description>
	<value>48</value>
</interrupt><interrupt>
	<name>LCD</name>
	<description>LCD controller interrupt request.</description>
	<value>49</value>
</interrupt><interrupt>
	<name>DSI</name>
	<description>DSI/D-PHY interrupt request.</description>
	<value>50</value>
</interrupt><interrupt>
	<name>CHARGER_DET</name>
	<description>Charger detection interrupt request.</description>
	<value>51</value>
</interrupt><interrupt>
	<name>DCACHE_MRM</name>
	<description>Data cache MRM interrupt request.</description>
	<value>52</value>
</interrupt><interrupt>
	<name>CLK_CALIBRATION</name>
	<description>Clock calibration interrupt request.</description>
	<value>53</value>
</interrupt><interrupt>
	<name>VSYS_GEN</name>
	<description>VSYS generator interrupt request.</description>
	<value>54</value>
</interrupt><interrupt>
	<name>RESERVED55</name>
	<description>SoftWare interrupt request.</description>
	<value>55</value>
</interrupt>
	<registers>
	<register>
	<name>CRYPTO_CLRIRQ_REG</name>
	<description>Crypto Clear interrupt request</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CRYPTO_CLRIRQ</name>
	<description>Write 1 to clear a pending interrupt request.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_CTRL_REG</name>
	<description>Crypto Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>CRYPTO_AES_KEXP</name>
	<description>It forces (active high) the execution of the key expansion process with the starting of the AES encryption/decryption process. The bit will be cleared automatically by the hardware, after the completion of the AES key expansion process.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_MORE_IN</name>
	<description>0 : Define that this is the last input block. When the current input is consumed by the crypto engine and the output data is written to the memory, the calculation ends (CRYPTO_INACTIVE goes to one).
1 : The current input data block is not the last. More input data will follow. When the current input is consumed, the engine stops and waits for more data (CRYPTO_WAIT_FOR_IN goes to one).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_HASH_OUT_LEN</name>
	<description>The number of bytes minus one of the hash result which will be saved at the memory by the DMA. In relation with the selected hash algorithm the accepted values are:
MD5: 0..15 -&gt; 1-16 bytes
SHA-1: 0..19 -&gt; 1-20 bytes
SHA-256: 0..31 -&gt; 1 - 32 bytes
SHA-256/224: 0..27 -&gt; 1- 28 bytes
SHA-384: 0..47 -&gt; 1 - 48 bytes
SHA-512: 0..63 -&gt; 1 - 64 bytes
SHA-512/224: 0..27 -&gt; 1- 28 bytes
SHA-512/256: 0..31 -&gt; 1 - 32 bytes</description>
	<bitRange>[15:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_HASH_SEL</name>
	<description>Selects the type of the algorithm
0 : The encryption algorithm (AES)
1 : A hash algorithm.
The exact algorithm is defined by the fileds CRYPTO_ALG and CRYPTO_ALG_MD.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_IRQ_EN</name>
	<description>Interrupt Request Enable
0 : The interrupt generation ability is disabled.
1 : The interrupt generation ability is enabled. Generates an interrupt request at the end of operation.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ENCDEC</name>
	<description>Encryption/Decryption
0 : Decryption
1 : Encryption</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_AES_KEY_SZ</name>
	<description>The size of AES Key
0x0 : 128 bits AES Key
0x1 : 192 bits AES Key
0x2 : 256 bits AES Key
0x3 : 256 bits AES Key</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_OUT_MD</name>
	<description>Output Mode. This field makes sense only when the AES algorithm is selected (CRYPTO_HASH_SEL =0)
0 : Write back to memory all the resulting data
1 : Write back to memory only the final block of the resulting data</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ALG_MD</name>
	<description>It defines the mode of operation of the AES algorithm when the controller is configured for an encryption/decryption processing (CRYPTO_HASH_SEL = 0).
0x0 : ECB
0x1 : ECB
0x2 : CTR
0x3 : CBC

When the controller is configured to applies a HASH function, this field selects the desired HASH algorithm with the help of the CRYPTO_ALG.

0x0 : HASH algorithms that are based on 32 bits operations
0x1 : HASH algorithms that are based on 64 bits operations
0x2 : Reserved
0x3 : Reserved

See also the CRYPTO_ALG field.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ALG</name>
	<description>Algorithm selection. When CRYPTO_HASH_SEL = 0 the only available choice is the AES algorithm.
0x0 : AES
0x1 : Reserved
0x2 : Reserved
0x3 : Reserved

When CRYPTO_HASH_SEL = 1, this field selects the desired hash algorithm, with the help of the CRYPTO_ALG_MD field.

If CRYPTO_ALG_MD = 0x0
0x0 : MD5
0x1 : SHA-1
0x2 : SHA-256/224
0x3 : SHA-256

If CRYPTO_ALG_MD = 0x1
0x0 : SHA-384
0x1 : SHA-512
0x2 : SHA-512/224
0x3 : SHA-512/256


</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_DEST_ADDR_REG</name>
	<description>Crypto DMA destination memory</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_DEST_ADDR</name>
	<description>Destination address at where the result of the processing is stored. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_FETCH_ADDR_REG</name>
	<description>Crypto DMA fetch register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_FETCH_ADDR</name>
	<description>The memory address from where will be retrieved the data that will be processed. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_KEYS_START</name>
	<description>Crypto First position of the AES keys storage memory</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_KEY_X</name>
	<description>CRYPTO_KEY_(0-63)
This is the AES keys storage memory. This memory is accessible via AHB slave interface, only when the CRYPTO is inactive (CRYPTO_INACTIVE = 1).</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_LEN_REG</name>
	<description>Crypto Length of the input block in bytes</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>CRYPTO_LEN</name>
	<description>It contains the number of bytes of input data. If this number is not a multiple of a block size, the data is automatically extended with zeros. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG0_REG</name>
	<description>Crypto Mode depended register 0</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG0</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[31:0]
CTR - CTRBLK[31:0]. It is the initial value of the 32 bits counter.
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG1_REG</name>
	<description>Crypto Mode depended register 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG1</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[63:32]
CTR - CTRBLK[63:32]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG2_REG</name>
	<description>Crypto Mode depended register 2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG2</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[95:64]
CTR - CTRBLK[95:64]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG3_REG</name>
	<description>Crypto Mode depended register 3</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG3</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[127:96]
CTR - CTRBLK[127:96]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_START_REG</name>
	<description>Crypto Start calculation</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CRYPTO_START</name>
	<description>Write 1 to initiate the processing of the input data. This register is auto-cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_STATUS_REG</name>
	<description>Crypto Status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>CRYPTO_IRQ_ST</name>
	<description>The status of the interrupt request line of the CRYPTO block.
0 : There is no active interrupt request.
1 : An interrupt request is pending.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTO_WAIT_FOR_IN</name>
	<description>Indicates the situation where the engine waits for more input data. This is applicable when the CRYPTO_MORE_IN= 1, so the input data are fragmented in the memory.
0 : The crypto is not waiting for more input data.
1 : The crypto waits for more input data.
The CRYPTO_INACTIVE flag remains to zero to indicate that the calculation is not finished. The supervisor of the CRYPTO must program to the CRYPTO_FETCH_ADDR and CRYPTO_LEN a new input data fragment. The calculation will be continued as soon as the CRYPTO_START register will be written with 1. This action will clear the CRYPTO_WAIT_FOR_IN flag.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTO_INACTIVE</name>
	<description>0 : The CRYPTO is active. The processing is in progress.
1 : The CRYPTO is inactive. The processing has finished.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ANAMISC_BIF</name>
	<version>1.0</version>
	<description>ANAMISC_BIF registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_CAL_IRQ_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CLK_CAL_IRQ_CLR</name>
	<description>Clear the IRQ.
1: Clear the IRQ
0: No effect.
Read out 0 always.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_CAL_IRQ_STATUS</name>
	<description>Shows the IRQ bit status.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_CAL_IRQ_EN</name>
	<description>Enable clk calibration IRQ.
0: Disabled.
1*: Enabled.

*Note: If IRQ feature is enabled, every calibration should be started by setting CLK_REF_SEL_REG[REF_CAL_START] to 1.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_CNT_REG</name>
	<description>Count value for oscillator calibration</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REF_CNT_VAL</name>
	<description>Indicates the calibration time, with a decrement counter to 1. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_SEL_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CAL_CLK_SEL</name>
	<description>Select calibration clock input to be used in calibration:
0x0 : DIVN clock
0x1 : RCLP
0x2 : RCHS
0x3 : XTAL32K
0x4 : RCOSC
0x5, 0x6 and 0x7: Reserved</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EXT_CNT_EN_SEL</name>
	<description>0 : Enable XTAL_CNT counter by the REF_CLK selected by REF_CLK_SEL.
1 : Enable XTAL_CNT counter from an external input.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CAL_START</name>
	<description>Writing a '1' starts a calibration. This bit is cleared when calibration is finished, and CLK_REF_VAL is ready. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CLK_SEL</name>
	<description>Select reference clock input for calibration:
0x0 : RCLP
0x1 : RCHS
0x2 : XTAL32K
0x3 : RCX
0x4 : RCOSC
0x5 : DIVN clock</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_REG</name>
	<description>DIVN reference cycles, lower 16 bits</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the number of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CACHE</name>
	<version>1.0</version>
	<description>CACHE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x100c0000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>84</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CACHE_CTRL2_REG</name>
	<description>Cache control register 2 (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CACHE_READY</name>
	<description>Cache Controller RO status bit.
0: Default.
1: Set to '1' when CACHE_CTRL is enabled, initialized and immediately ready for a cacheable access to service.</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CACHE_RAM_INIT</name>
	<description>Cache Controller RO status bit.
0: Default.
1: Set to '1' when SRAM is being initialized (i.e. being flushed).
Note: The flushing of the cache memory takes 256 HCLK cycles.</description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CACHE_FLUSHED</name>
	<description>0: Cache is not flushed yet.
1: Cache is flushed.

Note 1: Setting and clearing of this (status) bit field is automatically done by the hardware. It is set on the falling edge and cleared on the rising edge of the (Cache Controller) CACHE_RAM_INIT signal.
Note 2: When the Cache is flushed by disabling and enabling the Cache Controller with a SYS_CTRL_REG[CACHERAM_MUX] sequence of 1 -&gt; 0 -&gt; 1, the CACHE_FLUSHED bit can also be cleared first by the software (if needed) with writing a CACHE_CTRL2_REG(CACHE_FLUSHED) sequence of 1 -&gt; 0. This is needed when the software uses the CACHE_FLUSHED bit as a status bit to wait for (e.g. in a while-loop). </description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_FLUSH_DISABLE</name>
	<description>0: Default.
1: Flushing of the Cache memory is disabled when SYS_CTRL_REG[CACHERAM_MUX] is switched from '1' to '0'.

Note: Setting this bit to '1' is only allowed for debugging purposes.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_USE_FULL_DB_RANGE</name>
	<description>00: CACHERAM (mirrored) read/write and NO use of the full 184 bits databus (for executing program code or extension of the SysRAM with the Cache RAM).
In this mode 8 bits, 16 bits and 32 bits write access is supported.

01: CACHERAM (mirrored) read and use of the full 184 bits databus of 'SRAM_1_0' (for testing and debugging purposes).
In this mode only 32 bits write access is supported.

10: CACHERAM (mirrored) read and use of the full 184 bits databus of 'SRAM_3_2' (for testing and debugging purposes).
In this mode only 32 bits write access is supported.

11: Reserved.

Note 1: SYS_CTRL_REG[CACHERAM_MUX] must be set to '0' before accessing the memory mapped (mirrored) Cache Data and TAG memory.
Note 2: For all 3 settings, max. 8 KByte is available from the memory map.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_MHCLKEN_DISABLE</name>
	<description>0: Default.
1: The &quot;m_HCLK_EN&quot; input is ignored and the controller avoids inserting m_HTRANS=BUSY because of wait states.

Note:
This bit is only relevant for executing from QSPI Flash (when set to '1' it will improve performance). This bit should be kept on '0' for executing from eFlash.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_CWF_DISABLE</name>
	<description>0: Default.
1: The cache line refill is performed with INCR type burst and &quot;Critical Word First&quot; is disabled.

Note:
This bit is only relevant for executing from QSPI Flash (when set to '1' it will improve performance).This bit should be kept on '0' for executing from eFlash.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_CGEN</name>
	<description>0: Cache controller clock gating is not enabled.
1: Cache controller clock gating is enabled (enabling power saving).</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_WEN</name>
	<description>0: Cache Data and TAG memory read only.
1: Cache Data and TAG memory read/write.
The Data and TAG memory are only updated by the cache controller.
There is no HW protection to prevent unauthorized access by the ARM.
Note 1: When accessing the memory mapped Cache Data and TAG memory (which is only allowed for debugging purposes) only 32 bits access is supported.
Note 2: SYS_CTRL_REG[CACHERAM_MUX] must be set to '0' before accessing the memory mapped Cache Data and TAG memory.
See also the CACHE_CTRL2_REG[CACHE_USE_FULL_DB_RANGE] description.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_LEN</name>
	<description>Length of OQSPI FLASH cacheable memory.
N*64 KBytes. N = 0 to 2048, incl. 2048 (max. of 128 Mbytes).
Setting CACHE_LEN=0 disables the caching.

Note 1: The max. relevant CACHE_LEN setting depends on the chosen Flash region (program) size.
Note 2: The first block (CACHE_LEN=1) includes the memory space specified by CACHE_FLASH_REG[FLASH_REGION_OFFSET].</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_FLASH_REG</name>
	<description>Cache QSPI Flash program size and base address register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x18000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FLASH_REGION_BASE</name>
	<description>These bits corresponds with the Flash region base address bits [31:16].
Default value is '0x1800'.
The Flash region base address bits [31:27] are fixed to '0b00011', supporting the range of 0x1800-0x1FFF'.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2 The Flash region base address setting depends on the chosen Flash region size.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_OFFSET</name>
	<description>Flash region offset address (in words).
This value is added to the Flash (CPU) address bits [13:2].
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.</description>
	<bitRange>[15:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_SIZE</name>
	<description>Flash region size.
Default value is '1' (0.5 MBytes).
0 = 0.25 MBytes,
1 = 0.5 MBytes,
2 = 1 MBytes,
3 = 2 MBytes,
4 = 4 MBytes,
5 = 8 MBytes,
6 = 16 MBytes,
7 = 32 MBytes,
8 = 64 MBytes,
9 = 128 MBytes.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2: See for the max. region (program) size the memory map.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_CTRL_REG</name>
	<description>Cache MRM (Miss Rate Monitor) CONTROL register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_IRQ_HITS_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache hits reached the programmed threshold (threshold != 0).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MISSES_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache misses reached the programmed threshold (threshold != 0).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_TINT_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the time interval counter reached the end (time interval != 0).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MASK</name>
	<description>0: Disables interrupt generation.
1: Enables interrupt generation.
Note: The Cache MRM generates a pulse-sensitive interrupt towards the ARM processor,</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_START</name>
	<description>0: Freeze the &quot;misses/hits&quot; counters and reset the time interval counter to the programmed value in CACHE_MRM_TINT_REG.
1: Enables the counters.
Note: In case CACHE_MRM_CTRL_REG[MRM_START] is set to '1' and CACHE_MRM_TINT_REG (!=0) is used for the MRM interrupt generation, the time interval counter counts down (on a fixed reference clock of 32 MHz) until it's '0'. At that time CACHE_MRM_CTRL_REG[MRM_START] will be reset automatically to '0' by the MRM hardware and the MRM interrupt will be generated.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS1WS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS with 1 Wait State register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_HITS1WS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_HITS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS THRESHOLD register (only Word (32-bits) access supported).</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_HITS_THRES</name>
	<description>Defines the hits threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_HITS_THRES_STATUS].
Note: When MRM_HITS_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_MISSES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) MISSES register (only Word (32-bits) access supported).</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES</name>
	<description>Contains the amount of cache misses.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_MISSES_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) THRESHOLD register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES_THRES</name>
	<description>Defines the misses threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_MISSES_THRES_STATUS].
Note: When MRM_MISSES_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_TINT_REG</name>
	<description>Cache MRM (Miss Rate Monitor) TIME INTERVAL register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_TINT</name>
	<description>Defines the time interval for the monitoring in 32 MHz clock cycles. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_TINT_STATUS].
Note: When MRM_TINT=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[18:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SWD_RESET_REG</name>
	<description>SWD HW reset control register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SWD_HW_RESET_REQ</name>
	<description>0: default.
1: HW reset request (from the debugger tool). The register is automatically reset with a HW_RESET.
This bit can only be accessed by the debugger software and not by the application.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHARGER</name>
	<version>1.0</version>
	<description>CHARGER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x51000600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>136</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CHARGER_CC_CHARGE_TIMER_REG</name>
	<description>Maximum CC-charge time limit register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001c20</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CC_CHARGE_TIMER</name>
	<description>Returns the current value of the CC-Charge timeout counter, running at a 1Hz clock. The range of the specific timer is identical to the one of the Pre-Charge and the CV-Charge timers, so it may count up to 6 hours, ranging from 0 to MAX_CC_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[30:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_CC_CHARGE_TIME</name>
	<description>This bit-field determines the maximum time (measured in ticks of the Charger's 1Hz clock) allowed for the CC (Constant Current) charging stage. If this is exceeded, a CC charge time-out error will be captured by the Charger's control unit and its FSM will move to the ERROR state. In order to exit this state and re-start charging, the CHARGER_RESUME bit-field of CHARGER_CTRL_REG must be set.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_CTRL_REG</name>
	<description>Charger main control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x003f6a78</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>EOC_TRIGGER</name>
	<description>0 = Edge-sensitive End-of-Charge detection support is enabled (default). The Charger's digital block expects a positive edge of the End-of-Charge signal coming from the Charger's analog circuit to let the respective debounce counters start and enable the FSM switch to the END_OF_CHARGE state, if the signal is stable.
1 = Level-sensitive End-of-Charge detection is enabled. In this mode, the Charger's digital block only monitors the level of the End-of-Charge signal coming from the analog circuit and if this is seen high in either CC_CHARGE or CV_CHARGE state, the EOC debounce counters start.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EOC_INTERVAL_CHECK_TIMER</name>
	<description>The specific bit-field determines the current state of the timer used to periodically check the End-of-Charge signal, as soon as the Charger's FSM is either in CC_CHARGE or CV_CHARGE state. Thus, as soon as the Charger's FSM enters the CC_CHARGE state:
  - The timer starts increasing when a positive edge detection on End-of-Charge signal occurs.
  - It keeps increasing until reaching the programmed EOC_INTERVAL_CHECK_THRES value, if and only if there is no detection of a negative edge on End-of-Charge signal. If this happens, the timer resets and starts over with a new End-of-Charge positive edge.
  - The timer also resets after having reached its programmed threshold or when the Charger's FSM next state is END_OF_CHARGE. This happens only after having found End-of-Charge signal asserted for 4 consecutive checks and provided that the specific signal has not de-asserted during the timer's interval.
Note: It must be noted that out of these two states, the specific timer is kept to zero. It is also noted that this timer runs at the 1Mhz clock of the Charger's block and its value always ranges from 0 to the EOC_INTERVAL_CHECK_THRES value set in the respective bit-field of CHARGER_CTRL_REG.</description>
	<bitRange>[27:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EOC_INTERVAL_CHECK_THRES</name>
	<description>This bit-field determines the periodic interval of checking the End-of-Charge signal, when the Charger's FSM is either in CC_CHARGE or in CV_CHARGE state. To implement this, a dedicated timer has been used, counting from zero up to the value programmed into this bit-field (see also EOC_INTERVAL_CHECK_TIMER field's description).
As soon as this timer reaches the programmed value, the End-of-Charge signal is sampled and depending on its status (high or low), another counter, keeping the number of consecutive End-of-Charge events, is increased or not. See also the description of the EOC_DEBOUNCE_CNT bit-field of CHARGER_STATUS_REG, for this counter.
Note: The specific bit-field should always be programmed to a non-zero value.</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REPLENISH_MODE</name>
	<description>When this bit-field is set and the Charger's FSM is in the BYPASSED state (thus, in Bypass mode), the internal multiplexer inside the digital part of the charger selects the Replenish, instead of the Pre-charge setting to be driven to the main Vbat comparator of the Charger's analogue circuitry. By this way, SW can read the respective analogue comparator's output in CHARGER_STATUS_REG (bit-field MAIN_VBAT_COMP_OUT), after the battery's volrtage has reached the End-of-Charge level, and determine if the battery voltage has dropped below the Replenish level, re-starting the battery charging accordingly.
Note: When the Charger's FSM is active and operational, this bit-field is don't care and the FSM determines which level (Pre-charge or Replenish) will be selected and driven to the analogue, depending on the current state. It is also noted that the supported Pre-charge and Replenish levels can be viewed in the respective bit-fields defined in CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRE_CHARGE_MODE</name>
	<description>When set, this bit-field enables a signal of the same name with the bit-field, driven from the Charger's digital part towards the analogue circuitry, in order to determine the current in Pre-Charge mode. If the Charger's FSM is active and operational, the specific bit-field is don't care. Hence, it is considered only when the Charger's FSM has reached the BYPASSED state (thus, in Bypass mode).
With the Charger's FSM being bypassed, SW should take over control and set the specific bit-field, in order to deliver the Pre-Charge instead of the normal Charge current to the Charger's analogue circuitry, during the Pre-Charge phase.
Note: See also the description of CHARGER_CURRENT_PARAM_REG register for the Pre-Charge and normal Charge current levels supported.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_LOOP_HOLD</name>
	<description>When set, this bit-field disables charging, provided that the Charger's FSM has switched to the BYPASSED state. This is possible only by setting the CHARGER_BYPASS bit-field of this register.
Thus, as soon as the Charger's FSM is bypassed, the respective signal driven by the FSM is overruled by this bit-field, making the analogue part of the Charger controllable also in this mode. If the Charger's FSM is not bypassed, this bit-field is don't care.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>JEITA_SUPPORT_DISABLED</name>
	<description>0 = Charger's JEITA FSM monitoring the battery temperature checks also if battery temperature is in the Warm or Cool zones.
In that case, it updates accordingly all the Charger's voltage levels (Charge, Pre-Charge, Replenish and OVP) programmed in CHARGER_VOLTAGE_PARAM_REG, as well as the charge and pre-charge current settings of CHARGER_CURRENT_PARAM_REG, depending on the temperature zone determined by the analogue circuitry of the Charger (see also the JEITA registers of the Charger's register file for the Voltage/Current levels in Warm and Cool temperature zones).
1 = Charger's JEITA FSM monitoring the battery temperature checks only if battery temperature is either in the Hot or Cold zones. In that case, it notifies the main Charger FSM to stop charging automatically, when in Hot zone. The same will happen also for the case of Cold, unless the NTC_LOW_DISABLE bit-field of CHARGER_CTRL_REG is set.
Note : It is not recommended to have the specific bit-field kept to '0' (and thus the JEITA support enabled), if at the same time the bit-field TBAT_PROT_ENABLE of the same register is also '0'. Thus, JEITA support should be coupled with the Battery's temperature protection.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_MONITOR_MODE</name>
	<description>Battery temperature pack monitoring modes, according to the following encoding:
00 = Battery temperature state checked and updated once, as soon as the charger is powered-up and settled.
01 = Battery temperature state checked periodically, depeding on TBAT_MON_TIMER_REG.TBAT_MON_INTERVAL and provided that Charger has been powered-up and charger's FSM is enabled.
10 = Battery temperature state checked periodically depending on TBAT_MON_TIMER_REG.TBAT_MON_INTERVAL, provided that Charger is powered-up and regardless if the Charger's FSM is enabled or not. Hence, this mode can be effective regardless of the state of CHARGE_START bit-field of CHARGER_CTRL_REG.
11 = When selected, it freezes the Battery temperature monitor FSM, as soon as the latter reaches the CHECK_IDLE state (see also CHARGER_STATUS_REG.CHARGER_JEITA_STATE bit-field's description for the states of this FSM). In this mode, the monitoring of Battery temperature is possible only by checking the status of TBAT_HOT_COMP_OUT and MAIN_TBAT_COMP_OUT bit-fields of CHARGER_STATUS_REG, thus by letting SW take over monitoring. This setting may be used in conjunction with Bypass mode (by setting CHARGER_BYPASS of CHARGER_CTRL_REG), so that both charging and battery temperature status monitoring are controlled by SW.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_TIMERS_HALT_ENABLE</name>
	<description>0 = Charge timeout timers continue running when charging is disabled because of a Die or of a Battery temperature error, if and only if STOP_CHARGE_TIMERS bit-field is '0' (default). If it is '1', the counters are stopped also in TDIE_PROT and TBAT_PROT states.
1 = Charge timeout timers are halted in case of a Die or of a Battery temperature error.
In that case, the global charge timer is stopped as soon as the Charger's FSM moves to TDIE_PROT or TBAT_PROT state. Also, either the Pre-Charge, the CC_CHARGE or the CV_CHARGE timer is also stopped, depending on the charging state of the FSM when the Die/Battery temperature error has been detected. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>STOP_CHARGE_TIMERS</name>
	<description>0 = Charger's Pre-Charge, CC, CV and Total charge timeout timers are ticking properly, running at the 1Hz clock.
1 = All four Charger's timeout timers are halted, counting is disabled. The counters will be reset when the FSM is either in DISABLED or in END_OF_CHARGE state.
Note: Value '0' is the recommended, '1' is a test mode, since it will globally halt the four timers and thus will block the generation of the respective timer expiration IRQs.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NTC_LOW_DISABLE</name>
	<description>0 = Charging is disabled when the battery temperature is found to have reached the &quot;COLD&quot; region. Therefore, the Charger's FSM moves directly to &quot;TBAT_PROT&quot; error and generates an IRQ to notify the system accordingly, in case the respective IRQ mask bit of CHARGER_ERROR_IRQ_MASK_REG is set. Also, CHARGER_ERROR_IRQ_STATUS_REG. TBAT_ERROR_IRQ field is updated accordingly.
1 = Charging is allowed to continue, even when the battery temperature pack reaches the &quot;COLD&quot; region. Consequently, the FSM continues charging and no battery temperature error event is generated.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_PROT_ENABLE</name>
	<description>0 = Battery temperature protection disabled
1 = Battery temperature protection enabled.
Charging will be stopped in case Battery temperature reaches &quot;Hot&quot; zone. It will also be disabled when reaching &quot;Cold&quot; zone, provided that CHARGER_CTRL_REG.NTC_LOW_DISABLE is not set. This is handled by the Charger's FSM, which moves directly to the respective error state (TBAT_PROT), also generating an Error IRQ if the respective IRQ mask bit is set (see also CHARGER_ERROR_IRQ_MASK_REG).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_ERROR_RESUME</name>
	<description>0 = FSM will not resume from a Die temperature error. Consequently, its state will be staying to &quot;TDIE_PROT&quot;, for as long as this bit-field is kept low, regardless of the status of the die tempeture comparator. Also, disabling the specific bit-field will reset the Die temperature error debounce counter, when the Charger's FSM is in TDIE_PROT state (so when a Die temperature error has been already detected) and the specific counter will remain frozen to 0 until the TDIE_ERROR_RESUME bit-field is set (see also the TDIE_ERROR_DEBOUNCE_CNT bit-field of CHARGER_STATUS_REG).
1 = FSM will resume from a Die temperature error, as soon as the respective analogue compator confirms that die temperature is again below the maximum allowed level.
It is noted that the maximum Die temperature level is programmable via the CHARGER_TEMPSET_PARAM_REG register's respective bit-field (T_DIE_MAX).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_PROT_ENABLE</name>
	<description>0 = Die temperature protection is disabled, thus charging will not be disabled by the Charger's FSM in case of a Die temperature error.
1 = Die temperature protection is enabled, thus the Charger's FSM will move to &quot;TDIE_PROT&quot; state, disabling charging at the same time.
It is noted that the Die temperature error event will be logged in the respective status bit of CHARGER_IRQ_ERROR_STATUS_REG and an IRQ will be generated, if and only if the corresponding mask bit of CHARGER_IRQ_MASK_REG is set. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGER_RESUME</name>
	<description>0 = Charger's FSM is not enable to resume from a charge timeout error or a Vbat OVP (Over-Voltage Protection) error. Consequently, FSM stays in &quot;ERROR&quot; state.
1 = Charger's FSM will resume from a charge timeout or from an OVP error, thus its state will move from &quot;ERROR&quot; to &quot;DISABLED&quot; state, so that the charge cycle starts-over.
It is noted that in the case of a Vbat OVP error, the FSM will leave &quot;ERROR&quot; state, as soon as the Vbat comparator for the OVP level shows that Vbat is again OK (so lower than the OVP setting).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGER_BYPASS</name>
	<description>0 = Charger's FSM is active and running, notifying SW upon switching between its states
1 = Charger's FSM is bypassed, so its state stays to &quot;BYPASS&quot;, so SW should take over the monitoring of the battery voltage and control of the charger. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGE_START</name>
	<description>0 = Charger's FSM is disabled, FSM stays at &quot;DISABLED&quot; state
1 = Charger's FSM is enabled, so FSM's state can move from DISABLED to the actual charge states, starting from &quot;PRE_CHARGE&quot;.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHARGER_ENABLE</name>
	<description>0 = Charger's analogue circuitry is powered-down
1 = Charger's analogue circuitry is being powered-up and will be available after a certain settling time (in ms).
As soon as this bit-field is set, the Charger's FSM waits for this settling time, before proceeding into DISABLED state, where it checks the Vbat level, as well as the Die temperature and the Battery temperature states. This is mandatory, before the actual charging begins, so before the FSM moves to PRE_CHARGE state.
It is finally noted that the settling time is configurable via CHARGER_PWR_UP_TIMER_REG, counting with the 1Khz clock.
Note: The Charger clocks must have been enabled first, by setting the CLK_SYS_REG[CLK_CHG_EN] bit-field to '1', in order to let the FSM proceed.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_CURRENT_PARAM_REG</name>
	<description>Charger current settings register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000020c6</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I_EOC_DOUBLE_RANGE</name>
	<description>When set, the specific bit-field enables an increase of the (%) range of End-of-Charge current setting. Consequently, the default lower and upper limits of 6% of I_CHARGE (value 0x0 of I_END_OF_CHARGE bit-field) and 20% (value 0x7 of the same bit-field) are increased to 12% and 40% respectively, as soon as the I_EOC_DOUBLE_RANGE bit-field is set.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_END_OF_CHARGE</name>
	<description>End-of-Charge current setting, ranging from 6%(&quot;000&quot;) to 20% (&quot;111&quot;) of the charge current setting, with a step size of 2%, as follows (when I_EOC_DOUBLE_RANGE = 0):
000 : 6%
001 : 8%
010 : 10%
011 : 12%
100 : 14%
101 : 16%
110 : 18%
111 : 20%
When I_EOC_DOUBLE_RANGE = 1, the range is:
000 : 12%
001 : 16%
010 : 20%
011 : 24%
100 : 28%
101 : 32%
110 : 36%
111 : 40%</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_PRECHARGE</name>
	<description>This bit-field determines the Pre-Charge current, in mA, ranging from 0.5 to 72mA, according to the following encoding:
0   :  0.5 mA
1   :  1  mA
2   :  1.5mA
3   :  2 mA
4   :  2.5mA
5   :  3  mA
6   :  3.5mA
7   :  4  mA
8   :  4.5mA
9   :  5  mA
10 :  5.5mA
11 :  6  mA
12 :  6.5mA
13 :  7  mA
14 :  7.5mA
15 :  8  mA
16 :  9  mA
17 : 10 mA
18 : 11 mA
19 : 12 mA
20 : 13 mA
21 : 14 mA
22 : 15 mA
23 : 16 mA
24 : 17 mA
25 : 18 mA
26 : 19 mA
27 : 20 mA
28 : 21 mA
29 : 22 mA
30 : 23 mA
31 : 24 mA
32 : 27 mA
33 : 30 mA
34 : 33 mA
35 : 36 mA
36 : 39 mA
37 : 42 mA
38 : 45 mA
39 : 48 mA
40 : 51 mA
41 : 54 mA
42 : 57 mA
43 : 60 mA
44 : 63 mA
45 : 66 mA
46 : 69 mA
47 : 72 mA
48 : 72 mA
49 : 72 mA
50 : 72 mA
51 : 72 mA
52 : 72 mA
53 : 72 mA
54 : 72 mA
55 : 72 mA
56 : 72 mA
57 : 72 mA
58 : 72 mA
59 : 72 mA
60 : 72 mA
61 : 72 mA
62 : 72 mA
63 : 72 mA</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE</name>
	<description>This bit-field determines the charge current range, in mA. The range is from 5mA to 720mA, according to the following encoding:
0   :   5 mA
1   :  10 mA
2   :  15 mA
3   :  20 mA
4   :  25 mA
5   :  30 mA
6   :  35 mA
7   :  40 mA
8   :  45 mA
9   :  50 mA
10 :  55 mA
11 :  60 mA
12 :  65 mA
13 :  70 mA
14 :  75 mA
15 :  80 mA
16 :  90 mA
17 : 100 mA
18 : 110 mA
19 : 120 mA
20 : 130 mA
21 : 140 mA
22 : 150 mA
23 : 160 mA
24 : 170 mA
25 : 180 mA
26 : 190 mA
27 : 200 mA
28 : 210 mA
29 : 220 mA
30 : 230 mA
31 : 240 mA
32 : 270 mA
33 : 300 mA
34 : 330 mA
35 : 360 mA
36 : 390 mA
37 : 420 mA
38 : 450 mA
39 : 480 mA
40 : 510 mA
41 : 540 mA
42 : 570 mA
43 : 600 mA
44 : 630 mA
45 : 660 mA
46 : 690 mA
47 : 720 mA
48 : 720 mA
49 : 720 mA
50 : 720 mA
51 : 720 mA
52 : 720 mA
53 : 720 mA
54 : 720 mA
55 : 720 mA
56 : 720 mA
57 : 720 mA
58 : 720 mA
59 : 720 mA
60 : 720 mA
61 : 720 mA
62 : 720 mA
63 : 720 mA
Note: It has to be noted that the specific values correspond to the normal battery temperature zone. However, the specific register field may be updated by the JEITA FSM (which checks the battery temperature either once or periodically), in order to adapt the Charge current to the new battery temperature zone (see also CHARGER_CTRL_REG.TBAT_MONITOR_MODE field as well). This is valid also for the Pre-Charge current field of this register and provided that JEITA support is enabled in CHARGER_CTRL_REG.
Consequently, in that case the register return the Charge current settings that abide to the JEITA requirements for the battery (either COOLER, COOL, WARM or NORMAL).</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_CURRENT_STATUS_REG</name>
	<description>Charger current status register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000085</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>I_PRECHARGE_SET</name>
	<description>This bit-field returns the applied Pre-Charge current setting. In JEITA charging, it contains the Pre-Charge value corresponding to the present battery temperature zone, according to JEITA_CURRENT/CURRENT2_SETTINGS_REG. If JEITA charging is disabled, it reflects the value of I_PRECHARGE bit-field CHARGER_CURRENT_PARAM_REG.
The specific bit-field is updated by the battery monitoring (JEITA) FSM, as soon as the latter starts running. Until then, it reflects the corresponding bit-field of CHARGER_CURRENT_PARAM_REG.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I_CHARGE_SET</name>
	<description>This bit-field returns the applied CC current setting. In JEITA charging, it contains the value corresponding to the present battery temperature zone, according to CHARGER_JEITA_CURRENT/CURRENT2_REG. If JEITA charging is disabled, it reflects the value of I_CHARGE bit-field CHARGER_CURRENT_PARAM_REG.
The specific bit-field is updated by the battery monitoring (JEITA) FSM, as soon as the latter starts running. Until then, it reflects the corresponding bit-field of CHARGER_CURRENT_PARAM_REG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_CV_CHARGE_TIMER_REG</name>
	<description>Maximum CV-charge time limit register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001c20</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CV_CHARGE_TIMER</name>
	<description>Returns the current value of the CV-Charge timeout counter, running at a 1Hz clock. The range of the specific timer is identical to the one of the Pre-Charge and the CC-Charge timers, so it may count up to 6 hours, ranging from 0 to MAX_CV_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[30:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_CV_CHARGE_TIME</name>
	<description>This bit-field determines the maximum time (measured in ticks of the Charger's 1Hz clock) allowed for the CV (Constant Voltage) charging stage. If this is exceeded, a CV charge time-out error will be captured by the Charger's control unit and its FSM will move to the ERROR state. In order to exit this state and re-start charging, the CHARGER_RESUME bit-field of CHARGER_CTRL_REG must be set.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_ERROR_IRQ_CLR_REG</name>
	<description>Interrupt clear register of Charger Error IRQs</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>TBAT_ERROR_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TDIE_ERROR_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>VBAT_OVP_ERROR_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TOTAL_CHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CV_CHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_CHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PRECHARGE_TIMEOUT_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's Error IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_ERROR_IRQ_MASK_REG</name>
	<description>Mask register of Charger Error IRQs</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>TBAT_ERROR_IRQ_EN</name>
	<description>When set, it enables the generation of Battery temperature IRQs.The IRQ is generated as soon as the JEITA FSM detects that the battery temperature is either in the &quot;Hot&quot; or in the &quot;Cold&quot; temperature region, by sampling the respective comparators' output.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_ERROR_IRQ_EN</name>
	<description>When set, it enables the generation of Die temperature error IRQs. The IRQ is generated as soon as a Die temperature error is captured, so as soon as the Charger's FSM moves to the TDIE_PROT state. For this to happen, the Die temperature comparator should indicate that Die temperature has exceeded the limit defined in CHARGER_TEMPSET_PARAM_REG.TDIE_MAX.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_OVP_ERROR_IRQ_EN</name>
	<description>When set, it enables the generation of VBAT_OVP IRQs. The IRQ is generated as soon as the dedicated Vbat comparator shows that Vbat has exceeded the OVP level and the Charger's FSM has switched to the respective error state (&quot;ERROR&quot;).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TOTAL_CHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the total charge timeout IRQs. The IRQ is generated as soon as the Charger's global charge timer expires, reaching 0.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CV_CHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the CV charge timeout IRQs. The IRQ is generated as soon as the Charger's state timer expires, reaching 0 when the FSM is in the CV_CHARGE state.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_CHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the CC charge timeout IRQs. The IRQ is generated as soon as the Charger's state timer, expires, reaching 0.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRECHARGE_TIMEOUT_IRQ_EN</name>
	<description>When set, it enables the Pre-Charge timeout IRQs. The IRQ is generated as soon as the Charger's state timer expires, reaching 0.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_ERROR_IRQ_STATUS_REG</name>
	<description>Status register of Charger Error IRQs</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>TBAT_ERROR_IRQ</name>
	<description>0 = No Battery temperature error IRQ event is captured, so charging may continue
1 = A Battery temperature error IRQ event has been captured, declaring that the Charger's FSM has moved to the respective error state (TBAT_PROT).
Note : The status bit is updated automatically when the Battery temperature is detected to be either in the HOT or in the COLD zone, regardless of the state of the respective IRQ mask bit.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_ERROR_IRQ</name>
	<description>0 = No Die temperature error IRQ events have been captured, so charging may continue
1 = A Die temperature error IRQ event is captured, declaring that the Charger's FSM has switched to the respective error state (TDIE_PROT) and charging will be automatically stopped.
Note : The status bit is updated automatically when a Die temperature error is detected, thus when the die temperature is found to have exceeded the programmed level, regardless of the state of the respective IRQ mask bit. The same applies to all the other status bits of the specific register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_OVP_ERROR_IRQ</name>
	<description>0 = Vbat has not exceeded the Over-Voltage Protection (OVP) level, so charging may continue
1 = Vbat has exceeded the Over-Voltage level, thus an OVP error event has been captured. The Charger's FSM switches to the respective error state (ERROR) as soon as the OVP event is captured by the digital part of the Charger and charging will be automatically stopped.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TOTAL_CHARGE_TIMEOUT_IRQ</name>
	<description>0 = Total charge time counter has not yet reached the maximum charge time (set in CHARGER_TOTAL_CHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CV_CHARGE_TIMEOUT_IRQ</name>
	<description>0 = State charge time counter has not yet reached the maximum CV charge time (set in CHARGER_CV_CHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum CV charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_CHARGE_TIMEOUT_IRQ</name>
	<description>0 = State charge time counter has not yet reached the maximum CC charge time (set in CHARGER_CC_CHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum CC charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PRECHARGE_TIMEOUT_IRQ</name>
	<description>0 = State charge time counter has not yet reached the maximum Pre-charge time (set in CHARGER_PRECHARGE_TIME_REG)
1 = Total charge time counter has reached the maximum Pre-charge time programmed. The Charger's FSM will move to the respective error state (ERROR) and charging will be automatically stopped, as soon as the specific event is captured.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_CURRENT2_REG</name>
	<description>JEITA-compliant current settings register for &quot;Cooler&quot; and &quot;Warmer&quot; zones</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00042105</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I_PRECHARGE_TWARMER</name>
	<description>Pre-charge current settings bit-field for the &quot;WARMER&quot; battery temperature pack zone. Regarding the range of values of this bit-field, see also the description of I_PRECHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_PRECHARGE_TCOOLER</name>
	<description>Pre-charge current settings bit-field for the &quot;COOLER&quot; battery temperature pack zone. Regarding the range of values of this bit-field, see also the description of I_PRECHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE_TWARMER</name>
	<description>Charge current settings bit-field for the &quot;WARMER&quot; battery temperature pack zone. Regarding the range of values of this bit-field, see also the description of I_CHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE_TCOOLER</name>
	<description>Charge current settings bit-field for the &quot;COOLER&quot; battery temperature pack zone. Regarding the range of values of this bit-field, see also the description of I_CHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_CURRENT_REG</name>
	<description>JEITA-compliant current settings register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00042105</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I_PRECHARGE_TWARM</name>
	<description>Pre-Charge current setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of I_PRECHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_PRECHARGE_TCOOL</name>
	<description>Pre-Charge current setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of I_PRECHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE_TWARM</name>
	<description>Charge current setting for the Warm battery temperature pack zone. Regarding the range of values of this bit-field, see also the description of I_CHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I_CHARGE_TCOOL</name>
	<description>Charge current setting for the &quot;COOL&quot; battery temperature level. Regarding the range of values of this bit-field, see also the description of I_CHARGE field of CHARGER_CURRENT_PARAM_REG register.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_CHARGE_REG</name>
	<description>JEITA-compliant Charge voltage settings register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00a68a68</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>V_CHARGE_TWARMER</name>
	<description>Charge voltage setting for the Warmer battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_CHARGE_TCOOLER</name>
	<description>Charge voltage setting for the Cooler battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_CHARGE_TWARM</name>
	<description>Charge voltage setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_CHARGE_TCOOL</name>
	<description>Charge voltage setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_OVP_REG</name>
	<description>JEITA-compliant OVP settings register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d76d76</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>V_OVP_TWARMER</name>
	<description>VBAT Over-voltage Protection (OVP) setting for the Warmer battery temperature zone.Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_OVP_TCOOLER</name>
	<description>VBAT Over-voltage Protection (OVP) setting for the Cooler battery temperature zone.Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_OVP_TWARM</name>
	<description>VBAT Over-voltage Protection (OVP) setting for the Warm battery temperature zone.Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_OVP_TCOOL</name>
	<description>VBAT Over-voltage Protection (OVP) setting for the Cool battery temperature zone.Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_PRECHARGE_REG</name>
	<description>JEITA-compliant Pre-Charge voltage settings register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00187187</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>V_PRECHARGE_TWARMER</name>
	<description>Pre-Charge voltage setting for the Warmer battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_PRECHARGE_TCOOLER</name>
	<description>Pre-Charge voltage setting for the Cooler battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_PRECHARGE_TWARM</name>
	<description>Pre-Charge voltage setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_PRECHARGE_TCOOL</name>
	<description>Pre-Charge current setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG register.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_JEITA_V_REPLENISH_REG</name>
	<description>JEITA-compliant Replenish settings register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0079f79f</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>V_REPLENISH_TWARMER</name>
	<description>Replenish voltage setting for the Warmer battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_REPLENISH_TCOOLER</name>
	<description>Replenish voltage setting for the Cooler battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_REPLENISH_TWARM</name>
	<description>Replenish voltage setting for the Warm battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_REPLENISH_TCOOL</name>
	<description>Replenish voltage setting for the Cool battery temperature zone. Regarding the range of values of this bit-field, see also the description of V_CHARGE field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_LOCK_REG</name>
	<description>Charger HW lock register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CHARGER_SWLOCK_EN</name>
	<description>0 = SW-based protection of Charger registers is disabled, protection is dependent on the value of bits [14:0]
1 = SW-based protection of Charger registers is active. Thus, if any of the 15 lock bits is non-set, the respective Charger register can be locked and back un-locked for writing, if the proper lock/un-lock sequence of writes is issued to CHARGER_SWLOCK_REG.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>JEITA_I_CHARGE2_LOCK</name>
	<description>0 = CHARGER_JEITA_CURRENT2_REG is un-locked, register writes are allowed
1 = CHARGER_JEITA_CURRENT2_REG is locked, register writes are not allowed</description>
	<bitRange>[14:14]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>JEITA_I_CHARGE_LOCK</name>
	<description>0 = CHARGER_JEITA_CURRENT_REG is un-locked, register writes are allowed
1 = CHARGER_JEITA_CURRENT_REG is locked, register writes are not allowed</description>
	<bitRange>[13:13]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>JEITA_V_OVP_LOCK</name>
	<description>0 = CHARGER_JEITA_V_OVP_REG is un-locked, register writes are allowed
1 = CHARGER_JEITA_V_OVP_REG is locked, register writes are not allowed</description>
	<bitRange>[12:12]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>JEITA_V_PRECHARGE_LOCK</name>
	<description>0 = CHARGER_JEITA_V_PRECHARGE_REG is un-locked, register writes are allowed
1 = CHARGER_JEITA_V_PRECHARGE_REG is locked, register writes are not allowed</description>
	<bitRange>[11:11]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>JEITA_V_CHARGE_LOCK</name>
	<description>0 = CHARGER_JEITA_V_CHARGE_REG is un-locked, register writes are allowed
1 = CHARGER_JEITA_V_CHARGE_REG is locked, register writes are not allowed</description>
	<bitRange>[10:10]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>TOTAL_CHARGE_TIMEOUT_LOCK</name>
	<description>0 = CHARGER_TOTAL_CHARGE_TIMER_REG is un-locked, register writes are allowed
1 = CHARGER_TOTAL_CHARGE_TIMER_REG is locked, register writes are not allowed</description>
	<bitRange>[9:9]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>CV_CHARGE_TIMEOUT_LOCK</name>
	<description>0 = CHARGER_CV_CHARGE_TIMER_REG is un-locked, register writes are allowed
1 = CHARGER_CV_CHARGE_TIMER_REG is locked, register writes are not allowed</description>
	<bitRange>[8:8]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>CC_CHARGE_TIMEOUT_LOCK</name>
	<description>0 = CHARGER_CC_CHARGE_TIMER_REG is un-locked, register writes are allowed
1 = CHARGER_CC_CHARGE_TIMER_REG is locked, register writes are not allowed</description>
	<bitRange>[7:7]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>PRECHARGE_TIMEOUT_LOCK</name>
	<description>0 = CHARGER_PRE_CHARGE_TIMER_REG is un-locked, register writes are allowed
1 = CHARGER_PRE_CHARGE_TIMER_REG is locked, register writes are not allowed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>TEMPSET2_PARAM_LOCK</name>
	<description>0 = CHARGER_TEMPSET2_PARAM_REG is un-locked, register writes are allowed
1 = CHARGER_TEMPSET2_PARAM_REG is locked, register writes are not allowed</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>TEMPSET_PARAM_LOCK</name>
	<description>0 = CHARGER_TEMPSET_PARAM_REG is un-locked, register writes are allowed
1 = CHARGER_TEMPSET_PARAM_REG is locked, register writes are not allowed</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>CURRENT_PARAM_LOCK</name>
	<description>0 = CHARGER_CURRENT_PARAM_REG is un-locked, writes are allowed
1 = All bit-fields of the register are locked, writes are not allowed</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>VOLTAGE_PARAM_LOCK</name>
	<description>0 = CHARGER_VOLTAGE_PARAM_REG is un-locked, register writes are allowed
1 = All bit-fields except of V_REPLENISH are locked, register writes to these bit-fields are not allowed</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>CHARGER_TEST_CTRL_LOCK</name>
	<description>0 = CHARGER_TEST_CTRL_REG is un-locked, register writes are allowed
1 = CHARGER_TEST_CTRL_REG is locked, register writes are not allowed</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>CHARGER_CTRL_LOCK</name>
	<description>0 = Protected bit-fields of CHARGER_CTRL_REG are un-locked, register writes are allowed 
1 = Protected bit-fields are locked, register writes are not allowed
The protected bit-fields of CHARGER_CTRL_REG are: CHARGER_BYPASS, TDIE_PROT_ENABLE, TBAT_PROT_ENABLE, NTC_LOW_DISABLE, STOP_CHARGE_TIMERS, TBAT_MONITOR_MODE and JEITA_SUPPORT_DISABLED.
Note: All the CHARGER_LOCK_REG bits are set-only bits. So if any of them is set by writing a '1', it cannot be unset by writing a '0'.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>CHARGER_PRE_CHARGE_TIMER_REG</name>
	<description>Maximum pre-charge time limit register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000708</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PRE_CHARGE_TIMER</name>
	<description>Returns the current value of the Pre-Charge timeout counter, running at a 1Hz clock. The range of the specific timer is identical to the one of the CC-Charge and the CV-Charge timers, so it may count up to 6 hours, ranging from 0 to MAX_PRE_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[30:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_PRE_CHARGE_TIME</name>
	<description>This bit-field determines the maximum time (measured in ticks of the Charger's 1Hz clock) allowed for the Pre-Charge stage. If this is exceeded, a Pre-Charge time-out error will be captured by the Charger's control unit and its FSM will move to the respective state (ERROR). In order to exit this state and re-start charging, the CHARGER_RESUME bit-field of CHARGER_CTRL_REG must be set.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_PWR_UP_TIMER_REG</name>
	<description>Charger power-up settling timer register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields><field>
	<name>CHARGER_PWR_UP_TIMER</name>
	<description>Returns the current value of the charger's power-up timer, running with the 1Khz clock.
Note: The specific timer is reset to the value programmed to CHARGER_PWR_UP_SETTLING bit-field, when the Charger's analogue circuitry has been enabled, after being disabled initially. By setting CHARGER_CTRL_REG[CHARGER_ENABLE] to '0', the analogue part is disabled and in order to be properly enable, SW has to wait for 1ms (one 1Khz clock period) time. The latter is is needed to ensure that the power-up timer's control signals in the Charger's digital part will be cleared when the analogue part is again enabled, so that a proper new start-up of the Charger's FSM is possible.</description>
	<bitRange>[20:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_PWR_UP_SETTLING</name>
	<description>This bit-field determines the charger's power-up (settling) time, required for the analogue circuitry of the charger. As soon as the charger is powered-on by setting the CHARGER_ENABLE bit-field of CHARGER_CTRL_REG, the charger's FSM loads a dedicated timer with this value and waits for this timer to expire, before proceeding to the next states.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATE_IRQ_CLR_REG</name>
	<description>Interrupt clear register of Charger FSM IRQs</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>CV_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[11:11]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CV_TO_CC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TBAT_STATUS_UPDATE_IRQ_CLR</name>
	<description>Writing a 1 will reset the Battery temperature status update IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TBAT_PROT_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TDIE_PROT_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EOC_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CV_TO_EOC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_TO_EOC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CC_TO_CV_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PRECHARGE_TO_CC_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DISABLED_TO_PRECHARGE_IRQ_CLR</name>
	<description>Writing a 1 will reset the respective Charger's State IRQ status bit ; writing a 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATE_IRQ_MASK_REG</name>
	<description>Mask register of Charger FSM IRQs</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>CV_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CV_CHARGE to PRE_CHARGE state.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CC_CHARGE to PRE_CHARGE state.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CV_TO_CC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CV_CHARGE to CC_CHARGE state.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_STATUS_UPDATE_IRQ_EN</name>
	<description>When set, this bit-field enables the generation of the Charger's state IRQ as soon as the battery temperature status is refreched by the Charger's Battery temperature monitor (JEITA) FSM. As soon as the specific FSM checks the current battery temperature level, it notifies the main Charger FSM that it has run and that the Battery temperature pack state is checked (and potentially refreshed with a new status).</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_PROT_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the Charger's state IRQ generation as soon as the Charger's FSM switches from the Battery temperature protection state (TBAT_PROT) to PRE_CHARGE, resuming charging.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDIE_PROT_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the Charger's state IRQ generation as soon as the Charger's FSM switches from the Die temperature protection state (TDIE_PROT) to PRE_CHARGE, resuming charging.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EOC_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the Charger's State IRQ generation as soon as the Charger's FSM switches from END_OF_CHARGE again to PRE_CHARGE state. This happens when the Vbat voltage level is detected to be below the Replenish level set.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CV_TO_EOC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CV_CHARGE to END_OF_CHARGE state.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_TO_EOC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CC_CHARGE to END_OF_CHARGE state.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CC_TO_CV_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from CC_CHARGE to CV_CHARGE state.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRECHARGE_TO_CC_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from PRE_CHARGE to CC_CHARGE state..</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DISABLED_TO_PRECHARGE_IRQ_EN</name>
	<description>When set, this bit-field enables the IRQ generation as soon as the Charger's FSM switches from DISABLED to PRE_CHARGE state.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATE_IRQ_STATUS_REG</name>
	<description>Status register of Charger FSM IRQs</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>CV_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CV_CHARGE to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from CV_CHARGE to PRE_CHARGE state</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CC_CHARGE to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from CC_CHARGE to PRE_CHARGE state</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CV_TO_CC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CV_CHARGE to CC_CHARGE state has been captured
1 = Charger's FSM has switched from CV_CHARGE to CC_CHARGE state</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_STATUS_UPDATE_IRQ</name>
	<description>0 = No battery temperature status update event has been captured
1 = Battery temperature pack's status has been checked and refreshed by the Charger's Battery temperature monitor FSM. Thus, the new status of the battery temperature should be checked by SW.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_PROT_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from TBAT_PROT to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from TBAT_PROT to PRE_CHARGE state, resuming charging after having recovered from a battery temperature error.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_PROT_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from TDIE_PROT to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from TDIE_PROT to PRE_CHARGE state, resuming charging after having recovered from a Die temperature error.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EOC_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from END_OF_CHARGE to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from END_OF_CHARGE to PRE_CHARGE state</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CV_TO_EOC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CV_CHARGE to END_OF_CHARGE state has been captured
1 = Charger's FSM has switched from CV_CHARGE to END_OF_CHARGE state</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_TO_EOC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CC_CHARGE to END_OF_CHARGE state has been captured
1 = Charger's FSM has switched from CC_CHARGE to END_OF_CHARGE state</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CC_TO_CV_IRQ</name>
	<description>0 = No transition of the Charger's FSM from CC_CHARGE to CV_CHARGE state has been captured
1 = Charger's FSM has switched from CC_CHARGE to CV_CHARGE state</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PRECHARGE_TO_CC_IRQ</name>
	<description>0 = No transition of the Charger's FSM from PRE_CHARGE to CC_CHARGE state has been captured
1 = Charger's FSM has switched from PRE_CHARGE to CC_CHARGE state</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DISABLED_TO_PRECHARGE_IRQ</name>
	<description>0 = No transition of the Charger's FSM from DISABLED to PRE_CHARGE state has been captured
1 = Charger's FSM has switched from DISABLED to PRE_CHARGE state</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_STATUS_REG</name>
	<description>Charger main status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>OVP_EVENTS_DEBOUNCE_CNT</name>
	<description>The specific bit-field returns the consecutive number of times Vbat has exceeded the programmed Over-Voltage Protection (OVP) level. It is used to determine when the Charger's FSM will exit any of the charging states (PRE/CC/CV_CHARGE) and will switch to the ERROR state due to an OVP error. This will happen as soon as the respective counter of OVP events reaches or exceeds a fixed number (4), similar to the approach adopted in the End-of-Charge and Die Temperature debouncing mechanisms.
The specific counter increases only while the Charger's FSM is in any of the three charging,states, the Vbat OVP interval check timer has reached the threshold set and when Vbat OVP comparator's output is asserted.
Note 1 : By default, as soon as the counter reaches 4, the FSM will switch to the ERROR state and the counter will reset again. Thus, in that case the specific counter ranges from 0 to 4 and vice-versa. However, if the monitoring of Vbat OVP comparator's state is less frequent than 5 (4+1) times the CHARGER_OVP_COMP_TIMER_REG[OVP_INTERVAL_CHECK_THRES] and Vbat has exceeded the OVP voltage level based on the comparator's output signal, then this counter will exceed 4 and may overflow.
This will not harm, however, the detection of the OVP event, as it only increases the number of OVP event occurrences by the debounce timer, until the OVP comparator timer's settling time has expired. Thus, the Charger FSM will again switch to ERROR when the counter has reached or exceeded 4 (bit [2] of OVP_EVENTS_DEBOUNCE_CNT is set) and the OVP comparator's timer has expired.
Note 2: See also the OVP_INTERVAL_CHECK_TIMER, OVP_INTERVAL_CHECK_THRES of CHARGER_OVP_COMP_TIMER_REG, for the debouncing mechanism of the Vbat OVP comparator's output.</description>
	<bitRange>[28:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EOC_EVENTS_DEBOUNCE_CNT</name>
	<description>The specific bit-field returns the number of times the End-of-Charge signal has been consecutively found to be high. It is used to determine when the Charger's FSM will switch from CV_CHARGE to END_OF_CHARGE state, implementing a debounce mechanism on End-of-Charge signal, coming from the analogue circuitry of the Charger towards the FSM.
The specific counter, running with the Charger's 1Mhz clock:
  - Increases after detecting that the End-of-Charge signal is high when the respective interval for the End-of-Charge check expires. This actually happens after having detected either a positive edge on the End-of-Charge signal or after having seen the signal's level to be high (see also CHARGER_CTRL_REG[EOC_TRIGGER]) , since only after that is it possible for the interval timer to start ticking.
  - Resets to zero when End-of-Charge is seen low when the interval timer has expired or when an End-of-Charge negative edge is seen before the timer's expiration, starting-over.
  - Does not count if End-of-Charge signal is seen high and either the CV_MODE signal (also driven by the analogue circutry) or the End-of-Charge signal of the previous clock cycle is seen low.
  - Is reset when the Charger's FSM is not in either the CC_CHARGE or the CV_CHARGE state or after having reached &quot;100&quot;(4). This is the threshold after which the End-of-Charge signal is considered stable by the Charger's FSM, to switch to the END_OF_CHARGE state. Thus, in practice, the specific counter (and bit-field) ranges between 0 and 4.
Note: See also the EOC_INTERVAL_CHECK_TIMER/THRES bit-fields of CHARGER_CTRL_REG.</description>
	<bitRange>[25:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_ERROR_DEBOUNCE_CNT</name>
	<description>The specific bit-field returns the consecutive number of times the Die temperature is seen either above (for the case of an error) or below (for the case of recovering from an error) the set Die temperature level.This is performed by a counter, which is increased:
- Each time the Die temperature comparator shows that Die temperature exceeds the set level, and while charging is active, provided that Die temperature protection is enabled. If, however, the CHARGER_CTRL_REG.TDIE_PROT_ENABLE bit-field is not set, the counter is reset and stays frozen to zero.
- Each time the Die temperature comparator shows that Die temperature is again below the set level, and while the FSM is in the Die temperature protection error state (TDIE_PROT) and the TDIE_ERROR_RESUME bit-field of CHARGER_CTRL_REG is set. If the specific bit-field is not set, the debounce counter is reset to 0 and it is kept frozen until the FSM is again enabled to resume from Die temperature errors.
If the Die temperature comparator of the Charger's analogue circuitry shows that temperature has exceeded the programmed level for four consecutive times and charging is active, the Charger's FSM considers this as a Die temperature error and moves to the TDIE_PROT state, resetting the timer at the same time and of course halting charging.
To recover from this state and resume charging, the FSM needs to see that Die temperature is below the programmed level for four consecutive times, again, provided that the TDIE_ERROR_RESUME bit-field of CHARGER_CTRL_REG is set. As soon as this happens, the error counter is again reset and the Charger's FSM resumes, by moving to PRE_CHARGE state. Consequently, the counter's value always ranges from 0 to 4.
Note: When the Charger's FSM is in BYPASSED state, then this bit-field is reset and kept frozen to zero. Consequently, the number of times Die temperature has exceeded the pre-programmed threshold should be determined by SW.</description>
	<bitRange>[22:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_JEITA_STATE</name>
	<description>Returns the state of the Charger's JEITA FSM. This FSM is used to update the state of the battery temperature pack, depending on the value programmed in CHARGER_CTRL_REG.TBAT_MONITOR_MODE bit-field. The encoding of the states is as follows:
0x0 = CHECK_IDLE
0x1 = CHECK_THOT
0x2 = CHECK_TCOLD
0x3 = CHECK_TWARMER
0x4 = CHECK_TWARM
0x5 = CHECK_TCOOLER
0x6 = CHECK_TCOOL
0x7 = CHECK_TNORMAL
0x8 = UPDATE_TBAT
The FSM initially is in CHECK_IDLE state and starts checking the battery's temperature by visiting the states that check for the respective temperature area (Hot, Cold, Warmer, Warm, Cooler, Cool, Normal), in this order.
If the battery temperature is found to be in one of the aforementioned zones, it directly moves to UPDATE_TBAT state, to update the battery temperature's state and notify the main FSM of the Charger about the battery temperature status, before returning to the CHECK_IDLE state. A Charger State IRQ will also be generated upon refreshing the battery temperature status (see also the description of CHARGER_STATE_IRQ_MASK_REG register).
Note: It is also noted that if the battery temperature is not found to be in any of the Hot, Cold, Warmer, Warm, Cooler or Cool zones, the FSM concludes that it is in the Normal zone, so between Warm and Cool. Consequently, the state CHECK_TNORMAL lasts only one (1MHz) clock cycle and is used to properly update the Battery temperature status (TBAT_STATUS) accordingly, before the last state (UPDATE_TBAT) is visited.</description>
	<bitRange>[19:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_STATE</name>
	<description>Indicating the state of the Charger's main FSM, based on the following encoding:
0x0 = POWER_UP (Charger's power-up not yet set)
0x1 = INIT (Charger is being power-up, FSM waiting for the analogue to settle)
0x2 = DISABLED (Charger powered-up but charging not yet started)
0x3 = PRE_CHARGE (Pre-Charge state)
0x4 = CC_CHARGE (Constant Current state)
0x5 = CV_CHARGE (Constant Voltage state)
0x6 = END_OF_CHARGE (End-of-Charge state)
0x7 = TDIE_PROT (Die temperature protection state, visited when Die temperature limit is exceeded)
0x8 = TBAT_PROT (Battery temperature protection state, visited when Battery temperature is either COLD or HOT)
0x9 = BYPASSED (Bypassed state, visited only when the FSM is bypassed and SW takes over control)
0xA = ERROR (Error state, visited when a charge time-out occurs or in the case of Vbat exceeding over-voltage level)</description>
	<bitRange>[15:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_STATUS</name>
	<description>Battery pack temperature status, according to the following encoding:
0x0 : Battery temperature in COLD zone (default)
0x1 : Battery temperature in COOLER zone (above COLD)
0x2 : Battery temperature in COOL zone (above COOLER)
0x3 : Battery temperature in NORMAL zone (above COOL and below WARM zones)
0x4 : Battery temperature in WARM zone (above NORMAL)
0x5 : Battery temperature in WARMER zone (above WARM and below HOT)
0x6 : Battery temperature in HOT zone
It is noted that, according to the JEITA standard (supported if the JEITA_SUPPORT_DISABLED bit-field of CHARGER_CTRL_REG is not set), if the battery pack temperature is in the &quot;HOT&quot; zone, charging will always be stopped. The same will happen also for the case of the COLD zone, unless the &quot;NTC_LOW_DISABLE&quot; bit-field of CHARGER_CTRL_REG is set. In that case, charging will be continued.</description>
	<bitRange>[11:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAIN_TBAT_COMP_OUT</name>
	<description>Returns the status of the main battery temperature comparator. This comparator by default checks if the battery temperature is in the Cold zone. However, if JEITA support is enabled and battery temperature is found to not be in either the Hot or the Cold zone, the same comparator is used to check for the Warm and Cool zones, as JEITA suggests.
The specific bit-field is suggested to be used in bypass mode and when the JEITA support is disabled (so when the battery temperature is checked agains the Hot and the Cold zones). In that case, the comparator checks the battery temperature agains the Cold level and its status can be as follows:
0 = Battery temperature pack is found to be below the Cold level, so in the non-allowed Cold temperature zone. Thus, charging will be disabled, provided that the NTC_LOW_DISABLE bit-field of CHARGER_CTRL_REG is not set.
1 = Battery temperature pack is found to be above the non-allowed Cold temperature zone. Thus, charging will be continued, provided that battery temperature will not be in the Hot zone as well.
When the Charger's main FSM is active and JEITA is enabled, the Charger's digital block takes over and controls the respective comparator's output.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_HOT_COMP_OUT</name>
	<description>Returns the status of the battery temperature comparator dedicated to the Hot temperature zone.
0 = Battery temperature pack is found to be below the Hot zone
1 = Battery temperature pack is found to be in the non-allowed Hot temperature zone. Thus, charging will be disabled, provided that battery temperature protection is enabled.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_COMP_OUT</name>
	<description>0 = Die temperature is found to be below the programmed level, set in CHARGER_TEMPSET_PARAM_REG.TDIE_SET level (normal operation)
1 = Die temperature is found to be above the set level.
Charging will be disabled if Die temperature protection is enabled and the Die temperature is found to be above the set level four consecutive times (see also TDIE_ERROR_DEBOUNCE_CNT bit-field). In that case, the Charger's FSM will also move the respective error state (TDIE_PROT) and an IRQ may be generated, if the respective mask bit of CHARGER_ERROR_IRQ_MASK_REG is set.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_OVP_COMP_OUT</name>
	<description>0 = Vbat has not exceeded the Over-Voltage Protection (OVP) voltage limit, according to the respective analogue comparator's output.
1 = Vbat is found to have exceeded the OVP voltage setting, thus charging should be disabled.
The OVP voltage settings are defined in CHARGER_VOLTAGE_PARAM_REG.V_OVP (for the Normal battery temperature zone), as well as in CHARGER_JEITA_V_OVP_REG (for Cool and Warm temperature zones, to comply with JEITA). </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAIN_VBAT_COMP_OUT</name>
	<description>This bit-field reflects the status of the main Vbat comparator residing in the analogue circuitry of the Charger.
This comparator is used to check Vbat against either the Pre-Charge or the Replenish voltage level, depending on what is driven by the Charger's digital block.
Thus, when the FSM is active, the comparator gets as reference the Replenish setting as soon as the FSM has reached the END_OF_CHARGE state. Otherwise,the Pre-Charge voltage setting is driven, including the Bypass mode.
According to the above, the encoding is as follows for the case the comparator compares Vbat against the Pre-Charge level:
0 = Vbat has not exceeded the set Pre-Charge voltage level.
1 = Vbat has reached or exceeded the set Pre-Charge voltage level.
For the case the comparator compares agains the Replenish level (when the FSM has reached the END_OF_CHARGE state, so when the charging has been completed), the encoding is as follows:
0 = Vbat has dropped below the set Replenish level, so charging will re-start and the FSM will move to the PRE_CHARGE state.
1 = Vbat is still greater or equal to the set Replenish level, thus charging remains in hold and the FSM in END_OF_CHARGE state.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>END_OF_CHARGE</name>
	<description>0 = Actual charge current is above the current level programmed in I_END_OF_CHARGE field of CHARGER_CURRENT_PARAM_REG (or charger is off)
1 = Actual charge current is below the current level programmed in I_END_OF_CHARGE bit-field of CHARGER_CURRENT_PARAM_REG.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_CV_MODE</name>
	<description>0 = Charger's voltage loop not in regulation (or Charger is off)
1 = Charger's Constant Voltage (CV) mode active, voltage loop in regulation</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_CC_MODE</name>
	<description>0 = Charger's Current loop not in regulation (or Charger is off)
1 = Charger's Constant Current (CC) mode active, current loop in regulation</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHARGER_IS_POWERED_UP</name>
	<description>0 = Charger is either off or it is being powered-on but the analogue ciruitry is not yet settled. The charger's main FSM is either in POWER_UP or INIT states.
1 = Charger is powered-up, so its analogue ciruitry should now be settled. The Charger's FSM has left both power-up states (POWER_UP, INIT), so charging can start.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_SWLOCK_REG</name>
	<description>Charger SW lock register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>SWLOCK_FSM_STATE</name>
	<description>Returns the state of the FSM detecting the sequence of writes that either enable (lock) or disable (un-lock) the protection to the Charger registers/register bit-fields, protected also through CHARGER_LOCK_REG (bits [14:0]). The supported states are:
  - WORD0 : First write expected, either when the SW protection is active (SWLOCK_STATUS = '1') or inactive ('0').
  - WORD1 : Second write expected. If the data written is the proper one, the FSM continues to WORD2 state, otherwise it starts over from state WORD0.
  - WORD2 : Third and last write expected. In this state, the FSM expects the proper write to toggle the SWLOCK_STATUS bit and switches from lock (default) to un-lock state and vice-versa. From WORD2, the FSM always switches to WORD0.
The lock and un-lock data sequences that must be written to this register are provided right below, for the sake of completeness.
  - LOCK sequence: 0x3768, 0x8673, 0xDEAD
  - UNLOCK sequence: 0x756E (&quot;un&quot;), 0x6C6F (&quot;lo&quot;), 0x636B (&quot;ck&quot;)
It is noted that locking is effective only if bit [15] of CHARGER_LOCK_REG is set to '1'. Otherwise, even if the sequence of data written by SW is the proper one, the locking through this mechanism will not be achieved and the registers will be protected or not depending on the state of the respective bits ([14:0]) of CHARGER_LOCK_REG.</description>
	<bitRange>[2:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SWLOCK_STATUS</name>
	<description>0 = SW locking is not active, writes to the protected Charger registers are allowed depending on CHARGER_LOCK_REG (bits [14:0])
1 = SW locking will be activated as soon as the (set-only) bit [15] of CHARGER_LOCK_REG is set. In that case, writes are not allowed to all the protected* Charger registers and register bit-fields, regardless of the bits [14:0] of CHARGER_LOCK_REG.
The specific bit becomes '1' only if the SW locking sequence of writes to this register is applied (see also SWLOCK_FSM_STATE bit-field for the lock/un-lock sequences). It can be unset only if the SW un-lock write sequence is applied.
*Note: The protected Charger registers covered by the SW lock/un-lock mechanism are the ones protected also by the bits [14:0] of CHARGER_LOCK_REG, and which are mentioned in the register descriptions of the respective bit-fields.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_TBAT_COMP_TIMER_REG</name>
	<description>Battery temperature (main) comparator timer register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>TBAT_COMP_TIMER</name>
	<description>Returns the main battery temperature comparator's timer, used for the latching of the comparator's output. The output of the comparator is used by the JEITA FSM, to determine the current battery temperature pack's status.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_COMP_SETTLING</name>
	<description>Settling time (specified in us) for the main battery temperature comparator, checking for the &quot;COOL&quot;, &quot;COLD&quot; and &quot;WARM&quot; levels. The charger's digital block uses a dedicated timer to sample the specific comparator's output. The comparator's output is latched as soon as the timer expires, reaching 0. Then, the timer is reloaded with the settling time value and starts-over, down-counting to 0.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TBAT_MON_TIMER_REG</name>
	<description>Battery temperature monitor interval timer register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>TBAT_MON_TIMER</name>
	<description>This is the battery temperature monitoring timer, counting with the Charger's 1KHz clock. If the battery monitor mode is accordingly set in the TBAT_MONITOR_MODE bit-field of CHARGER_CTRL_REG (so either to 0x1 or 0x2), this timer is initially loaded with the value set in TBAT_MON_INTERVAL bit-field in the subsequent 1khz cycles starts down-counting to 0. As soon as the specific timer expires,the JEITA FSM starts-over again, to refresh the battery temperature status.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TBAT_MON_INTERVAL</name>
	<description>Timing interval (in ms) for the Battery temperature monitoring. This interval determines how often the JEITA FSM will be checking and potentially refreshing the Battery temperature status, by selecting accordingly the proper level (Hot, Cold, Warm, Cool or Normal), based on the feedback of the two battery temperature comparators being present in the Charger's analogue circuitry (one for the Hot level and one for Cold, Cool and Warm, to support JEITA).
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TDIE_COMP_TIMER_REG</name>
	<description>Die temperature comparator timer register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>TDIE_COMP_TIMER</name>
	<description>Returns the current value of the timer used to determine when the Die temperature comparator's output must be sampled by the digital. As soon as the timer expires (down-counting to 0, starting from TDIE_COMP_SETTLING) the comparator's output is latched by the Charger's digital block and used by the main FSM. After expiring, the timer starts-over again, down-counting, to enable the continuous monitoring of Die temperature by the digital.
Note: When the Charger's FSM is in BYPASSED state, this timer is kept to zero and the SW takes over, sampling the status of the TDIE_PROT_COMP_OUT bit-field of CHARGER_STATUS_REG to determine if the Die temperature limit has been exceeded.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDIE_COMP_SETTLING</name>
	<description>Settling time threshold (in us) for the Die temperature comparator. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TEMPSET2_PARAM_REG</name>
	<description>Charger battery temperature settings register (Cooler, Warmer).</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00dde654</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>TBAT_WARMER</name>
	<description>This bit-field determines the battery temperature threshold above which the &quot;WARMER&quot; zone is defined (between WARM and HOT). Regarding the temperatures supported, the range is between minus 10C and 53C, as already defined in the TBAT_COLD bit-field of CHARGER_TEMPSET_PARAM_REG.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_WARM</name>
	<description>This bit-field determines the battery temperature above which the charge current is reduced, defining the &quot;Warm&quot; temperature zone. It ranges from minus 10C to 53C. The range is the same with the one defined in detail in TBAT_COLD bit-field.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_COOL</name>
	<description>This bit-field determines the battery temperature below which the charge current is reduced, defining the &quot;Cool&quot; temperature zone. It ranges from minus 10C to 53C and the range is the same with the one defined in TBAT_COLD bit-field.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_COOLER</name>
	<description>This bit-field determines the battery temperature below which the charge current is reduced, defining the &quot;COOLER&quot; temperature zone (between COLD and COOL). Regarding the temperatures supported, the range is between minus 10C and 53C, as already defined in the TBAT_COLD bit-field of CHARGER_TEMPSET_PARAM_REG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TEMPSET_PARAM_REG</name>
	<description>Charger battery temperature settings register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00003fca</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>TDIE_MAX</name>
	<description>This bit-field determines the maximum Die temperature level limit, ranging from 0C to 130C, according to the following encoding:
000: 0 C (mainly for test purposes)
001: 50 C
010: 80 C
011: 90 C
100: 100 C
101: 110 C
110: 120 C
111: 130 C</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_HOT</name>
	<description>This bit-field determines the battery temperature above which the charge current is zero, defining the &quot;Hot&quot; battery temperature zone. It ranges from minus 10C to 53C. The range is the same with the one defined in detail in TBAT_COLD bit-field.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TBAT_COLD</name>
	<description>This bit-field determines the battery temperature below which the charge current is zero, defining the &quot;Cold&quot; temperature zone. The range of covered temperatures is provided in the following list, which also includes the &quot;Comparator Ladder Reference&quot; ratio (defined in Section 3.11.2.3 of &quot;Lithium_Dialog_Design_Documentation&quot; document).
0   :  -10C/0.741
1   :   -9C/0.733
2   :   -8C/0.724
3   :   -7C/0.715
4   :   -6C/0.706
5   :   -5C/0.695
6   :   -4C/0.686
7   :   -3C/0.677
8   :   -2C/0.668
9   :   -1C/0.657
10 :    0C/0.647
11 :    1C/0.638
12 :    2C/0.628
13 :    3C/0.618
14 :    4C/0.608
15 :    5C/0.596
16 :    6C/0.587
17 :    7C/0.578
18 :    8C/0.567
19 :    9C/0.557 
20 :   10C/0.546
21 :   11C/0.536
22 :   12C/0.527
23 :   13C/0.517
24 :   14C/0.506
25 :   15C/0.495
26 :   16C/0.486
27 :   17C/0.477
28 :   18C/0.467
29 :   19C/0.457
30 :   20C/0.446
31 :   21C/0.438
32 :   22C/0.429
33 :   23C/0.419
34 :   24C/0.410
35 :   25C/0.400
36 :   26C/0.392
37 :   27C/0.383
38 :   28C/0.375
39 :   29C/0.366
40 :   30C/0.356
41 :   31C/0.349
42 :   32C/0.341
43 :   33C/0.333
44 :   34C/0.325
45 :   35C/0.316
46 :   36C/0.309
47 :   37C/0.302
48 :   38C/0.295
49 :   39C/0.287
50 :   40C/0.280
51 :   41C/0.273
52 :   42C/0.267
53 :   43C/0.260
54 :   44C/0.253
55 :   45C/0.247
56 :   46C/0.241
57 :   47C/0.235
58 :   48C/0.229
59 :   49C/0.223
60 :   50C/0.217
61 :   51C/0.212
62 :   52C/0.207
63 :   53C/0.202</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_THOT_COMP_TIMER_REG</name>
	<description>Battery temperature comparator timer register for &quot;Hot&quot; zone</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>THOT_COMP_TIMER</name>
	<description>Returns the battery temperature comparator's timer dedicated for the &quot;Hot&quot; level.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>THOT_COMP_SETTLING</name>
	<description>Charger's battery temperature comparator settling time (specified in us), specifically for the Hot temperature zone. The charger's digital block uses a dedicated timer to sample the specific comparator's output. The comparator's output is latched as soon as the timer expires, reaching 0. Then, the timer is reloaded with the settling time value and starts-over again
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_TOTAL_CHARGE_TIMER_REG</name>
	<description>Maximum total charge time limit register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00003f48</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TOTAL_CHARGE_TIMER</name>
	<description>Returns the current value of the overall charge timeout counter, running at a 1Hz clock. This timer has been set to 16 bits, so that it can count up to 10.5 hours, and ranges from 0 to MAX_TOTAL_CHARGE_TIME. It is reset to 0 when the Charger's FSM is either in DISABLED or in END_OF_CHARGE state.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_TOTAL_CHARGE_TIME</name>
	<description>This bit-field determines the maximum overall charging time allowed (measured in ticks of the 1Hz clock). If this is exceeded, a total charge time-out error will be captured by the Charger's controller and its FSM will move to the ERROR state. An IRQ will be also generated if the respective IRQ mask bit of CHARGER_ERROR_IRQ_MASK_REG is already set. In order to to exit this state, the &quot;CHARGER_RESUME&quot; bit-field of CHARGER_CTRL_REG must be set, to enable the Charger's FSM switch from ERROR to DISABLED state and start-over.
Note: The specific bit-field should be always set to a non-zero value.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_VBAT_COMP_TIMER_REG</name>
	<description>Main Vbat comparator timer register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000063</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>VBAT_COMP_TIMER</name>
	<description>Returns the current value of the timer used to determine when the output of the Vbat comparator (checking Vbat vs Pre_Charge and Replenish levels) must be sampled by the digital. As soon as the timer expires (down-counting to 0, starting from the value set in VBAT_COMP_SETTLING), the comparator's output is latched by the Charger's digital block and used by the FSM.
Note: When the Charger's FSM is in BYPASSED state, this timer is kept to zero and the SW takes over. In this mode, the specific comparator checks the level of Vbat against the Pre-Charge level. Hence, SW can periodically sample the status of this comparator by reading the MAIN_VBAT_COMP_OUT bit-field of CHARGER_STATUS_REG, to determine if Vbat has exceeded the Pre-Charge level or not.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_COMP_SETTLING</name>
	<description>Settling time threshold (in us) for the Vbat comparator checking Vbat vs the programmed Pre-Charge and Replenish levels. The settings (voltage levels) of the comparator are controlled by the digital block of the Charger and they are driven based on the state of the main FSM (PRE_CHARGE, END_OF_CHARGE).</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_VOLTAGE_PARAM_REG</name>
	<description>Charger voltage settings register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00ca122b</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>V_OVP</name>
	<description>This bit-field determines the VBAT Over-voltage protection limit. This Over-voltage protection level is used by the Charger's analogue circuitry and specifically by a dedicated comparator, the output of which is sampled by the digital block of the Charger. As soon as VBAT is detected to have reached or exceeded this level, the Charger's FSM moves to ERROR state, interrupting charging. If the respective Error IRQ mask bit is set, an Error IRQ pulse will be also generated.
Regarding the actual range of supported values for this bit-field, see the the description of V_CHARGE bit-field of this register.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_REPLENISH</name>
	<description>This bit-field determines the absolute value (in V) of the Replenish voltage threshold. As soon as charging has been completed and the Charger's FSM has reached the END_OF_CHARGE state, the respective analogue comparator of the Charger compares VBAT with the Replenish level. If VBAT is found to have dropped below this level, charging should start-over again and in that case, the FSM moves again to the PRE_CHARGE state.
Regarding the supported Replenish voltage levels, see the description of V_CHARGE bit-field.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_PRECHARGE</name>
	<description>This bit-field determines the voltage level at which the battery is considered as Pre-charged and therefore the Charger's FSM should move to the CC_CHARGE state, entering the Constant Current charging phase.
Regarding the supported Pre-Charge voltage levels, see also the description of V_CHARGE bit-field of this register.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V_CHARGE</name>
	<description>This bit-field determines the charge voltage levels supported. The supported levels are determined according to the following encoding:
0   : 2.80V
1   : 2.85V
2   : 2.90V
3   : 2.95V
4   : 3.00V
5   : 3.05V
6   : 3.10V
7   : 3.15V
8   : 3.20V
9   : 3.25V
10 : 3.30V
11 : 3.35V
12 : 3.40V
13 : 3.45V
14 : 3.50V
15 : 3.55V
16 : 3.60V
17 : 3.65V
18 : 3.70V
19 : 3.75V
20 : 3.80V
21 : 3.82V
22 : 3.84V
23 : 3.86V
24 : 3.88V
25 : 3.90V
26 : 3.92V
27 : 3.94V
28 : 3.96V
29 : 3.98V
30 : 4.00V
31 : 4.02V
32 : 4.04V
33 : 4.06V
34 : 4.08V
35 : 4.10V
36 : 4.12V
37 : 4.14V
38 : 4.16V
39 : 4.18V
40 : 4.20V
41 : 4.22V
42 : 4.24V
43 : 4.26V
44 : 4.28V
45 : 4.30V
46 : 4.32V
47 : 4.34V
48 : 4.36V
49 : 4.38V
50 : 4.40V
51 : 4.42V
52 : 4.44V
53 : 4.46V
54 : 4.48V
55 : 4.50V
56 : 4.52V
57 : 4.54V
58 : 4.56V
59 : 4.58V
60 : 4.60V
61 : 4.70V
62 : 4.80V
63 : 4.90V*
It has to be noted that the specific values correspond to the normal battery temperature zone. However, the specific register field may be updated by the JEITA FSM (which checks the battery temperature either once or periodically), in order to adapt the charge voltage to the battery temperature zone (see also CHARGER_CTRL_REG.TBAT_MONITOR_MODE field as well). This is valid also for the other three fields of the current register. Consequently, in that case the register returns the Charge voltage settings that abide to the JEITA requirements for the battery (either COOL, WARM or NORMAL).
Note: Option &quot;63&quot; (4.90V) is not supported for V_CHARGE, V_PRECHARGE and V_REPLENISH bit-fields (and respective levels). It should be used only in the V_OVP bit-field, as the (maximum) Over-voltage protection level.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHARGER_VOLTAGE_STATUS_REG</name>
	<description>Charger voltage status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d9f1e8</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>V_OVP_SET</name>
	<description>This bit-field returns the applied V_OVP setting. In JEITA charging, it contains the value corresponding to the present battery temperature zone, according to JEITA_V_OVP_REG. If JEITA charging is disabled, it reflects the V_OVP bit-field of CHARGER_VOLTAGE_PARAM_REG.
The specific bit-field is updated by the battery monitoring (JEITA) FSM, as soon as the latter starts running. Until then, it reflects the corresponding bit-field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[23:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>V_REPLENISH_SET</name>
	<description>This bit-field returns the applied V_REPLENISH setting. In JEITA charging, it contains the value corresponding to the present battery temperature zone, according to JEITA_V_REPLENISH_REG. If JEITA charging is disabled, it reflects the V_REPLENISH bit-field of CHARGER_VOLTAGE_PARAM_REG.
The specific bit-field is updated by the battery monitoring (JEITA) FSM, as soon as the latter starts running. Until then, it reflects the corresponding bit-field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[17:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>V_PRECHARGE_SET</name>
	<description>This bit-field returns the applied V_PRECHARGE setting. In JEITA charging, it contains the value corresponding to the present battery temperature zone, according to JEITA_V_PRECHARGE_REG. If JEITA charging is disabled, it reflects the V_PRECHARGE bit-field of CHARGER_VOLTAGE_PARAM_REG.
The specific bit-field is updated by the battery monitoring (JEITA) FSM, as soon as the latter starts running. Until then, it reflects the corresponding bit-field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[11:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>V_CHARGE_SET</name>
	<description>This bit-field returns the applied V_CHARGE setting. In JEITA charging, it contains the value corresponding to the present battery temperature zone, according to JEITA_V_CHARGE_REG. If JEITA charging is disabled, it reflects the V_CHARGE bit-field of CHARGER_VOLTAGE_PARAM_REG.
The specific bit-field is updated by the battery monitoring (JEITA) FSM, as soon as the latter starts running. Until then, it reflects corresponding the bit-field of CHARGER_VOLTAGE_PARAM_REG.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHARGER_VOVP_COMP_TIMER_REG</name>
	<description>Vbat OVP comparator timer register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000fc63</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OVP_INTERVAL_CHECK_TIMER</name>
	<description>The specific bit-field determines the current state of the timer used to periodically check the output of the Over-Voltage Protection comparator's output signal, as soon as the Charger's FSM reaches any of the charging states (PRE/CC/CV_CHARGE).
When this happens, the timer starts ticking with the 1Mhz clock, ranging from 0 up to the programmed interval threshold (see also OVP_INTERVAL_CHECK_THRES field). As soon as this timer reaches the programmed threshold value, the Vbat OVP comparator's output is evaluated, increasing or not the counter keeping the consecutive OVP events. It is noted that out of the charging states, the specific timer is kept frozen to zero, not counting.
Note : See also the OVP_OCCURRENCES_CNT bit-field of CHARGER_STATUS_REG for the consecutive OVP events counter.</description>
	<bitRange>[31:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_OVP_COMP_TIMER</name>
	<description>Returns the current value of the timer used to determine when the Vbat Over-Voltage protection (OVP) comparator's output must be sampled by the digital. As soon as the timer expires (down-counting to 0, starting from VBAT_OVP_COMP_SETTLING), the comparator's output is latched by the Charger's digital block and used by the main FSM.
Note: When the Charger's FSM is in BYPASSED state, this timer is kept to zero and the SW takes over, sampling the status of the VBAT_OVP_COMP_OUT bit-field of CHARGER_STATUS_REG to determine if the Vbat has exceeded the OVP limit.</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OVP_INTERVAL_CHECK_THRES</name>
	<description>This bit-field determines the periodic interval of checking the dedicated Vbat OVP comparator's output, when the Charger's FSM is in any of the charging states (PRE/CC/CV_CHARGE). The implementation is based on a dedicated timer, counting from zero up to the value programmed into this bit-field (see also OVP_INTERVAL_CHECK_TIMER field's description) and only when the FSM is in any of the three charging states. Out of these states, the timer is kept frozen to zero.
As soon as this timer reaches the programmed threshold, the Vbat OVP comparator's output is sampled and depending on its level, (high or low), another counter, keeping the number of consecutive OVP events, is increased or not. The programmed threshold value should always be non-zero.
Note: See also the OVP_DEBOUNCE_CNT bit-field of CHARGER_STATUS_REG, for the consecutive OVP events counter.</description>
	<bitRange>[15:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBAT_OVP_COMP_SETTLING</name>
	<description>Settling time threshold (in us) for the Vbat comparator checking Vbat vs the programmed Over-Voltage level.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHG_DET</name>
	<version>1.0</version>
	<description>CHG_DET registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>40</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CHG_DET_ADC_CTRL_REG</name>
	<description>Charge detection ADC control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>ADC_V30_SEL</name>
	<description>This bit-field determines the mode to be used when the intention is to measure the USB Dp/Dm levels with the GP_ADC. In specific:
0 = Should be used when the V30 rail is at 3.0V
1 = Should be used when the V30 rail is at 3.3V</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_DM_TO_ADC_EN</name>
	<description>0 = Disables the connection of USBm to the GP_ADC
1 = Enables the connection of USBm to the GP_ADC through a relative test switch</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_DP_TO_ADC_EN</name>
	<description>0 = Disables the connection of USBp to the GP_ADC
1 = Enables the connection of USBp to the GP_ADC through a relative test switch</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHG_DET_DCD_TIMER_REG</name>
	<description>Charge detection DCD time-out timer register (used in the FSM)</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x02580258</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>DCD_TIMER</name>
	<description>This bit-field returns the current value of the DCD time-out timer, also ticking with the 1KHz clock, same as the shared 8-bit timer.
The specific timer counts only in states NODE_ATTACHED, WAIT_FOR_DCD and CHECK_FOR_DCD, since these are the states where Data Contact Detection is evaluated.
The timer is automatically reloaded with the programmed threshold value (DCD_TIMEOUT_THRES) as soon as the FSM returns to its starting state (WAIT_FOR_ATTACH, 0x0).</description>
	<bitRange>[25:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCD_TIMEOUT_THRES</name>
	<description>This bit-field determines the value from which the Data Contact Detection (DCD) time-out timer starts down-counting, until expiring to zero. Non-zero values are recommended.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHG_DET_FSM_CTRL_REG</name>
	<description>Charge detection FSM control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CHG_DET_EN</name>
	<description>0 = Charge detection FSM is disabled, analog part is controlled through the USB_CHARGER_CTRL_REG register's bit-fields.
1 = Charge detection FSM is enabled and controls the analog part, overruling the content of USB_CHARGER_CTRL_REG.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHG_DET_FSM_STATUS_REG</name>
	<description>Charge detection FSM status register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>CHG_DET_STATE</name>
	<description>This bit-field returns the current state of the charge detection block's FSM. The supported states are:
  - 0x0 : WAIT_FOR_ATTACH (starting state)
  - 0x1 : NODE_ATTACHED (USB_DP_VAL first check)
  - 0x2 : WAIT_FOR_DCD (Data Contact Detection - first state)
  - 0x3 : CHECK_FOR_DCD (Data Contact Detection - second state)
  - 0x4 : WAIT_FOR_PCD (Primary Contact Detection - first state)
  - 0x5 : CHECK_FOR_PCD (Primary Contact Detection - second state)
  - 0x6 : WAIT_FOR_SCD (Secondary Contact Detection - first state)
  - 0x7 : CHECK_FOR_SCD (Secondary Contact Detection - second state)
  - 0x8 : CHG_PORT_DETECTED (terminal state, indicating the port detection's completion).
It is noted that:
  - The FSM returns to state WAIT_FOR_ATTACH either when VBUS_AVAILABLE goes to '0', or when it is disabled by the SW.
  - The FSM may return to state WAIT_FOR_ATTACH from any of the other states when VBUS_AVAILABLE goes to '0', implying either a USB detach event or a VBUS voltage drop.
  - The FSM implements a time-out mechanism during the Data Contact Detection phase (NODE_ATTACHED, WAIT_FOR_DCD and CHECK_FOR_DCD states). A dedicated 10-bit timer counts down in any of these states, until USB_DP_VAL is found to be '0' (so we have a contact detected) or until it expires.
  - The time-out timer's expiration means that there is no D+/D- pins contact detected within the required time-out period, as defined through CHG_DET_DCD_TIMER_REG and as required by the spec. Even in this case though, the FSM does not abort, but proceeds normally to the next state, which is the first Primary Detection State, to comply with the Battery Charging specification.</description>
	<bitRange>[12:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>NO_CONTACT_DETECTED</name>
	<description>0 = Contact is sensed on the Dp/Dm (data) pins by the FSM, during the Data Contact Detection (DCD) phase (USB_DP_VAL = 0)
1 = No contact is sensed on the Dp/Dm pins during the DCD phase (USB_DP_VAL = 1)
Note: Even in the case of no contact detected on the Dp/Dm pins, the FSM continues with the port detection procedure, moving to the Primary Contact Detection (PCD) states.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PORT_2P4AMP_DETECTED</name>
	<description>0 = Port detection either not yet finished or finished without detecting a 2.4 Amp charging port
1 = Port detection has finished by detecting a 2.4 Amp charging port</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PORT_2AMP_DETECTED</name>
	<description>0 = Port detection either not yet finished or finished without detecting a 2 Amp charging port
1 = Port detection has finished by detecting a 2 Amp charging port</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PORT_1AMP_DETECTED</name>
	<description>0 = Port detection either not yet finished or finished without detecting a 1 Amp charging port
1 = Port detection has finished by detecting a 1 Amp charging port</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PS2_PROP_PORT_DETECTED</name>
	<description>0 = Port detection either not yet finished or finished without detecting a PS2 or a Proprietary charger port
1 = Port detection has finished by detecting either a PS2 or a Proprietary charger port</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCP_PORT_DETECTED</name>
	<description>0 = Port detection either not yet finished or finished without detecting a DCP port (Dedicated Charging Port)
1 = Port detection has finished by detecting a DCP port</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CDP_PORT_DETECTED</name>
	<description>0 = Port detection either not yet finished or finished without detecting a CDP port (Charging Downstream Port)
1 = Port detection has finished by detecting a CDP port</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDP_PORT_DETECTED</name>
	<description>0 = Port detection either not yet finished or finished without detecting an SDP port (Standard Downstream Port)
1 = Port detection has finished by detecting an SDP port</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DETECTION_COMPLETED</name>
	<description>0 = Port detection not yet finished, FSM still active
1 = Port detection completed, FSM has reached its terminal state (CHG_PORT_DETECTED). The port type is accessible through the relevant bit-fields of this register.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHG_DET_IRQ_CLEAR_REG</name>
	<description>Charge detection IRQ clear register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CHG_DET_IRQ_CLR</name>
	<description>Writing any value to this register clears the charge detection IRQ, reading always returns zero.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CHG_DET_IRQ_MASK_REG</name>
	<description>Charge detection IRQ mask register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CHG_DET_IRQ_EN</name>
	<description>0 = Charge detection block's IRQ generation is disabled, interrupts to Cortex-M33 are masked.
1 = Charge detection block's IRQ generation is enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHG_DET_IRQ_STATUS_REG</name>
	<description>Charge detection IRQ status register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CHG_DET_IRQ</name>
	<description>0 = No new charge detection IRQ has been generated.
1 = A new charge detection IRQ is generated and should be cleared by SW, by writing to CHG_DET_IRQ_CLEAR_REG (interrupt is level-sensitive).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHG_DET_STATUS_REG</name>
	<description>Charge detection status register holding the comparator outputs</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>USB_DM_VAL2</name>
	<description>0: USBp &lt; 2.3V
1: USBp &gt; 2.5V</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DP_VAL2</name>
	<description>0: USBp &lt; 2.3V
1: USBp &gt; 2.5V</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DM_VAL</name>
	<description>0 = USBm &lt; 0.8V
1 = USBm &gt; 1.5V (PS2 or Proprietary Charger)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DP_VAL</name>
	<description>0 = USBp &lt; 0.8V
1 = USBp &gt; 1.5V (PS2 or Proprietary Charger)</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_CHG_DET</name>
	<description>0 = Standard Downstream Port (SDP) or no Dp/Dm contact detected (nothing connected)
1 = Charging Downstream Port (CDP) or Dedicated Charging Port (DCP)</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USB_DCP_DET</name>
	<description>0 = Charging downstream port is detected
1 = Dedicated charger is detected
It is noted that the control bit VDM_SRC_ON must be set to validate this status bit. 
Note: This register shows the actual status.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHG_DET_SW_CTRL_REG</name>
	<description>Charge detection manual (SW-based) mode control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>IDM_SINK_ON</name>
	<description>0 = Disables the Idm_sink to USBm
1 = Enables the Idm_sink to USBm</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IDP_SINK_ON</name>
	<description>0 = Disables the Idp_sink to USBp
1 = Enables the Idp_sink to USBp</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDM_SRC_ON</name>
	<description>0 = Disables the Vdm_src
1 = Enables the Vdm to USBm and also the USB_DCP_DET status bit</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDP_SRC_ON</name>
	<description>0 = Disables the Vdp_src
1 = Enables the Vdp_src and also the USB_CHG_DET status bit</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IDP_SRC_ON</name>
	<description>0 = Disables the Idp_src and the Rdm_dwn
1 = Enables the Idp_src and the Rdm_dwn</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USB_CHARGE_ON</name>
	<description>0 = Disables the charge detection analog circuit
1 = Enables the charge detection analog circuit</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CHG_DET_TIMER_REG</name>
	<description>Charge detection timer register (used in the FSM)</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00320032</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>CHG_DET_TIMER</name>
	<description>This bit-field returns the current value of the charge detection timer, which is used by the FSM and which down-counts with a clock of 1KHz. The specific clock is enabled by setting the CLK_SYS_REG[CLK_CHG_EN] bit-field to '1' and it is the same clock used by the Charger's digital block.
The specific timer is automatically re-loaded with the programmed threshold value (CHG_DET_TIMER_THRES), upon expiring to zero or when the charge detection FSM moves to the state NODE_ATTACHED (0x1).</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CHG_DET_TIMER_THRES</name>
	<description>This bit-field determines the value from which the charge detection timer starts down-counting, until expiring to zero. Non-zero values are recommended.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_AUD</name>
	<version>1.0</version>
	<description>CRG_AUD registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>80</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PCM_DIV_REG</name>
	<description>PCM divider and enables</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>PCM_SRC_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_PCM_EN</name>
	<description>Enable for the internally generated PCM clock
The PCM_DIV must be set before or together with CLK_PCM_EN.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_DIV</name>
	<description>PCM clock divider. Minimum value is 0x2.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM_FDIV_REG</name>
	<description>PCM fractional division register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PCM_FDIV</name>
	<description>These bits define the fractional division part of the PCM clock. The left most '1' defines the denominator, the number of '1' bits define the numerator. E.g.
0x0110 means 2/9, with a distribution of 1.0001.0000
0xfeee means 13/16, with a distribution of 1111.1110.1110.1110
</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDM_DIV_REG</name>
	<description>PDM divider and enables</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PDM_MASTER_MODE</name>
	<description>Master mode selection
0: slave mode
1: master mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_PDM_EN</name>
	<description>Enable for the internally generated PDM clock
The PDM_DIV must be set before or together with CLK_PDM_EN.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PDM_DIV</name>
	<description>PDM clock divider</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC_DIV_REG</name>
	<description>SRC divider and enables</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>CLK_SRC2_EN</name>
	<description>Enable for the internally generated SRC2 clock
The SRC2_DIV must be set before or together with CLK_SRC2_EN.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_SRC_EN</name>
	<description>Enable for the internally generated SRC clock
The SRC_DIV must be set before or together with CLK_SRC_EN.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC2_DIV</name>
	<description>SRC2 clock divider</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_DIV</name>
	<description>SRC clock divider</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_CTRL</name>
	<version>1.0</version>
	<description>CRG_CTRL registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50060000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_PDCTRL_REG</name>
	<description>Clock control settings for PD_CTRL</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>EMMC_INV_TX_CLK</name>
	<description>Inverts the clock in the TX path</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMMC_INV_RX_CLK</name>
	<description>Invert the clock in the RX path, cascaded with INV_TX_CLK</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMMC_ENABLE</name>
	<description>Enables the clock.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMMC_CLK_DIV</name>
	<description>clock divider setting
0x0 : divide by 16
0x1 : divide by 1
0x2 : divide by 2
0x4 : divide by 4
0x8 : divide by 8</description>
	<bitRange>[10:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDIO_INV_TX_CLK</name>
	<description>Inverts the clock in the TX path</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDIO_INV_RX_CLK</name>
	<description>Invert the clock in the RX path, cascaded with INV_TX_CLK</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDIO_ENABLE</name>
	<description>Enables the clock.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDIO_CLK_DIV</name>
	<description>clock divider setting
0x0 : divide by 16
0x1 : divide by 1
0x2 : divide by 2
0x4 : divide by 4
0x8 : divide by 8</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_GPU</name>
	<version>1.0</version>
	<description>CRG_GPU registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x51001000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_GPU_REG</name>
	<description>Control register for clocks in PD_GPU</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>MIPI_D_PHY_EN</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIPI_PHY_EN</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MIPI_DSI_EN</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPU_ENABLE</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_SNC</name>
	<version>1.0</version>
	<description>CRG_SNC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020900</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_SNC_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>I3C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_CLK_SNC_REG</name>
	<description>Peripheral divider register RESET register. Reads back 0x0000</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>I3C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_CLK_SNC_REG</name>
	<description>Peripheral divider register SET register. Reads back 0x0000</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>I3C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[16:16]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[13:13]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[12:12]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[10:10]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[9:9]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[8:8]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_SYS</name>
	<version>1.0</version>
	<description>CRG_SYS registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>20</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BATCHECK_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>BATCHECK_LOAD_ENABLE</name>
	<description>Enable a current load on the battery.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BATCHECK_ILOAD</name>
	<description>Set the current load to (ILOAD+1) mA.</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BATCHECK_TRIM</name>
	<description>Trim the current load with steps of 2.7% from -19.1% to +19.1%.
0: +0.0% , 8: -0%
1: +2.7% , 9: -2.7%
2: +5.5% , 10: -5.5%
3: +8.2% , 11: -8.2%
4: +10.9% , 12: -10.9%
5: +13.6% , 13: -13.6%
6: +16.4% , 14: -16.4%
7: +19.1% , 15: -19.1%</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_SYS_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_CHG_EN</name>
	<description>Enables the clocks for the charger FSM block</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_RESET_REQ</name>
	<description>Generates a SW reset towards the LCD controller.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_DPHYCLK_SEL</name>
	<description>This bitfield selects the clock source for the LCD controller. This bit may not be changed while LCDC is active.
0: source as selected by LCD_SYSCLK_DIV2 bit
1: DPHY byte clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_CLK_SYS_REG</name>
	<description>Peripheral divider RESET register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_CHG_EN</name>
	<description>Enables the clocks for the charger FSM block</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_RESET_REQ</name>
	<description>Generates a SW reset towards the LCD controller.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_DPHYCLK_SEL</name>
	<description>This bitfield selects the clock source for the LCD controller. This bit may not be changed while LCDC is active.
0: source as selected by LCD_SYSCLK_DIV2 bit
1: DPHY byte clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_CLK_SYS_REG</name>
	<description>Peripheral divider SET register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI3_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI3_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_CHG_EN</name>
	<description>Enables the clocks for the charger FSM block</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_RESET_REQ</name>
	<description>Generates a SW reset towards the LCD controller.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_DPHYCLK_SEL</name>
	<description>This bitfield selects the clock source for the LCD controller. This bit may not be changed while LCDC is active.
0: source as selected by LCD_SYSCLK_DIV2 bit
1: DPHY byte clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_TOP</name>
	<version>1.0</version>
	<description>CRG_TOP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>252</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>ANA_STATUS_REG</name>
	<description>Analog Signals Status Register</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x3fffffff</resetMask>
	<fields><field>
	<name>FLAG_LDO_V30_COMBINED_OK</name>
	
	<bitRange>[29:29]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XOR_DOUT_WAKEUP_PADS</name>
	<description>Will be the result of XOR operation of the hibernation wakeup pads outputs combined.
DFT_EN_INPUT_PD_AON_PADS in TEST_CTRL5_REG must be 1.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBUS_AVAILABLE</name>
	<description>High when VBUS &gt; ( VBAT + 150 mV). Hysteresis is approx. 40 mV</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FLAG_ADC_LDO_OK</name>
	<description>When high, ldo_adc is active</description>
	<bitRange>[26:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FLAG_IBIAS_TRIM</name>
	<description>10nA Iref trimming, high when on-chip current is larger than reference current</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VIN_NOK</name>
	<description>General output of the BOD to indicate that one of the monitored inputs is below the trigger-level.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BG_OK</name>
	<description>When high bandgap is active</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_DCDC_VLED_OK</name>
	<description>When high, boost dcdc vled is active</description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_VSYS_HIGH_TEMP</name>
	<description>If 1 indicates that temperature of LDO_VSYS is above operating conditions</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT_VSYS_STATE</name>
	<description>0x0 : Hibernation mode or VBUS-only ( sysbat switch opened).
0x1 : Test mode ( sysbat switch closed).
0x2 : Ideal diode enabled (with VBAT-only or VBUS and VBAT) .
0x3 : Sleep mode (with VBAT-only, sysbat switch closed).</description>
	<bitRange>[20:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_VSYS_HEAD_LIM</name>
	<description>When high, the headroom loop is controlling VSYS </description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_VSYS_CURR_LIM</name>
	<description>When high, the current limiter is controlling VSYS </description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_VSYS_LIM</name>
	<description>When high, the voltage loop is controlling VSYS </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_VSYS_OK</name>
	<description>When high, LDO_VSYS is in regulating mode </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_MIPI_OK</name>
	<description>When high, ldo_mipi is active</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_V30_OK</name>
	<description>When high, ldo_v30 is active</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SWITCH_V18F_OK</name>
	<description>V18F switch completely closed</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUCK_DCDC_V18P_OK</name>
	<description>V18P Rail ok based on DCDC V18P programmed level</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUCK_DCDC_V18_OK</name>
	<description>V18 Rail ok based on DCDC V18 programmed level</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUCK_DCDC_V14_OK</name>
	<description>V14 Rail ok based on DCDC V14 programmed level</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUCK_DCDC_V12_OK</name>
	<description>V12 Rail ok based on DCDC V12 programmed level</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBUS_PLUGIN</name>
	<description>VBUS is connected (VBUS &gt; 2.5V)</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VSYS_NEAR_VLED</name>
	<description>BOOST_VLED_SEL=0x0 : VSYS&gt;4.3
BOOST_VLED_SEL=0x1 : VSYS&gt;4.55
BOOST_VLED_SEL=0x2 : VSYS&gt;4.8
BOOST_VLED_SEL=0x3 : VSYS&gt;4.8</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBUS_ABOVE_VSYS</name>
	<description>VBUS&gt;VSYS+0.05V</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VSYS_OK</name>
	<description>VSYS&gt; 2.45V</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBAT_OK</name>
	<description>VBAT&gt; 2.7V</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COMP_VBUS_OK</name>
	<description>1: VBUS&gt; 4.1V
0: VBUS&lt;3.4V</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>POR_VSYS_OK</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>POR_V30_OK</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BANDGAP_REG</name>
	<description>bandgap trimming</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008020</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EN_BGR_TCCOMP</name>
	<description>Enable Temperature compensation in the reference current
for Charger and LED module.
&quot;1&quot; = enabled ( = default setting)
&quot;0&quot; = Disabled original currents from BGR are used
instead of the Temp-compensated currents</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BANDGAP_ENABLE_CLAMP</name>
	<description>Enables a supply clamp inside the bandgap that improves PSRR. Should be enabled by software after cold boot.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_TRIM</name>
	<description>Trim register for bandgap</description>
	<bitRange>[11:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYSRAM_LPMX</name>
	<description>RAM Transparent Light Sleep (TLS) Core Enable for System RAMs and Cache RAM. Assert low to enable the TLS core feature, which will result in lower leakage current.
In case VDD is below 0.81V, it is necessary to hold this pin high to maintain data retention.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_ITRIM</name>
	<description>Current trimming for bias </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BIAS_VREF_SEL_REG</name>
	
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000bb</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>BIAS_VREF_RF2_SEL</name>
	<description>same coding as BIAS_VREF_RF1_SEL.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BIAS_VREF_RF1_SEL</name>
	<description>Vref_code | Vref_Voltage (mV)
0:900
1:930
2:960
3:990
4:1020
5:1050
6:1080
7:1110
8:1140
9:1170
10:1200
11:1230
12:1260
13:1290
14:1320
15:1350</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_CTRL_REG</name>
	<description>Brown Out Detection control register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0007fc02</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>BOD_VBUS_RST_EN</name>
	<description>If set, generate power-on reset on channel VBUS</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VBAT_RST_EN</name>
	<description>If set, generate power-on reset on channel VBAT.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_MIPI_RST_EN</name>
	<description>If set, generate power-on reset on channel VMIPI</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VSYS_RST_EN</name>
	<description>If set, generate power-on reset on channel VSYS. Bear in mind that there is an additional configurable POR on VSYS rail, check POR_CTRL_REG.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18F_RST_EN</name>
	<description>If set, generate power-on reset on channel V18F</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18P_RST_EN</name>
	<description>If set, generate power-on reset on channel V18P</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18_RST_EN</name>
	<description>If set, generate power-on reset on channel V18</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V14_RST_EN</name>
	<description>If set, generate power-on reset on channel V14</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V12_RST_EN</name>
	<description>If set, generate power-on reset on channel V12</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VBUS_EN</name>
	<description>Enable brown-out detection for channel VBUS</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VBAT_EN</name>
	<description>Enable brown-out detection for channel VBAT.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_MIPI_EN</name>
	<description>Enable brown-out detection for channel VMIPI</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VSYS_EN</name>
	<description>Enable brown-out detection for channel VSYS. Bear in mind that there is an additional configurable POR on VSYS rail, check POR_CTRL_REG.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18F_EN</name>
	<description>Enable brown-out detection for channel V18F</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18P_EN</name>
	<description>Enable brown-out detection for channel V18P</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V18_EN</name>
	<description>Enable brown-out detection for channel V18</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V14_EN</name>
	<description>Enable brown-out detection for channel V14</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_V12_EN</name>
	<description>Enable brown-out detection for channel VDD (V12)</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_STATUS_CLEAR</name>
	<description>Clears BOD_STATUS_REG when this bit is 1 for more than 2us. It must be 0 to register BOD events in BOD_STATUS_REG.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_STATUS_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>BOD_VBUS</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VBAT</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VMIPI</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VSYS</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V18F</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V18P</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V18</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V14</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_V12</name>
	<description>1: below trigger level (BOD event)
0: above trigger level
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CLK_AMBA_REG</name>
	<description>HCLK, PCLK, divider and clock gates</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000052</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields><field>
	<name>OQSPI_PULLUP_ENABLE</name>
	<description>Selects pull value when OQSPIF_D* pads are not output.
0: The pads are pull-down
1: The pads are pull-up (to V18F)</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OQSPI_GPIO_MODE</name>
	<description>If this bit is set, the upper 4 pins of the OQSPIF controller can be used as GPIO, P2_07 to P2_04.
In this mode, the OQSPIF controller should be restricted to QUAD mode or less.
Note: the supply remains V18F, so if the supply is off, the pads become floating.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC2_ENABLE</name>
	<description>Clock enable for QSPI RAM controller </description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC2_DIV</name>
	<description>Clock divider setting.
0b00: divide by 1
0b01: divide by 2
0b10: divide by 4
0b11: divide by 8</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ENABLE</name>
	<description>Clock enable for QSPI FLASH2 controller </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_DIV</name>
	<description>Clock divider setting.
0b00: divide by 1
0b01: divide by 2
0b10: divide by 4
0b11: divide by 8</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OQSPIF_ENABLE</name>
	<description>Clock enable for Octal SPI controller </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OQSPIF_DIV</name>
	<description>Clock divider setting.
0b00: divide by 1
0b01: divide by 2
0b10: divide by 4
0b11: divide by 8</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_ENABLE</name>
	<description>Clock enable for OTP controller </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AES_CLK_ENABLE</name>
	<description>Clock enable for AES crypto block </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SLOW_PCLK_DIV</name>
	<description>Slow-APB interface clock, derived from DIVN_CLK:
0b000: divide divn_clk by 1
0b001: divide divn_clk by 2
0b010: divide divn_clk by 4
0b011: divide divn_clk by 8
0b1xx: divide divn_clk by 16</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCLK_DIV</name>
	<description>Fast-APB interface clock, Cascaded with HCLK:
0b00: divide hclk by 1
0b01: divide hclk by 2
0b10: divide hclk by 4
0b11: divide hclk by 8 </description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HCLK_DIV</name>
	<description>AHB interface and microprocessor clock. Source clock divided by:
0b000: divide clk by 1
0b001: divide clk by 2
0b010: divide clk by 4
0b011: divide clk by 8
0b1xx: divide clk by 16</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_CMAC_SWITCH_REG</name>
	<description>Clock switching register for CMAC clock domain</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>CMAC_RUNNING_ON_XTAL</name>
	<description>This bit is '1' when the CMAC_CLK is enabled, and the switch is set in the XTAL32M position.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMAC_RUNNING_ON_DIVN</name>
	<description>This bit is '1' when the CMAC_CLK is enabled, and the switch is set in the DIVN_CLK position.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMAC_CLK_SEL</name>
	<description>Selects the clock source of the CMAC_CLK.
0: DIVN_CLK is selected
1: XTAL32M is selected.
Note: this bitfield can only be set to '1' when the PD_RAD domain is on (RAD_IS_UP), and will be automatically reset to '0' when the PD_RAD power domain turns off.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_CTRL_REG</name>
	<description>Clock control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00002001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RUNNING_AT_PLL</name>
	<description>Indicates that the PLL clock is used as clock, and may not be switched off </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_XTAL32M</name>
	<description>Indicates that the XTAL32M clock is used as clock, and may not be switched off </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_RCHS</name>
	<description>Indicates that the RCHS clock is used as clock </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_RCLP</name>
	<description>Indicates that the RCLP_CLK is being used as clock </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VAD_CLK_SEL</name>
	<description>Selects the clock for the VAD.
0: Select RCLP clock (normalized for ~32KHz)
1: Select XTAL32K</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LP_CLK_SEL</name>
	<description>Sets the clock source of the LowerPower clock
0x0: RC32K
0x1: RCX
0x2: XTAL32K through the oscillator with an external Crystal.
0x3: XTAL32K through an external square wave generator (set PID of GPIO to FUNC_GPIO)</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CLK_SEL</name>
	<description>Selects the clock source.
0x0 : XTAL32M
0x1 : RCHS
0x2 : The Low Power clock is used
0x3 : The PLL160Mhz is used
Note: switching to/from PLL may only be done from/to XTAL32M.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RADIO_REG</name>
	<description>Radio PLL control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RAD_REG_RESET_REQ</name>
	<description>Reset request for registers of the radio PHY.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCU_ENABLE</name>
	<description>Enable the RF control Unit clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_SYNCH_RESET</name>
	<description>Force synchronous reset to CMAC core and Sleep Timer. Its effective only when both Radio and Timer Power Domains are powered and the clocks are enabled.
CMAC CPU and CMAC registers, including the retained ones, will be reset.
It should be kept in reset for enough time to make sure that it will be captured by CMAC, Low Power and APB clocks.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CLK_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCHS_REG</name>
	<description>Fast RC control register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x001804ae</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>RCHS_SPEED</name>
	<description>Selects speed of RCHS output
0b00: 32MHz, by dividing 96 / 3.
0b01: 96MHz, by dividing 96 /1.
0b1x: 64MHz.
Note: switching to/from 64MHz requires the RCHS to settle, which can be &gt; 100us.
Switching 32 to/from 96MHz does not require settling.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCHS_INIT_RANGE</name>
	<description>Course frequency adjustment</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCHS_INIT_DEL</name>
	<description>Fine frequency adjustment</description>
	<bitRange>[19:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCHS_INIT_DTCF</name>
	<description>Fine duty-cycle adjustment.
0x0: minimum
0x2: default
0x4: maximum
0x5 until 0x7: oscillator does not work</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCHS_INIT_DTC</name>
	<description>Course duty-cycle adjustment.
0x0: minimum
0x5: default
0xA: maximum
0xB until 0xF: oscillator does not work</description>
	<bitRange>[8:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCHS_BIAS</name>
	<description>Bias adjustment</description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCHS_ENABLE</name>
	<description>Enables the HighSpeed RC oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCLP_REG</name>
	<description>32/512 kHz RC oscillator register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RCLP_LOW_SPEED_FORCE</name>
	<description>Forces RCLP in 32kHz mode. If this bit is 0 then RCLP frequency is 512KHz</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCLP_TRIM</name>
	<description>0000 = lowest frequency
0111 = default
1111 = highest frequency </description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCLP_ENABLE</name>
	<description>Enables the 32kHz RC oscillator.
This bit is gated to '0' automatically when sleep state is entered, and PMU_CTRL_REG.ENABLE_CLKLESS is set to '1'.
Do not disable this bit, as deepsleep state is not correctly entered.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCX_REG</name>
	<description>RCX-oscillator control register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000afc</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RCX_BIAS</name>
	<description>LDO bias current.
0x0: minimum
0xF: maximum</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_C0</name>
	<description>Add unit capacitance to RC-time delay.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_CADJUST</name>
	<description>Adjust capacitance part of RC-time delay.
0x00: minimum capacitance
0x1F: maximum capacitance</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_ENABLE</name>
	<description>0: Disable the RCX oscillator (watchdog runs at RCLP)
1: Enable the RCX oscillator (watchdog runs at RCX)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RTCDIV_REG</name>
	<description>Divisor for RTC 100Hz clock</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00051ea8</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>RTC_RESET_REQ</name>
	<description>Reset request for the RTC module</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_ENABLE</name>
	<description>Enable for the 100 Hz generation for the RTC block</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_DENOM</name>
	<description>Selects the denominator for the fractional division:
0b0: 1000
0b1: 1024</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_INT</name>
	<description>Integer divisor part for RTC 100Hz generation</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_FRAC</name>
	<description>Fractional divisor part for RTC 100Hz generation.
if RTC_DIV_DENOM=1, &lt;RTC_DIV_FRAC&gt; out of 1024 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;
If RTC_DIV_DENOM=0, &lt;RTC_DIV_FRAC&gt; out of 1000 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_SNC_CTRL_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>SNC_STATE_RETAINED</name>
	<description>A flag which can be used from FW to indicate that the CPU state has been retained and should be restored during the wakeup sequence (at the beginning of Reset Handler).
This flag is retained during the power-down periods.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_CLK_ENABLE</name>
	<description>Clock-enable for the CM0plus in the SNC.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_RESET_REQ</name>
	<description>Force the SNC microprocessor in reset.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_SWITCH2XTAL_REG</name>
	<description>Switches clock from RC32M to XTAL32M</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>SWITCH2XTAL</name>
	<description>When writing to this register, the clock switch will happen from RC32M to XTAL32M. If any other clock is selected than RC32M, the selection is discarded.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CLK_TMR_REG</name>
	<description>Clock control for the timers</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>TMR2_PWM_AON_MODE</name>
	<description>Maps Timer2_pwm onto P1_17.
This state is preserved during deep sleep, to allow PWM output on the pad during deep sleep.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_PWM_AON_MODE</name>
	<description>Maps Timer1_pwm onto P1_00
This state is preserved during deep sleep, to allow PWM output on the pad during deep sleep.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPCT_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_XTAL32K_REG</name>
	<description>32 kHz XTAL oscillator register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000002e</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>XTAL32K_DISABLE_OUTPUT</name>
	<description>Disables output buffer, test only</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_DISABLE_AMPREG</name>
	<description>Setting this bit disables the amplitude regulation of the XTAL32kHz oscillator.
Set this bit to '1' for an external clock to XTAL32Kp
Keep this bit '0' with a crystal between XTAL32Kp and XTAL32Km</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_CUR</name>
	<description>Bias current for the 32kHz XTAL oscillator. 0000 is minimum, 1111 is maximum, 0011 is default. For each application there is an optimal setting for which the start-up behavior is optimal </description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_RBIAS</name>
	<description>Setting for the bias resistor. 00 is maximum, 11 is minimum. Prefered setting will be provided by Dialog </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_ENABLE</name>
	<description>Enables the 32kHz XTAL oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DISCHARGE_RAIL_REG</name>
	<description>Immediate rail resetting. There is no LDO/DCDC gating</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RESET_V30</name>
	<description>1: Enables immediate discharging of the V30 rail. Note that the source is not disabled.
0: disable immediate discharging of the V30 rail.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_VPOD</name>
	<description>1: Enables immediate discharging of the VPOD rail. Note that the source is not disabled.
0: disable immediate discharging of the VPOD rail.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_V18P</name>
	<description>1: Enables immediate discharging of the V18P rail. Note that the source is not disabled.
0: disable immediate discharging of the V18P rail.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_V18</name>
	<description>1: Enables immediate discharging of the V18 rail. Note that the source is not disabled.
0: disable immediate discharging of the V18 rail.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_V14</name>
	<description>1: Enables immediate discharging of the V14 rail. Note that the source is not disabled.
0: disable immediate discharging of the V14 rail.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCD_EXT_CTRL_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>LCD_EXT_CLK_EN</name>
	
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_EXT_CNT_RELOAD</name>
	<description>Reload value for LCD_EXT_CLK generation.
When the counter hits 0x0, it is reloaded with
LCD_EXT_CNT_RELOAD&lt;&lt;5.
So the clock period is F(slp_clk) * 32 * (LCD_EXT_CNT_RELOAD+1)
Value 0x0 is not allowed.
The LCD_EXT_CLK is generated from the SLP_CLK.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_LATCH_EN</name>
	<description>Direct write to the individual pad latching signals.
Latches the control signals of the pads for state retention in powerdown mode.
0 = Control signals are retained
1 = Latch is transparant, pad can be recontrolled </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_RESET_LATCH_EN</name>
	<description>Direct Reset of the marked bits. Reading returns 0x0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_SET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_SET_LATCH_EN</name>
	<description>Direct Set of the marked bits. Reading returns 0x0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>P1_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_LATCH_EN</name>
	<description>Direct write to the individual pad latching signals.
Latches the control signals of the pads for state retention in powerdown mode.
0 = Control signals are retained
1 = Latch is transparant, pad can be recontrolled </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_RESET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_RESET_LATCH_EN</name>
	<description>Direct Reset of the marked bits. Reading returns 0x0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_SET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_SET_LATCH_EN</name>
	<description>Direct Set of the marked bits. Reading returns 0x0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>P2_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00007fff</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_LATCH_EN</name>
	<description>Direct write to the individual pad latching signals.
Latches the control signals of the pads for state retention in powerdown mode.
0 = Control signals are retained
1 = Latch is transparant, pad can be recontrolled </description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_RESET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_RESET_LATCH_EN</name>
	<description>Direct Reset of the marked bits. Reading returns 0x0.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_SET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_SET_LATCH_EN</name>
	<description>Direct Set of the marked bits. Reading returns 0x0.</description>
	<bitRange>[14:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>PMU_CTRL_REG</name>
	<description>Power Management Unit control register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000060f</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>RETAIN_RGP_RAM</name>
	<description>Retain the R-G-B RAMs inside the LCD display controller</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RETAIN_GPU_CLUT</name>
	<description>Retain the GPU CLUT memory</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RETAIN_DCACHE</name>
	<description>Selects the retainability of the dcache block while PD_CTRL is off.
'1' is retainable, '0' is power gated</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPU_SLEEP</name>
	<description>Put the GPU power domain (PD_GPU) in powerdown</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CTRL_SLEEP</name>
	<description>Put the Controller power domain (PD_CTRL) in powerdown</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENABLE_CLKLESS</name>
	<description>Selects the clockless sleep mode. Wakeup is done asynchronously.
When set to '1', the lp_clk is stopped during deep sleep, until a wakeup event (not debounced) is detected by the WAKUPCT block.
When set to '0', the lp_clk continues running, so the MAC counters keep on running.
This mode cannot be combined with regulated sleep, so keep SLEEP_TIMER=0 when using ENABLE_CLKLESS.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RETAIN_CACHE</name>
	<description>Selects the retainability of the cache block during deep sleep.
'1' is retainable, '0' is power gated</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_SLEEP</name>
	<description>Put the System powerdomain (PD_SYS) in powerdown.
If this bit is '1', and there is no pending IRQ in the PDC for the M33, the PD_SYS will be switched off.
Wakeup should be handled by the PDC.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_ON_WAKEUP</name>
	<description>Perform a Hardware Reset after waking up. Booter will be started. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_SLEEP</name>
	<description>Put the Communications powerdomain (PD_SNC) in powerdown </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SLEEP</name>
	<description>Put the Timers Powerdomain (PD_TIM) in powerdown.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_SLEEP</name>
	<description>Put the digital part of the radio, including CMAC (PD_RAD) in powerdown </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUD_SLEEP</name>
	<description>Put the audio power domain (PD_AUD) in powerdown</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_SLEEP_REG</name>
	<description>Configures the sleep/wakeup strategy</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00881e08</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ULTRA_FAST_WAKEUP</name>
	<description>Allows the core to start running on the RC32M while the PMU is still waiting for supplies to settle to the final value. Only use in combination with FAST_WAKEUP and 0.9 V on VDD during sleep.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENABLE_FAST_SWITCH</name>
	<description>Enables early clock switching upon event detection to speed up wakeup time</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VLED_BYPASS_REFRESH_TIME</name>
	<description>This setting determines how long the VLED bypass switch is closed when VSYS near VLED flag and VLED VNOK flag are asserted in sleep. Each 1 LSB represents 31.25us. If VLED_BYPASS_REFRESH_TIME(sec) &gt;= BASE_REFRESH_INTERVAL(sec), then VLED bypass switch will remain closed until VLED VNOK flag is asserted, if VSYS near VLED flag was high when going to sleep. If VLED_BYPASS_REFRESH_TIME = 0, then VLED bypass switch will remain opened in sleep independently on the state of VSYS near VLED comparator, and will only be closed if needed during the boost refresh cycles.
</description>
	<bitRange>[29:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_SLEEP_INTERVAL</name>
	<description>&quot;This is the interval at which the BOD comparators/POR will be checked during sleep. Value represents RAILS_REFRESH_INTERVAL times-&gt; BOD and POR are checked every(sec)=BASE_REFRESH_INTERVAL(sec)*RAILS_REFRESH_INTERVAL*BOD_SLEEP_INTERVAL
If 0, BOD/POR will not be checked in sleep.&quot;</description>
	<bitRange>[22:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAILS_REFRESH_INTERVAL</name>
	<description>This is the interval at which the power rails reference voltage will be refreshed during sleep. Value represents BASE_REFRESH_INTERVAL times-&gt; Rails refresh every(sec)=BASE_REFRESH_INTERVAL(sec)*RAILS_REFRESH_INTERVAL.
If 0, then voltage reference will not be refreshed in sleep, and BOD/POR will not be checked in sleep.</description>
	<bitRange>[18:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BASE_REFRESH_INTERVAL</name>
	<description>This sets the base time for calculating the intervals at which PMU refreshes during sleep. In addition, if DCDC_VLED_SLEEP_EN=1, this will be the VLED refresh interval. Each 1 LSB represents 0.125ms. Thus, max base time = 3.875ms.
If 0, then there will not be any refresh cycle in SLEEP.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_TRIM_REG</name>
	
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000480</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>IBIAS_10N_TRIM</name>
	
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RET_V30_TRIM</name>
	
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_V30_TRIM</name>
	
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_CTRL_REG</name>
	<description>Controls the POR on VBAT</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000820</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>POR_VSYS_SLEEP_CYCLE_EN</name>
	<description>Enables POR_VSYS during BOD check cycles in sleep (If POR_VSYS_DISABLE = 0)</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VSYS_HYST_SEL</name>
	<description>&quot;Selects POR_VSYS threshold level, when hysteresis is disabled (see POR_VSYS_DISABLE)
0: Vthres = VTH_L (low level)
1: Vthres = VTH_H (high level)&quot;</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VSYS_HYST_DISABLE</name>
	<description>Disable POR_VSYS hysteresis.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VSYS_FORCE_ON</name>
	<description>FORCE POR_VSYS to be ON (also in SLEEP)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VSYS_MASK</name>
	<description>Mask POR on VSYS</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_VSYS_DISABLE</name>
	<description>Disable POR_VSYS</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_V30_SLEEP_CYCLE_EN</name>
	<description>Enables POR_V30 during BOD check cycles in sleep (If POR_V30_DISABLE = 0)
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_V30_HYST_SEL</name>
	<description>Selects POR_VDDA_3V0 threshold level, when hysteresis is disabled (see POR_VDDA_3V0_HYST_DISABLE)
0: Vthres = VTH_L (low level)
1: Vthres = VTH_H (high level)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_V30_HYST_DISABLE</name>
	<description>Disable POR_VDDA_3V0 hysteresis; select level with POR_VDDA_3V0_HYST_SEL</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_V30_FORCE_ON</name>
	<description>Force POR_VDDA_3V0 always ON, (also in SLEEP)</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_V30_MASK</name>
	<description>Mask POR_VDDA_3V0</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_V30_DISABLE</name>
	<description>Disable POR_VDDA_3V0</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_PIN_REG</name>
	<description>Selects a GPIO pin for POR generation</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>POR_PIN_POLARITY</name>
	<description>0: Active Low
1: Active High
Note: This applies only for the GPIO pin. Reset pad is always active High
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_PIN_SELECT</name>
	<description>0x00: P0_00
...
0x1f: P0_31
0x20: P1_00
...
0x3F: P1_31
0x40: P2_00
...
0x4E: P2_14
0x4F to 0x7E: reserved
0x7F: POR generation disabled</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_TIMER_REG</name>
	<description>Time for POR to happen</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000018</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>POR_TIME</name>
	<description>Time for the POReset to happen.
Formula:
Time = POR_TIME x 4096 x RC32 clock period
Default value: ~3 seconds
</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_CTRL_REG</name>
	<description>Power control register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000cc393</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SW_V18F_SLEEP_ON</name>
	<description>Closes the V18F switch in sleep when DCDC_V18P_SLEEP_EN is 1. See SW_V18F register for more settings.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_V18F_ON</name>
	<description>Closes the V18F switch when DCDC_V18P_EN is 1. See SW_V18F register for more settings.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VLED_SLEEP_EN</name>
	<description>Enables boost dcdc led rail in sleep mode</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VLED_EN</name>
	<description>Enables boost dcdc led rail in active mode</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_SLEEP_EN</name>
	<description>Enables buck dcdc V18p rail in sleep mode</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18P_EN</name>
	<description>Enables buck dcdc V18p rail in active mode</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_SLEEP_EN</name>
	<description>Enables buck dcdc V18 rail in sleep mode</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V18_EN</name>
	<description>Enables buck dcdc V18 rail in active mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_SLEEP_EN</name>
	<description>Enables buck dcdc V14 rail in sleep mode</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V14_EN</name>
	<description>Enables buck dcdc V14 rail in active mode</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V12_SLEEP_EN</name>
	<description>Enables buck dcdc V12 rail in sleep mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_V12_EN</name>
	<description>Enables buck dcdc V12 rail in active mode</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLAMP_V12_DIS</name>
	<description>Disables V12 clamp. During Hibernation, V12 clamp will be enabled regardless of this bit.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLAMP_V30_EN</name>
	<description>Enables V30 clamp.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_MIPI_EN</name>
	<description>Enables ldo MIPI when DCDC_V18P_EN is 1</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RET_V30_SLEEP_EN</name>
	<description>Enables ldo V30 ret in sleep mode</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_RET_V30_EN</name>
	<description>Enables ldo V30 ret in active mode</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_V30_SLEEP_EN</name>
	<description>Enables ldo V30 in sleep mode</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_V30_EN</name>
	<description>Enables ldo V30 in active mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_START_EN</name>
	<description>Enables ldo start.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_LVL_REG</name>
	
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00009830</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>VSYS_LEVEL</name>
	<description>Level setting for VSYS rail when ldo_vsys is enabled (COMP_VBUS_OK &amp; COMP_VBUS_ABOVE_VSYS): 
0=4.8V
1=4.6V
2=4.4V
3=4.2V </description>
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V18_LEVEL</name>
	<description>Level setting for V18 rail:
0=1.8V
1=1.2V</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V14_LEVEL</name>
	<description>Level setting for V14 rail:
0=1.2V
1=1.3V
2=1.4V
3=1.5V</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V12_SLEEP_LEVEL</name>
	<description>Level setting for V12 rail in sleep:
0=0.75V
1=0.9V
2=1.2V
3=reserved</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V12_LEVEL</name>
	<description>Level setting for V12 rail:
0=0.75V
1=0.9V
2=1.2V
3=reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V30_SLEEP_LEVEL</name>
	<description>Level setting for V30 in sleep:
0x0: 3.0V
0x1: reserved
0x2: 3.3V
0x3: 3.3V
</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>V30_LEVEL</name>
	<description>Level setting for V30:
0x0: 3.0V
0x1: reserved
0x2: 3.3V
0x3: 3.3V
</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VMIPI_LEVEL</name>
	<description>LDO MIPI level: 0.9V+0.05V*LDO_MIPI_LEVEL. Default=1.2V
</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLAMP_V12_LEVEL</name>
	<description>Level setting for V12 clamp, retained in hibernation (only V12 source in Hibernation). Typical output voltages (not regulated):
</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RAM_PWR_CTRL_REG</name>
	<description>Control power state of System RAMS</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields><field>
	<name>RAM13_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM12_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM11_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM10_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM9_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM8_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM7_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM6_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM5_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM4_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM3_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_PWR_CTRL</name>
	<description>See description of RAM0_PWR_CTRL.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM0_PWR_CTRL</name>
	<description>Power state control of the individual RAMs. May only change when the memory isn't accessed.
When PD_MEM_IS_UP:
0x0: Normal operation
0x1: Normal operation
0x2: Retained (no access possible)
0x3: Off (memory content corrupted)
When PD_MEM_IS_DOWN:
0x0: Retained
0x1: Off (memory content corrupted)
0x2: Retained
0x3: Off (memory content corrupted)</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_STAT_REG</name>
	<description>Reset status register</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>SNC_WDOGRESET_STAT</name>
	<description>Indicates that a SNC-Watchdog timeout has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_WDOGRESET_STAT</name>
	<description>Indicates that a CMAC-Watchdog timeout has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWD_HWRESET_STAT</name>
	<description>Indicates that a write to SWD_RESET_REG has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOGRESET_STAT</name>
	<description>Indicates that a Watchdog timeout has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWRESET_STAT</name>
	<description>Indicates that a SW Reset has happened</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HWRESET_STAT</name>
	<description>Indicates that a HW Reset has happened</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PORESET_STAT</name>
	<description>Indicates that a PowerOn Reset has happened.
All bitfields of RESET_STAT_REG should be read (in order to check the source of reset) and then cleared to '0', allowing thus the HW to automatically set to '1' the proper bitfields during the next reset event.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RST_CTRL_REG</name>
	<description>Reset control register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>SYS_CACHE_FLUSH_WITH_SW_RESET</name>
	<description>0: Flush the System Cache memory only at HW reset.
1: Flush the System Cache memory also at SW reset.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SECURE_BOOT_REG</name>
	<description>Controls secure booting</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PROT_OTP_CS_WRITE</name>
	<description>This bit will permanentlly disable any write action to the CS inside the OTP</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_SNC_DEBUGGER_OFF</name>
	<description>This bit will permanently disable the SNC debugger</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_OQSPIF_KEY_READ</name>
	<description>This bit will permanently disable CPU read capability at OTP offset 0x00000B00 and for the complete segment</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_OQSPIF_KEY_WRITE</name>
	<description>This bit will permanently disable ANY write capability at OTP offset 0x00000B00 and for the complete segment </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_AES_KEY_READ</name>
	<description>This bit will permanently disable CPU read capability at OTP offset 0x00000A00 and for the complete segment </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_AES_KEY_WRITE</name>
	<description>This bit will permanently disable ANY write capability at OTP offset 0x00000A00 and for the complete segment </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROT_SIG_KEY_WRITE</name>
	<description>This bit will permanently disable ANY write capability at OTP offset 0x000008C0 and for the complete segment </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_CMAC_DEBUGGER_OFF</name>
	<description>This bit will permanently disable the CMAC debugger</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_DEBUGGER_OFF</name>
	<description>Follows the respective OTP flag value. Its value is updated by the BootROM code.
1: The system debugger SWD is totally disabled.
0: The system debugger is enabled with DEBUGGER_ENABLE</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SECURE_BOOT</name>
	<description>Follows the respective OTP flag value. Its value is updated by the BootROM code.
1: system is a secure system supporting secure boot
0: system is not supporting secure boot</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SLP_MAP_REG</name>
	<description>Map signals on GPIOs during sleep</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>LCD_INV_EXT_CLK_SLP_MAP</name>
	<description>Maps inverted LCD_EXT_CLK on P0_10, for LCD XFRP function
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCD_EXT_CLK_SLP_MAP</name>
	<description>Maps LCD_EXT_CLK on P0_19, for LCD VCOM/FRP/EXTCOMIN function
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BANDGAP_SLP_MAP</name>
	<description>Setting this bit will:

-map bandgap_enable to P0_13
-map (wokenup OR cmac_slp_timer_expire) to P1_06</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCLP_SLP_MAP</name>
	<description>Maps RCLP onto P1_23.
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_SLP_MAP</name>
	<description>Maps XTA32k onto P0_31.
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_SLP_MAP</name>
	<description>Maps RCX onto P1_22.
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR4_PWM_SLP_MAP</name>
	<description>Maps Timer4_pwm onto P1_31
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR3_PWM_SLP_MAP</name>
	<description>Maps Timer3_pwm onto P1_30
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_PWM_SLP_MAP</name>
	<description>Maps Timer1_pwm onto P0_30
This state is preserved during deep sleep, to allow pin output toggle on the pad during deep sleep.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SW_V18F_REG</name>
	
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>DELAY_TRIM</name>
	<description>Soft start delay trim
</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SKIP_SOFT_START</name>
	<description>Skip soft start routine
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_SW_ON</name>
	<description>Forces closing sw_V18f, independent of v18p state
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_CTRL_REG</name>
	<description>System Control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SW_RESET</name>
	<description>Writing a '1' to this bit will generate a SW_RESET.</description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CACHERAM_MUX</name>
	<description>Controls accessiblity of Cache RAM:
0: the cache controller is bypassed, the cacheRAM is visible in the memory space
1: the cache controller is enabled, the cacheRAM is not visible anymore in the memory space</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIMEOUT_DISABLE</name>
	<description>Disables timeout in Power statemachine. By default, the statemachine continues if after 2 ms the blocks are not started up. This can be read back from
ANA_STATUS_REG</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEBUGGER_ENABLE</name>
	<description>Enable the debugger. This bit is set by the booter according to the OTP header. If not set, the SWDIO and SW_CLK can be used as gpio ports. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_DEBUGGER_ENABLE</name>
	<description>Enable the CMAC debugger. If not set, the SWDIO and SW_CLK can be used as gpio ports. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_INTVECT</name>
	<description>0: normal operation
1: If ARM is in address range 0 to 0x1FF then the address is remapped to SYS-RAM 0x0080.0000 to 0x0080.01FF. This allows to put the interrupt vector table to be placed in RAM while executing from QSPI.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_ADR0</name>
	<description>Controls which memory is located at address 0x0000 for execution.
0x0: ROM
0x1: OTP un-cached
0x2: OQSPI FLASH cached (see also the CACHE_FLASH_REG.FLASH_REGION.* descriptions)

Note 1: When REMAP_ADR0=0x2, address 0x0 is mapped to FLASH_REGION_BASE + FLASH_REGION_OFFSET&lt;&lt;2. Note 2: When REMAP_ADR0=0x2, the CPU can only access the Flash region [FLASH_REGION_BASE + FLASH_REGION_OFFSET&lt;&lt;2, FLASH_REGION_SIZE] from the 0x16000000 address range. The complete Flash can be accessed via the 0x36000000 address range but only uncached. 0x3: RAMS un-cached
0x4: OQSPI FLASH un-cached (for verification only)
0x5: SYSRAM3 (for SNC-based applications, where SNC uses SYSRAM 1&amp;2)
0x6: Cache Data RAM un-cached (CACHERAM_MUX=0, for testing purposes only)


Note 1: DWord (64 bits) access is not supported by the Cache Data RAM interface in mirrored mode (only 32, 16 and 8 bits). Note 2: DMA access is not supported by the Cache Data RAM interface when REMAP_ADR0=0x6. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_STAT_REG</name>
	<description>System status register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000165a5</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>GPU_IS_UP</name>
	<description>Indicates that PD_GPU is functional </description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GPU_IS_DOWN</name>
	<description>Indicates that PD_GPU is in power down </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CTRL_IS_UP</name>
	<description>Indicates that PD_CTRL is functional </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CTRL_IS_DOWN</name>
	<description>Indicates that PD_CTRL is in power down </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>POWER_IS_UP</name>
	<description>Indicates that the Startup statemachine is finished, and all power regulation is in order.
In UltraFastWakeup mode, the SW needs to wait for this signal before starting any heavy traffic.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBG_IS_ACTIVE</name>
	<description>Indicates that a debugger is attached.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SNC_IS_UP</name>
	<description>Indicates that PD_SNC is functional </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SNC_IS_DOWN</name>
	<description>Indicates that PD_SNC is in power down </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_UP</name>
	<description>Indicates that PD_TIM is functional </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_DOWN</name>
	<description>Indicates that PD_TIM is in power down </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MEM_IS_UP</name>
	<description>Indicates that PD_MEM is functional</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MEM_IS_DOWN</name>
	<description>Indicates that PD_MEM is in power down</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_IS_UP</name>
	<description>Indicates that PD_SYS is functional </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_IS_DOWN</name>
	<description>Indicates that PD_SYS is in power down </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUD_IS_UP</name>
	<description>Indicates that PD_AUD is functional </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUD_IS_DOWN</name>
	<description>Indicates that PD_AUD is in power down </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_UP</name>
	<description>Indicates that PD_RAD is functional </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_DOWN</name>
	<description>Indicates that PD_RAD is in power down </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>VBUS_IRQ_CLEAR_REG</name>
	<description>Clear pending IRQ register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VBUS_IRQ_CLEAR</name>
	<description>Writing any value to this register will reset the VBUS_IRQ line</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>VBUS_IRQ_MASK_REG</name>
	<description>IRQ masking</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>VBUS_WAKEUP_CLKLESS</name>
	<description>Enables waking up from CLKLESS mode when VBUS becomes available.
For the system to wakeup, also the VBUS_IRQ_EN_RISE should be set to trigger the PDC.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBUS_IRQ_EN_RISE</name>
	<description>Setting this bit to '1' enables VBUS_IRQ generation when the VBUS starts to ramp above threshold</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VBUS_IRQ_EN_FALL</name>
	<description>Setting this bit to '1' enables VBUS_IRQ generation when the VBUS starts to fall below threshold</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WAKEUP_HIBERN_REG</name>
	
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fff</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>HIBERNATION_ENABLE</name>
	<description>Enable hibernation mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUP_PD_EN</name>
	<description>Enables pulldown for GPIO[n] during hibernation
Bit 0: P0_20
Bit 1: P0_29
Bit 2: P1_04
Bit 3: P0_28</description>
	<bitRange>[9:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUP_EN</name>
	<description>Enables GPIO[n] to wake up from hibernation
Bit 0: P0_20
Bit 1: P0_29
Bit 2: P1_04
Bit 3: P0_28</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_VSYS</name>
	<version>1.0</version>
	<description>CRG_VSYS registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000b00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>VSYS_GEN_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000610ed</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields><field>
	<name>FORCE_VBAT_VSYS_SW</name>
	<description>0x0,0x1: VBAT_VSYS set to ideal diode
0x2: Forces VBAT_VSYS switch to be opened
0x3: Forces VBAT_VSYS switch to be closed </description>
	<bitRange>[24:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_LDO_ENABLE</name>
	<description>0x0,0x1: LDO VSYS will be enabled when COMP_VBUS_OK &amp; COMP_VBUS_ABOVE_VSYS.
0x2: LDO_VSYS will be disabled regardless of VBUS state
0x3: LDO_VSYS will be enabled regardless of VBUS state</description>
	<bitRange>[22:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_TEMP_PROTECT_MODE</name>
	<description>0x0: LDO_VSYS is muted (disabled) when temperature is too high, when temperature is back to operating conditions ldo is unmuted
0x1: LDO_VSYS is muted (disabled) when temperature is too high, LDO_VSYS_HIGH_TEMP_IRQ must be cleared to allow ldo to be unmuted. See VSYS_GEN_IRQ_CLEAR_REG.
0x2: LDO_VSYS is not muted (disabled) when temperature is too high
0x3: Force LDO_VSYS mute </description>
	<bitRange>[20:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_HEADROOM</name>
	<description>Enables the voltage headroom loop in the LDO_VSYS. </description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CURLIM_OFFSET_TRIM</name>
	<description>For adjusting the offset of the curlim range ( +/- 78 mA)
0x0 = maximum positive offset.
0x10 = minimal offset ( reset value).
0x1F = maximum negative offset.</description>
	<bitRange>[17:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CURLIM_GAIN_TRIM</name>
	<description>For adjusting the gain of the curlim range ( +/- 20%)
0x0 = maximum gain.
0x10 = nominal gain ( reset value).
0x1F = minimum gain.</description>
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CURLIM_SET</name>
	<description>Sets the level of the LDO_VSYS current limiter in 10 mA steps. It is reset when vbus is not plugged (COMP_VBUS_PLUGIN == 0).
0x0 = 1270 mA
0x1 = 1260 mA
...
0x76 = 90 mA ( reset value)
</description>
	<bitRange>[7:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_CURLIM</name>
	<description>Enables the current limiter in the LDO_VSYS</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>VSYS_GEN_IRQ_CLEAR_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>VBUS_LOW_DRIVE_IRQ_CLEAR</name>
	<description>Clears VBUS_LOW_DRIVE_IRQ</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>LDO_VSYS_HIGH_TEMP_IRQ_CLEAR</name>
	<description>Clears LDO_VSYS_HIGH_TEMP_IRQ</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>VSYS_GEN_IRQ_MASK_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>VBUS_LOW_DRIVE_IRQ_MASK</name>
	<description>Masks VBUS_LOW_DRIVE_IRQ interrupt. It is reset when vbus is not plugged in (COMP_VBUS_PLUGIN == 0). This is because when vbus is just plugged in, it is likely to bounce; therefore IRQ is masked to avoid false triggering. Some time after vbus plugin, software might increase ldo_vsys current limit and should set this mask to 0 (after clearing IRQ).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VSYS_HIGH_TEMP_IRQ_MASK</name>
	<description>Masks LDO_VSYS_HIGH_TEMP_IRQ interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>VSYS_GEN_IRQ_STATUS_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>VBUS_LOW_DRIVE_IRQ_STATUS</name>
	<description>Indicates vbus drive strength is not enough to keep vbus up with the set limit of ldo_vbus. Consider lowering CURLIM_SET in VSYS_GEN_CTRL_REG. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VSYS_HIGH_TEMP_IRQ_STATUS</name>
	<description>Indicates that a high temperature has been detected at ldo_vsys </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_XTAL</name>
	<version>1.0</version>
	<description>CRG_XTAL registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>156</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PLL_SYS_CTRL1_REG</name>
	<description>System PLL control register 1.</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000e8a0</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PLL_OUT_DIV</name>
	<description>0: Output divider ON 1: Output divider OFF</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_SEL_MIN_CUR_INT</name>
	<description>0: VCO current read from min_current &lt;5:0&gt;,
1: VCO current is internally determined with a calibration algoritm.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_PRE_DIV</name>
	<description>PLL input divider (1: Indicates divide by 2).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_N_DIV</name>
	<description>PLL loop divider N (x means divide by x, 0 means divide by 1) </description>
	<bitRange>[10:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_PLL_VREF_HOLD</name>
	<description>0: Indicates that the reference input is tracked,
1: Indicates that the reference input is sampled.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_PLL_ENABLE</name>
	<description>0: LDO PLL off,
1: LDO PLL on.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_RST_N</name>
	<description>0: PLL in Reset 1L PLL out of Reset </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_EN</name>
	<description>0: Power down
1: PLL on </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_SYS_CTRL2_REG</name>
	<description>System PLL control register 2.</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c80</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PLL_RECALIB</name>
	<description>Recalibrate</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_SYS_CTRL3_REG</name>
	<description>System PLL control register 3.</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00009870</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PLL_MIN_CURRENT</name>
	<description>VCO current trimming.</description>
	<bitRange>[6:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_SYS_STATUS_REG</name>
	<description>System PLL status register.</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LDO_PLL_OK</name>
	<description>1: Indicates that LDO PLL is in regulation.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_CALIBRATION_END</name>
	<description>Indicates that calibration has finished.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_BEST_MIN_CUR</name>
	<description>Calibrated VCO current.</description>
	<bitRange>[10:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_LOCK_FINE</name>
	<description>1: PLL locked </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PLL_USB_CTRL1_REG</name>
	<description>USB PLL control register 1.</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00006890</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PLL_OUT_DIV</name>
	<description>0: Output divider ON 1: Output divider OFF</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_SEL_MIN_CUR_INT</name>
	<description>0: VCO current read from min_current &lt;5:0&gt;,
1: VCO current is internally determined with a calibration algoritm.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_PRE_DIV</name>
	<description>PLL input divider (1: Indicates divide by 2).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_N_DIV</name>
	<description>PLL loop divider N (x means divide by x, 0 means divide by 1) </description>
	<bitRange>[10:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_PLL_VREF_HOLD</name>
	<description>0: Indicates that the reference input is tracked,
1: Indicates that the reference input is sampled.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_PLL_ENABLE</name>
	<description>0: LDO PLL off,
1: LDO PLL on.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_RST_N</name>
	<description>0: PLL in Reset 1L PLL out of Reset </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_EN</name>
	<description>0: Power down
1: PLL on </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_USB_CTRL2_REG</name>
	<description>USB PLL control register 2.</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000c80</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PLL_RECALIB</name>
	<description>Recalibrate</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_USB_CTRL3_REG</name>
	<description>USB PLL control register 3.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00009870</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PLL_MIN_CURRENT</name>
	<description>VCO current trimming.</description>
	<bitRange>[6:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PLL_USB_STATUS_REG</name>
	<description>USB PLL status register.</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LDO_PLL_OK</name>
	<description>1: Indicates that LDO PLL is in regulation.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_CALIBRATION_END</name>
	<description>Indicates that calibration has finished.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_BEST_MIN_CUR</name>
	<description>Calibrated VCO current.</description>
	<bitRange>[10:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PLL_LOCK_FINE</name>
	<description>1: PLL locked </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RESET_SYS_IRQ_CTRL_REG</name>
	<description>System IRQ RESET register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>CMAC2SNC_IRQ_BIT</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC2SYS_IRQ_BIT</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC2SYS_IRQ_BIT</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC2CMAC_IRQ_BIT</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS2SNC_IRQ_BIT</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS2CMAC_IRQ_BIT</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_SYS_IRQ_CTRL_REG</name>
	<description>System IRQ SET register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>CMAC2SNC_IRQ_BIT</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC2SYS_IRQ_BIT</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC2SYS_IRQ_BIT</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC2CMAC_IRQ_BIT</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS2SNC_IRQ_BIT</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS2CMAC_IRQ_BIT</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_IRQ_CTRL_REG</name>
	<description>System IRQ control register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>CMAC2SNC_IRQ_BIT</name>
	
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC2SYS_IRQ_BIT</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC2SYS_IRQ_BIT</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC2CMAC_IRQ_BIT</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS2SNC_IRQ_BIT</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS2CMAC_IRQ_BIT</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CAP_MEAS_REG</name>
	<description>Capacitance measure circuit control</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000090</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>XTAL32M_MEAS_TIME</name>
	<description>Select measurement time (in DIVN clock-cycles)
0: 32
1: 64

6: 2048
7: 4096</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_MEAS_START</name>
	<description>Starts capacitance measurement</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_MEAS_CUR</name>
	<description>Select measurement current (minimum required capacitance)
0: 100nA (0.44pF)
1: 500nA (2.22pF)
2: 1uA (4.44pF)
3: 5uA (22.2pF)</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CAP_SELECT</name>
	<description>Select measured capacitance
0: disabled
1: hold capacitance
2: xtal_p
3: xtal_n
4: xtal_p + xtal_n
5: low reference on xtal_p
6: low reference on xtal_p</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL_REG</name>
	<description>Xtal32m control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000415</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>XTAL32M_DRIVE_CYCLES</name>
	<description>Number of drive clock-cycles
0x0: Drive disabled
0x1: 4
0x2: 8
0x3: 16
0x4: 32
0x5: 64
0x6:128
0x7:256</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_ENABLE</name>
	<description>Enables xtal32m (testing purposes)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_BIASPROT</name>
	<description>Bias startup circuit
0: enable during startup
1: always enabled
2: always disabled</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_LDO_SAH</name>
	<description>Controls amplitude regulator sample-and-hold
2'b00: set to HOLD when IRQ fires
2'b01: always TRACK
2'b1x: always HOLD</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPREG_SAH</name>
	<description>Controls amplitude regulator sample-and-hold
2'b00: set to HOLD when IRQ fires
2'b01: always TRACK
2'b1x: always HOLD</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_BIAS_SAH</name>
	<description>Controls bias sample-and-hold
2'b00: set to HOLD when IRQ fires
2'b01: always TRACK
2'b1x: always HOLD</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_FSM_REG</name>
	<description>Startup state machine configuration</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>XTAL32M_BOOST_MODE</name>
	<description>Boost mode configuration
0: Only allow BOOST mode in START state
1: Allow BOOST mode in SETTLE and START state</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_FSM_APPLY_CONFIG</name>
	<description>CUR_SET, AMPL_SET, CMP_LVL and TRIM from XTAL32M_TRIM_REG are
0: applied at next startup
1: immediately applied</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_FSM_FORCE_IDLE</name>
	<description>Forces FSM in IDLE state, allows for software control</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_MODE</name>
	<description>Use following comparator trim settings in SETTLE state:
0: XTAL32M_TRIM_REG.CMP_LVL
1: XTAL32M_SETTLE_REG.CMP_LVL</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM_MODE</name>
	<description>Use following trimsetting in the SETTLE state
0: XTAL32M_TRIM_REG.TRIM
1: XTAL32M_SETTLE_REG.TRIM</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_MODE</name>
	<description>Use the following current setting in the SETTLE state
0: XTAL32M_START_REG.CUR_SET
1: XTAL32M_SETTLE_REG.CUR_SET</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_IRQ_CTRL_REG</name>
	<description>Xtal32m Interrupt control register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>XTAL32M_IRQ_CAP_CTRL</name>
	<description>The IRQ counter is captured in the XTAL32M_IRQ_STATUS_REG.IRQ_COUNT_CAP when leaving the following state
0: START
1: SETTLE
2: RUN</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_IRQ_ENABLE</name>
	<description>Enable xtal interrupt generation.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_IRQ_CLK</name>
	<description>Clock divider for IRQ counter
0: 4us
1: 32us</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_IRQ_CNT</name>
	<description>IRQ counter start value.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_IRQ_STAT_REG</name>
	<description>XTAL32M IRQ status register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL32M_IRQ_COUNT_CAP</name>
	<description>Captured IRQ counter</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_IRQ_COUNT_STAT</name>
	<description>Current IRQ counter value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTAL32M_SETTLE_REG</name>
	<description>Trim values for XTAL32M in SETTLE state of startup</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x001a312c</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_TIMEOUT</name>
	<description>Timeout
0: disabled
1: 4us
2: 8us

63: 252us
64: 268us
...
127: 1260us</description>
	<bitRange>[28:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_BLANK</name>
	<description>Blanking time for comparator output
0: disabled
1: 4us
2: 8us
3: 16us
4: 32us
5: 64us</description>
	<bitRange>[21:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_LVL</name>
	<description>Comparator triplevel
0: 30%
1: 35%
2: 45%
3: 60%</description>
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPL_SET</name>
	<description>Amplitude Regulator input level setting (peak-peak) in SETTLE phase of startup
0: 300mV
1: 350mV
..
7: 900mV</description>
	<bitRange>[16:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_SET</name>
	<description>Current setting (units of 16uA) in SETTLE phase of startup
0: OFF
1: 1x
2: 2x
3: 3x
4: 4x
5: 6x
6: 8x
7: 12x
8: 16x
9: 24x
10: 32x
11: 48x
12: 64x
13: 96x
14: 128x
15: 192x</description>
	<bitRange>[13:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM</name>
	<description>Capacitance bank seting in SETLLE phase of startup
CL = 3.5pF + 50fF/LSB</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_START_REG</name>
	<description>Trim values for XTAL32M in START state of startup</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x001c312c</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_TIMEOUT</name>
	<description>Timeout
0: disabled
1: 4us
2: 8us

63: 252us
64: 268us
...
127: 1260us</description>
	<bitRange>[28:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_BLANK</name>
	<description>Blanking time for comparator output
0: disabled
1: 4us
2: 8us
3: 16us
4: 32us
5: 64us</description>
	<bitRange>[21:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_LVL</name>
	<description>Comparator triplevel
0: 30%
1: 35%
2: 45%
3: 60%</description>
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPL_SET</name>
	<description>Amplitude Regulator input level setting (peak-peak) in START phase of startup
0: 300mV
1: 350mV
..
7: 900mV</description>
	<bitRange>[16:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_SET</name>
	<description>Current setting (units of 16uA) in START phase of startup
0: OFF
1: 1x
2: 2x
3: 3x
4: 4x
5: 6x
6: 8x
7: 12x
8: 16x
9: 24x
10: 32x
11: 48x
12: 64x
13: 96x
14: 128x
15: 192x</description>
	<bitRange>[13:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM</name>
	<description>Capacitance bank seting in START phase of startup
CL = 3.5pF + 50fF/LSB</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_STAT0_REG</name>
	<description>XTAL32M status register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x3fffffff</resetMask>
	<fields><field>
	<name>XTAL32M_OVERLOAD</name>
	<description>Indicates xtal is overloaded</description>
	<bitRange>[29:29]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_CMP_LVL_STAT</name>
	<description>Current value for amplitude regulator comparator setting</description>
	<bitRange>[28:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_AMPL_TRIM</name>
	<description>Current value for amplitude trim</description>
	<bitRange>[26:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_TRIM_VAL</name>
	<description>Current value for oscillator trimming</description>
	<bitRange>[23:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_CUR_SET_STAT</name>
	<description>Current value for cur_set</description>
	<bitRange>[13:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_LDO_OK</name>
	<description>Indicates LDO voltage level is ok</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_CMP_OUT</name>
	<description>Amplitude regulator comparator output state</description>
	<bitRange>[8:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_STATE</name>
	<description>State of xtal startup FSM
0x0: IDLE
0x1: WAIT_LDO
0x2: WAIT_BIAS
0x3: XTAL_DRIVE
0x4: START_BLANK
0x5: START
0x6: SETTLE_BLANK
0x7: SETTLE
0x8: RUN
0x9: CAP_TEST_IDLE
0xA: CAP_TEST_MEAS
0xB: CAP_TEST_END</description>
	<bitRange>[6:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_CMP_OUT_HOLD</name>
	<description>Captured state of amplitude regulator comparators at IRQ fire.</description>
	<bitRange>[2:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_READY</name>
	<description>Indicates xtal startup FSM has reached the RUNNIG state and is ready for use (sysclk)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TRIM_REG</name>
	<description>Trim values for XTAL32M in RUNNING state</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00021d2c</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields><field>
	<name>XTAL32M_BOOST_TRIM</name>
	<description>Boost trimming, set accordingly to shunt capacitance. Sensitivity: 125fF/LSB
0x0: Boost Disabled
1: 250fF
2: 375fF
3: 500fF;
4: 625fF;

62: 7.875pF
63: 8pF</description>
	<bitRange>[24:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_LVL</name>
	<description>Comparator triplevel
0: 30%
1: 35%
2: 45%
3: 60%</description>
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPL_SET</name>
	<description>Amplitude Regulator input level setting (peak-peak) in running phase
0: 300mV
1: 350mV
..
7: 900mV</description>
	<bitRange>[16:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_SET</name>
	<description>Current setting (units of 16uA) in running phase
0: OFF
1: 1x
2: 2x
3: 3x
4: 4x
5: 6x
6: 8x
7: 12x
8: 16x
9: 24x
10: 32x
11: 48x
12: 64x
13: 96x
14: 128x
15: 192x</description>
	<bitRange>[13:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM</name>
	<description>Capacitance bank seting in running phase, use to trim the xtal32m output frequency
CL = 3.5pF + 50fF/LSB</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DCACHE</name>
	<version>1.0</version>
	<description>DCACHE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30100000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>40</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DCACHE_BASE_ADDR_REG</name>
	<description>Dcache base address for cacheable region</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DCACHE_BASE_ADDR</name>
	<description>Base of PSRAM cacheable memory
N*1kByte. N = 0 to 131072 (max. of 128 MByte).</description>
	<bitRange>[16:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_CTRL_REG</name>
	<description>Dcache Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00800000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DCACHE_DISABLE_CLKGATE</name>
	<description>Disable the clockgating for the DCACHE
0: Enable clockgating (default)
1: Disable clockgating</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCACHE_WBUFFER_FLUSH</name>
	<description>Write buffer flush
0: Write buffer isn't flushed (default)
1: Write buffer is flushed</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCACHE_WBUFFER_EMPTY</name>
	<description>Status of the write buffer
0: Write buffer isn't empty
1: Write buffer is empty</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCACHE_WFLUSHED</name>
	<description>0: DCACHE is not write flushed yet.
1: DCACHE is write flushed.

Note 1: Setting and clearing of this (status) bit field is automatically done by the hardware.
Note 2: The CACHE_WFLUSHED bit can also be cleared first by the software by writing a '0'</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCACHE_READY</name>
	<description>0: DCACHE isn't initialized yet
1: DCACHE initialization has been completed</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCACHE_WFLUSH</name>
	<description>Write a '1' to this field will trigger a write flush of the 'dirty' lines. All modified data in 'dirty' line will be written back to the PSRAM. The corresponding 'dirty' bits will be cleared. Reading this bit will return '0'</description>
	<bitRange>[20:20]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DCACHE_INIT</name>
	<description>Write a '1' to this field will trigger an initialization of the cache ('0's are written in the TAG area).. Reading from this field will always return '0'</description>
	<bitRange>[19:19]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DCACHE_ENABLE</name>
	<description>Enable the dcache controller HW block:
0: Disabled, all AHB accesses towards the QSPI are bypassing the HW block straight into the PSRAM
1: Enabled, all AHB access towards the QSPI within the cacheable region are cached.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCACHE_LEN</name>
	<description>Length of PSRAM cacheable memory
N*1kByte. N = 0 to 131072 (max. of 128 MByte).
Setting DCACHE_LEN=0 disables the caching.</description>
	<bitRange>[17:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_CTRL_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) CONTROL register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_IRQ_EVICTS_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache evicts reached the programmed threshold (threshold != 0).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_HITS_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache hits reached the programmed threshold (threshold != 0).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MISSES_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache misses reached the programmed threshold (threshold != 0).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_TINT_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the time interval counter reached the end (time interval != 0).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MASK</name>
	<description>0: Disables interrupt generation.
1: Enables interrupt generation.
Note: The Cache MRM generates a pulse-sensitive interrupt towards the ARM processor,</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_START</name>
	<description>0: Freeze the &quot;misses/hits&quot; counters and reset the time interval counter to the programmed value in CACHE_MRM_TINT_REG.
1: Enables the counters.
Note: In case CACHE_MRM_CTRL_REG[MRM_START] is set to '1' and CACHE_MRM_TINT_REG (!=0) is used for the MRM interrupt generation, the time interval counter counts down (on a fixed reference clock of 16 MHz) until it's '0'. At that time CACHE_MRM_CTRL_REG[MRM_START] will be reset automatically to '0' by the MRM hardware and the MRM interrupt will be generated.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_EVICTS_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) EVICTS register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_EVICTS</name>
	<description>Contains the amount of cache evicts</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_EVICTS_THRES_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) EVICTS THRESHOLD register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_EVICTS_THRES</name>
	<description>Defines the hits threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_EVICTS_THRES_STATUS].
Note: When MRM_EVICTS_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_HITS_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) HITS register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_HITS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_HITS_THRES_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) HITS THRESHOLD register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_HITS_THRES</name>
	<description>Defines the hits threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_HITS_THRES_STATUS].
Note: When MRM_HITS_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_MISSES_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) MISSES register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES</name>
	<description>Contains the amount of cache misses.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_MISSES_THRES_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) THRESHOLD register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES_THRES</name>
	<description>Defines the misses threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_MISSES_THRES_STATUS].
Note: When MRM_MISSES_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DCACHE_MRM_TINT_REG</name>
	<description>Dcache MRM (Miss Rate Monitor) TIME INTERVAL register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MRM_TINT</name>
	<description>Defines the time interval for the monitoring in 32 MHz clock cycles. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_TINT_STATUS].
Note: When MRM_TINT=0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[18:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DCDC</name>
	<version>1.0</version>
	<description>DCDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BUCK_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00008cc0</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CFG_TIMEOUT</name>
	<description>Sets maximum switch on-time.
0x0: Disabled
0x1: 0.5 ms
0x2: 1.0 ms (Default)
0x3: 1.5 ms</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_FREEWHEEL</name>
	<description>Enables freewheel switch when converter is idle.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIM_BIAS</name>
	<description>Bias current trim.
0x0: -21 %
0x1: -14 %
0x2: -7 %
0x3: +0 % (Default)
0x4: +7 %
0x5: +14 %
0x6: +21 %
0x7: +28 %</description>
	<bitRange>[12:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CFG_IMAX_UPPER</name>
	<description>Sets upper value of inductor peak current limit control.
0x0: 260 mA
0x1: 400 mA
0x2: 530 mA
0x3: 660 mA
0x4: 790 mA
0x5: 920 mA
0x6: 1060 mA (Default)
0x7: 1190 mA</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CFG_IMAX_LOWER</name>
	<description>Sets lower value of inductor peak current limit control.
0x0: 260 mA (Default)
0x1: 400 mA
0x2: 530 mA
0x3: 660 mA
0x4: 790 mA
0x5: 920 mA
0x6: 1060 mA
0x7: 1190 mA</description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CFG_HYST</name>
	<description>Controls hysteresis on output comparator. Values listed are typical.
0x0: 6 mV (Default)
0x1: 9 mV
0x2: 12 mV
0x3: 15 mV</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DCDC_BOOST</name>
	<version>1.0</version>
	<description>DCDC_BOOST registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>24</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BOOST_CTRL_REG0</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00090d2c</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields><field>
	<name>BOOST_TIMEOUT_TRIG_DELAY</name>
	<description>Delay before generating next comparator clock after a timeout event on the P switch, allows inductor current to drop to zero
0x0: Disabled
0x1: 250 ns
0x2: 500 ns
0x3: 750 ns
0x4: 1000 ns (default)
0x5: 1250 ns
0x6: 1500 ns
0x7: 1750 ns
0x8: 2000 ns
0x9: 2250 ns
0xA: 2500 ns
0xB: 2750 ns
0xC: 3000 ns
0xD: 3250 ns
0xE: 3500 ns
0xF: 3750 ns</description>
	<bitRange>[20:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_PSW_TIMEOUT</name>
	<description>P switch timeout, if switch is closed longer than this a timeout is generated and the FSM is forced to the next state
0x0: Disabled
0x1: 250 ns
0x2: 500 ns
0x3: 750 ns
0x4: 1000 ns
0x5: 1250 ns
0x6: 1500 ns
0x7: 1750 ns
0x8: 2000 ns (default)
0x9: 2250 ns
0xA: 2500 ns
0xB: 2750 ns
0xC: 3000 ns
0xD: 3250 ns
0xE: 3500 ns
0xF: 3750 ns</description>
	<bitRange>[16:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_NSW_TIMEOUT</name>
	<description>N switch timeout, if switch is closed longer than this a timeout is generated and the FSM is forced to the next state
0x0: Disabled
0x1: 125 ns
0x2: 250 ns
0x3: 375 ns
0x4: 500 ns
0x5: 625 ns
0x6: 750 ns (default)
0x7: 875 ns
0x8: 1000 ns
0x9: 1125 ns
0xA: 1250 ns
0xB: 1375 ns
0xC: 1500 ns
0xD: 1625 ns
0xE: 1750 ns
0xF: 1875 ms</description>
	<bitRange>[12:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_OK_CLR_COUNT</name>
	<description>Number of subsequent V_NOK events before BOOST_VLED_OK is reset
0x0: 2
0x1: 4
0x2: 8 (default)
0x3: 15</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_IDLE_CLK_DIV</name>
	<description>Determines times between comparator samples when converter is idle
0x0 = 250 ns
0x1 = 500 ns (default)
0x2 = 1000 ns
0x3 = 2000 ns</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_VLED_TRIM</name>
	<description>Trim setting for boost converter, sets deviation from nominal output voltage (4 V)
0x0: -75 mV
0x1: -50 mV
0x2: -25 mV
0x3: 0 mV (default)
0x4: 25 mV
0x5: 50 mV
0x6: 75 mV
0x7: 100 mV</description>
	<bitRange>[4:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_VLED_SEL</name>
	<description>Voltage selection for boost converter, sets nominal output voltage
0x0: 4.50V (default)
0x1: 4.75V
0x2: 5.00V
0x3: 5.00V</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOOST_CTRL_REG1</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0003fbe4</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>BOOST_CUR_LIM_SLEEP_FIXED</name>
	<description>Enable fixed current iso dynamic current in sleep mode
0x0: Use dynamic current control
0x1: Use fixed current as defined in BOOST_CUR_LIM_SLEEP (default)</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_CUR_LIM_SLEEP</name>
	<description>Fixed inductor peak current limit in sleep mode
I = 30 mA * (1 + N), default 960 mA</description>
	<bitRange>[16:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_CUR_LIM_STEP</name>
	<description>Step size taken by automatic inductor peak current limit control
0x0: 0 (disabled)
0x1: 1
0x2: 2 (default)
0x3: 3</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_CUR_LIM_MAX</name>
	<description>Maximum inductor peak current limit
I = 30 mA * (1 + N), default 960 mA</description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_CUR_LIM_MIN</name>
	<description>Minimum inductor peak current limit
I = 30 mA * (1 + N), default 150 mA</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOOST_STATUS_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00024000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>BOOST_COMP_TRIM</name>
	<description>Actual P side comparator trim value</description>
	<bitRange>[23:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_IDLE</name>
	<description>Converter idle</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_CUR_LIM</name>
	<description>Actual inductor peak current limit</description>
	<bitRange>[16:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_COMP_P_DYN_P</name>
	<description>P output of P side dynamic comparator</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_COMP_P_DYN_N</name>
	<description>N output of P side dynamic comparator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_COMP_P_CONT</name>
	<description>Output of P side continuous time comparator</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_COMP_N_CONT</name>
	<description>Output of N side continuous time comparator</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_TIMEOUT_PSW</name>
	<description>Timeout on P switch occurred</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_TIMEOUT_NSW</name>
	<description>Timeout on N switch occurred</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_VOUT_NOK</name>
	<description>NOK output of output voltage comparator</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_VOUT_OK</name>
	<description>OK output of output voltage comparator</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_SW_STATE</name>
	<description>State of boost converter switches
0x0: Both off
0x1: P switch on
0x2: N switch on
0x3: Undefined</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_STARTUP_COMPLETE</name>
	<description>Indicates if the converter is enabled and the startup counter has expired (internal biasing settled)</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_VLED_OK</name>
	<description>Indicates that V_LED is above its threshold, reset after too many subsequent V_NOK events</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BOOST_TEST_CTRL_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00f00200</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>BOOST_ILOAD_SEL_TEST</name>
	<description>Test mode control for 20mA test-mux
0x0: All switches open (Default)
0x1: Sink 20mA from LX for testing PMOS
0x2: Sink 20mA from V_LED
0x3: Source 20mA into LX for testing NMOS</description>
	<bitRange>[28:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_LSSUP_TRIM</name>
	<description>Trim low side supply voltage
V = 2 V + 300 mV * N, default 2.9 V</description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOST_HSGND_TRIM</name>
	<description>Trim high side ground
V = VBAT - (2 V + 400 mV * N), default VBAT - 3.2 V</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>VLED_PWR_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>VLED_PWR_FORCE</name>
	<description>Manual selection of VLED supply source, requires that VLED_PWR_MANUAL = 0x1
0x0: VLED not powered
0x1: VLED powered by VSYS
0x2: VLED powered by boost converter
0x3: N.A.</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VLED_PWR_MANUAL</name>
	<description>0x0: VLED supply source automatically selected
0x1: VLED supply source manually selected</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VLED_PWR_USE_VSYS_LVL</name>
	<description>Sets the condition for powering VLED from VSYS
0x0: VLED always powered from VSYS
0x1: VLED powered form VSYS if VSYS is near VLED, depending on vsys-comparator (Default)</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VLED_PWR_ENABLE</name>
	<description>0x0: VLED power controller disabled
0x1: VLED power controller enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VSYS_OK_DEBOUNCE</name>
	<description>Sets debounce time on VSYS comparator in steps of 1.024 ms
Note: actual delay can be up to one period of 1.024 ms clock shorter than programmed depending on alignment of comparator trip event and clock edge </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>VLED_PWR_STATUS_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>VLED_PWR_ALLOW_BOOST</name>
	<description>Indicates whether boost converter is blocked or not</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VLED_PWR_VSYS_CONNECTED</name>
	<description>Indicates that VSYS switch is closed</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VLED_PWR_SWITCH_CTRL_STATE</name>
	<description>State of the VLED power control FSM
0x0: Disabled
0x1: VSYS
0x2: Boost
0x3: N.A.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VSYS_OK_DEBOUNCED</name>
	<description>Output of VSYS OK debounce logic</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VSYS_OK</name>
	<description>Output of VSYS OK logic</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DMA</name>
	<version>1.0</version>
	<description>DMA registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x51000400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>280</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DMA0_A_START_REG</name>
	<description>Source address register of DMA channel 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA0_A_START</name>
	<description>Source start address of channel 0</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_B_START_REG</name>
	<description>Destination address register of DMA channel 0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA0_B_START</name>
	<description>Destination start address of channel 0</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_CTRL_REG</name>
	<description>Control register of DMA channel 0</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000: lowest priority
111: highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA0_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_IDX_REG</name>
	<description>Index pointer register of DMA channel 0</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA0_CTRL_REG[DMA_ON] has been cleared) and DMA0_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA0_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA0_INT_REG</name>
	<description>Interrupt length register of DMA channel 0</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA0_INT_REG has reached DMA0_IDX_REG and before DMA0_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_LEN_REG</name>
	<description>Transfer length register of DMA channel 0</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_LEN</name>
	<description>DMA channel's transfer length. DMA0_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_A_START_REG</name>
	<description>Source address register of DMA channel 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA1_A_START</name>
	<description>Source start address of channel 1</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_B_START_REG</name>
	<description>Destination address register of DMA channel 1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA1_B_START</name>
	<description>Destination start address of channel 1</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_CTRL_REG</name>
	<description>Control register of DMA channel 1</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA1_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_IDX_REG</name>
	<description>Index pointer register of DMA channel 1</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA1_CTRL_REG[DMA_ON] has been cleared) and DMA1_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA1_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA1_INT_REG</name>
	<description>Interrupt length register of DMA channel 1</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA1_INT_REG has reached DMA1_IDX_REG and before DMA1_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_LEN_REG</name>
	<description>Transfer length register of DMA channel 1</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_LEN</name>
	<description>DMA channel's transfer length. DMA1_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_A_START_REG</name>
	<description>Source address register of DMA channel 2</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA2_A_START</name>
	<description>Source start address of channel 2</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_B_START_REG</name>
	<description>Destination address register of DMA channel 2</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA2_B_START</name>
	<description>Destination start address of channel 2</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_CTRL_REG</name>
	<description>Control register of DMA channel 2</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address
0 = do not increment
1 = increment according value of BW</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA2_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_IDX_REG</name>
	<description>Index pointer register of DMA channel 2</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA2_CTRL_REG[DMA_ON] has been cleared) and DMA2_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA2_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA2_INT_REG</name>
	<description>Interrupt length register of DMA channel 2</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA2_INT_REG has reached DMA2_IDX_REG and before DMA2_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_LEN_REG</name>
	<description>Transfer length register of DMA channel 2</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_LEN</name>
	<description>DMA channel's transfer length. DMA2_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_A_START_REG</name>
	<description>Source address register of DMA channel 3</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA3_A_START</name>
	<description>Source start address of channel 3</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_B_START_REG</name>
	<description>Destination address register of DMA channel 3</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA3_B_START</name>
	<description>Destination start address of channel 3</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_CTRL_REG</name>
	<description>Control register of DMA channel 3</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA3_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_IDX_REG</name>
	<description>Index pointer register of DMA channel 3</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA3_CTRL_REG[DMA_ON] has been cleared) and DMA3_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA3_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA3_INT_REG</name>
	<description>Interrupt length register of DMA channel 3</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA3_INT_REG has reached DMA3_IDX_REG and before DMA3_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_LEN_REG</name>
	<description>Transfer length register of DMA channel 3</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_LEN</name>
	<description>DMA channel's transfer length. DMA3_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_A_START_REG</name>
	<description>Source address register of DMA channel 4</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA4_A_START</name>
	<description>Source start address of channel 4</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_B_START_REG</name>
	<description>Destination address register of DMA channel 4</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA4_B_START</name>
	<description>Destination start address of channel 4</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_CTRL_REG</name>
	<description>Control register of DMA channel 4</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA4_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_IDX_REG</name>
	<description>Index pointer register of DMA channel 4</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA4_CTRL_REG[DMA_ON] has been cleared) and DMA4_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA4_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA4_INT_REG</name>
	<description>Interrupt length register of DMA channel 4</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA4_INT_REG has reached DMA4_IDX_REG and before DMA4_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_LEN_REG</name>
	<description>Transfer length register of DMA channel 4</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_LEN</name>
	<description>DMA channel's transfer length. DMA4_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_A_START_REG</name>
	<description>Source address register of DMA channel 5</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA5_A_START</name>
	<description>Source start address of channel 5</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_B_START_REG</name>
	<description>Destination address register of DMA channel 5</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA5_B_START</name>
	<description>Destination start address of channel 5</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_CTRL_REG</name>
	<description>Control register of DMA channel 5</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA5_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_IDX_REG</name>
	<description>Index pointer register of DMA channel 5</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA5_CTRL_REG[DMA_ON] has been cleared) and DMA5_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA5_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA5_INT_REG</name>
	<description>Interrupt length register of DMA channel 5</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA5_INT_REG has reached DMA5_IDX_REG and before DMA5_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_LEN_REG</name>
	<description>Transfer length register of DMA channel 5</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_LEN</name>
	<description>DMA channel's transfer length. DMA5_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_A_START_REG</name>
	<description>Source address register of DMA channel 6</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA6_A_START</name>
	<description>Source start address of channel 6</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_B_START_REG</name>
	<description>Destination address register of DMA channel 6</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA6_B_START</name>
	<description>Destination start address of channel 6</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_CTRL_REG</name>
	<description>Control register of DMA channel 6</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA6_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_IDX_REG</name>
	<description>Index pointer register of DMA channel 6</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA6_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA6_CTRL_REG[DMA_ON] has been cleared) and DMA6_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA6_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA6_INT_REG</name>
	<description>Interrupt length register of DMA channel 6</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA6_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA6_INT_REG has reached DMA6_IDX_REG and before DMA6_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA6_LEN_REG</name>
	<description>Transfer length register of DMA channel 6</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA6_LEN</name>
	<description>DMA channel's transfer length. DMA6_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_A_START_REG</name>
	<description>Source address register of DMA channel 7</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA7_A_START</name>
	<description>Source start address of channel 7</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_B_START_REG</name>
	<description>Destination address register of DMA channel 7</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DMA7_B_START</name>
	<description>Destination start address of channel 7</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_CTRL_REG</name>
	<description>Control register of DMA channel 7</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel de-asserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = '0') and results into requesting the bus continuously during the whole transfer, to speed-up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched-on again, in order to perform a new transfer.
NOTE: This bit-field is overruled to '1' when channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts, according to the following configuration:
00 = Bursts are disabled
01 = Bursts of 4 are enabled
10 = Bursts of 8 are enabled
11 = Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, etc ...
1: DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.
NOTE: This bit-field is overruled to '0' when channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.
NOTE: This bit-field is overruled to '0' when channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW=&quot;00&quot; ; by 2, when BW=&quot;01&quot; ; by 4, when BW=&quot;10&quot;)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)
NOTE: This bit-field is overruled to '0' when channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the SW has to check that the reading of DMA7_CTRL_REG.DMA_ON returns 0, before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_IDX_REG</name>
	<description>Index pointer register of DMA channel 7</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA7_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA7_CTRL_REG[DMA_ON] has been cleared) and DMA7_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA7_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA7_INT_REG</name>
	<description>Interrupt length register of DMA channel 7</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA7_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA7_INT_REG has reached DMA7_IDX_REG and before DMA7_IDX_REG is incremented. The interrupt enable bit of this this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA7_LEN_REG</name>
	<description>Transfer length register of DMA channel 7</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA7_LEN</name>
	<description>DMA channel's transfer length. DMA7_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_CLEAR_INT_REG</name>
	<description>DMA Interrupt clear register</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>DMA_RST_IRQ_CH7</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 7 ; writing a 0 will have no effect</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH6</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 6 ; writing a 0 will have no effect</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH5</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 5 ; writing a 0 will have no effect</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH4</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 4 ; writing a 0 will have no effect</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH3</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 3 ; writing a 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH2</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 2 ; writing a 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH1</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 1 ; writing a 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH0</name>
	<description>Writing a 1 will reset the status bit of DMA_INT_STATUS_REG for channel 0 ; writing a 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>DMA_INT_MASK_REG</name>
	<description>DMA Interrupt mask register</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>DMA_IRQ_ENABLE7</name>
	<description>0: disable interrupts on channel 7
1: enable interrupts on channel 7</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE6</name>
	<description>0: disable interrupts on channel 6
1: enable interrupts on channel 6</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE5</name>
	<description>0: disable interrupts on channel 5
1: enable interrupts on channel 5</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE4</name>
	<description>0: disable interrupts on channel 4
1: enable interrupts on channel 4</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE3</name>
	<description>0: disable interrupts on channel 3
1: enable interrupts on channel 3</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE2</name>
	<description>0: disable interrupts on channel 2
1: enable interrupts on channel 2</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE1</name>
	<description>0: disable interrupts on channel 1
1: enable interrupts on channel 1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE0</name>
	<description>0: disable interrupts on channel 0
1: enable interrupts on channel 0</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_INT_STATUS_REG</name>
	<description>DMA Interrupt status register</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA_BUS_ERR7</name>
	<description>0: No bus error response is detected for channel 7
1: Bus error response detected for channel 7
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started. It is also noted that when channel 7 is configured as &quot;trusted&quot; (in Secure Boot mode), this bit-field is overruled to '0', masking the bus error status reported to the user.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR6</name>
	<description>0: No bus error response is detected for channel 6
1: Bus error response detected for channel 6</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR5</name>
	<description>0: No bus error response is detected for channel 5
1: Bus error response detected for channel 5</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR4</name>
	<description>0: No bus error response is detected for channel 4
1: Bus error response detected for channel 4
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR3</name>
	<description>0: No bus error response is detected for channel 3
1: Bus error response detected for channel 3
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR2</name>
	<description>0: No bus error response is detected for channel 2
1: Bus error response detected for channel 2
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR1</name>
	<description>0: No bus error response is detected for channel 1
1: Bus error response detected for channel 1
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR0</name>
	<description>0: No bus error response is detected for channel 0
1: Bus error response detected for channel 0
NOTE: This bit-field is auto-clear and it is initialized to '0' as soon as a new transfer is started.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH7</name>
	<description>0: IRQ on channel 7 is not set
1: IRQ on channel 7 is set</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH6</name>
	<description>0: IRQ on channel 6 is not set
1: IRQ on channel 6 is set</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH5</name>
	<description>0: IRQ on channel 5 is not set
1: IRQ on channel 5 is set</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH4</name>
	<description>0: IRQ on channel 4 is not set
1: IRQ on channel 4 is set</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH3</name>
	<description>0: IRQ on channel 3 is not set
1: IRQ on channel 3 is set</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH2</name>
	<description>0: IRQ on channel 2 is not set
1: IRQ on channel 2 is set</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH1</name>
	<description>0: IRQ on channel 1 is not set
1: IRQ on channel 1 is set</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH0</name>
	<description>0: IRQ on channel 0 is not set
1: IRQ on channel 0 is set</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA_REQ_MUX_REG</name>
	<description>DMA channels peripherals mapping register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA67_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
The first DMA request is mapped on channel 6 and the second on channel 7. Please refer to the description of DMA01_SEL bit-field for the exact peripherals' mapping.
NOTE: When channel DMA7 is configured as secure channel, it cannot support any peripheral requests, since DREQ_MODE is disabled automatically, overruling the corresponding bit-field of DMA7_CTRL_REG.</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA45_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
The first DMA request is mapped on channel 4 and the second on channel 5. Please refer to the description of DMA01_SEL bit-field for the exact peripherals' mapping.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA23_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
The first DMA request is mapped on channel 2 and the second on channel 3. Please refer to the description of DMA01_SEL bit-field for the exact peripherals' mapping.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA01_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
The first DMA request is mapped on channel 0 and the second on channel 1 and the peripherals supported are listed below. Note that in the following list, the &quot;rx&quot; implies a Peripheral-to-Memory transfer and the &quot;tx&quot; a Memory-to-Peripheral transfer.
0x0: SPI_rx / SPI_tx
0x1: SP2_rx / SPI2_tx
0x2: UART_rx / UART_tx
0x3: UART2_rx / UART2_tx
0x4: I2C_rx / I2C_tx
0x5: I2C2_rx / I2C2_tx
0x6: USB_rx / USB_tx
0x7: UART3_rx / UART3_tx
0x8: PCM / PCM
0x9: SRC_rx / SRC_tx
0xA: SPI3_rx / SPI3_tx
0xB: I2C3_rx / I2C3_tx
0xC: GP_ADC / APP_ADC
0xD: SRC2_rx / SRC2_tx
0xE: I3C_rx / I3C_tx
0xF: None

NOTE: If any of the two available peripheral selector fields (DMA01_SEL, DMA23_SEL) have the same value, the lesser significant selector has higher priority and will control the DMA acknowledge signal driven to the selected peripheral. Hence, if DMA01_SEL = DMA23_SEL, the channels 0 and 1 will provide the Rx and Tx DMA acknowledge signals for the selected peripheral.
Consequently, it is suggested to assign the intended peripheral value to a unique selector field. Exception is the SRC, for which the mapping of the same peripheral option to more than one channel pairs may be intended (e.g. for stereo mode).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_RESET_INT_MASK_REG</name>
	<description>DMA Reset Interrupt mask register</description>
	<addressOffset>0x00000114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>DMA_RESET_IRQ_ENABLE7</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 7, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE6</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 6, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE5</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 5, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE4</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 4, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE3</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 3, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE2</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 2, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE1</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 1, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE0</name>
	<description>Writing a '1' will disable the IRQs in the DMA channel 0, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>DMA_SET_INT_MASK_REG</name>
	<description>DMA Set Interrupt mask register</description>
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>DMA_SET_IRQ_ENABLE7</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 7, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE6</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 6, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE5</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 5, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE4</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 4, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE3</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 3, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE2</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 2, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE1</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 1, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE0</name>
	<description>Writing a '1' will enable the IRQs in the DMA channel 0, writing a '0' has no effect. Reading returns always '0'.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DSI2</name>
	<version>1.0</version>
	<description>DSI2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x51001300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>432</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DSI2_CFG_AUTOINSERT_EOTP_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>AUTOINSERT_EOTP</name>
	<description>Enables the Host Controller to automatically insert an EoTp short packet when switching from HS to LP mode.
1b0 eotp is not automatically inserted
1b1 eotp is automatically inserted</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_BTA_H_TO_COUNT_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>BTA_H_TO_COUNT</name>
	<description>Host Bust Turn Around (BTA) Timout. Sets the value of the DSI-2 Host Bus Turn Around timeout in clk clock periods that once reached will initiate a timeout error. A value of 0x000000 disables the timeout.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_CLK_LANE_EN_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CLK_LANE_EN</name>
	<description>Forces PHY Enable n signals to 1'b1 when register is set to 1. See the DSI-2
Controller User Guide description of the input port cfg clk lane en for additional information.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_CONTINUOUS_HS_CLK_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CONTINUOUS_HS_CLK</name>
	<description>Sets the Host Controller into non-continuous MIPI clock mode. When in
non-continuous clock mode, the high speed clock will transistion into low power mode between
transmissions. 1'b0 - Non-Continuous high speed clock 1'b1 - Continuous high speed clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_DATA_LANE_EN_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>DATA_LANE_EN</name>
	<description>Forces PHY Enable n signals to 1'b1 when register is set to 1. See the DSI-2
Controller User Guide description of the input port cfg data lane en for additional informa-
tion.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_DISABLE_BURST_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DISABLE_BURST</name>
	<description>Disables packets combined into a burst. Normal DSI-2 operation is to combine packets and send as a burst without returning to LP mode between each packet.
1b0 packets are combined and sent as a burst. (Default DSI-2 behavior)
1b1 Controller returns to LP mode between each packet.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_DISBL_RX_CRC_CHECK_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>DISABLE_RX_CRC_CHECK</name>
	<description>Prevents the Host from checking the payload CRC in long packets sent from the Peripheral. This input should be set if the peripheral does not support CRC generation.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_EXT_CMDS_AFT_EOTP_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>EXTRA_CMDS_AFTER_EOTP</name>
	<description>Configures the DSI-2 Host Controller to send extra End Of Transmission Packets after the end of a packet. The value of cfg_extra_cmd_after_eotp is the number of extra EOTP packets sent.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_HTX_TO_COUNT_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>HTX_TO_COUNT</name>
	<description>Host HS TX Timeout count, HS TX Timeout. Sets the value of the DSI-2 host High Speed TX timeout count in clk clock periods that once reached will initiate a timeout error and follow the recovery procedure documented in the DSI-2 specification. A value of 0x000000 disables the timeout.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_IRQ_MASK</name>
	<description>Status of APB to packet interface, reading will clear IRQ status 1 and 2</description>
	<addressOffset>0x000001a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IRQ_HS_TX_TIMEOUT</name>
	<description>host bta timeout, host controller host bta timeout port</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_LP_RX_TIMEOUT</name>
	<description>low power rx timeout, host controller lp rx timeout port</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_HOST_BTA_TIMEOUT</name>
	<description>high speed tx timeout, host controller hs tx timeout port</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_MAP_DIRECTORY</name>
	<description>map directory to dsi host controller status out port bit descriptions</description>
	<bitRange>[28:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_RX_PACKET_RCVD</name>
	<description>All RX packet payload data has been received</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_RX_HEADER_RCVD</name>
	<description>RX packet header has been received</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_RX_FIFO_UNDERFLOW</name>
	<description>RX fifo underflow</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_RX_FIFO_OVERFLOW</name>
	<description>RX fifo overflow</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_TX_FIFO_UNDERFLOW</name>
	<description>TX fifo underflow</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_TX_FIFO_OVERFLOW</name>
	<description>TX fifo overflow</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_DPHY_DIRECTION</name>
	<description>DPHY direction
0 - TX had control
1 - RX has control</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_TX_DONE</name>
	<description>TX packet done</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_STATE_NOT_IDLE</name>
	<description>State machine not idle</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_IRQ_MASK2</name>
	<description>Status of APB to packet interface part 2, read part 2 first then dsi2 host irq 2</description>
	<addressOffset>0x000001ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>IRQ_CRC_ERROR</name>
	<description>CRC error</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_MULTI_BIT_ECC_ERROR</name>
	<description>TX packet done</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_SINGLE_BIT_ECC_ERROR</name>
	<description>Single bit ecc error</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_IRQ_STATUS</name>
	<description>Status of APB to packet interface, reading will clear IRQ status 1 and 2</description>
	<addressOffset>0x000001a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IRQ_HS_TX_TIMEOUT</name>
	<description>host bta timeout, host controller host bta timeout port</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_LP_RX_TIMEOUT</name>
	<description>low power rx timeout, host controller lp rx timeout port</description>
	<bitRange>[30:30]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_HOST_BTA_TIMEOUT</name>
	<description>high speed tx timeout, host controller hs tx timeout port</description>
	<bitRange>[29:29]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_MAP_DIRECTORY</name>
	<description>map directory to dsi host controller status out port bit descriptions</description>
	<bitRange>[28:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_RX_PACKET_RCVD</name>
	<description>All RX packet payload data has been received</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_RX_HEADER_RCVD</name>
	<description>RX packet header has been received</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_RX_FIFO_UNDERFLOW</name>
	<description>RX fifo underflow</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_RX_FIFO_OVERFLOW</name>
	<description>RX fifo overflow</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_TX_FIFO_UNDERFLOW</name>
	<description>TX fifo underflow</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_TX_FIFO_OVERFLOW</name>
	<description>TX fifo overflow</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_DPHY_DIRECTION</name>
	<description>DPHY direction
0 - TX had control
1 - RX has control</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_TX_DONE</name>
	<description>TX packet done</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_STATE_NOT_IDLE</name>
	<description>State machine not idle</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_IRQ_STATUS2</name>
	<description>Status of APB to packet interface part 2, read part 2 first then dsi2 host irq 2</description>
	<addressOffset>0x000001a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>IRQ_CRC_ERROR</name>
	<description>CRC error</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_MULTI_BIT_ECC_ERROR</name>
	<description>TX packet done</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_SINGLE_BIT_ECC_ERROR</name>
	<description>Single bit ecc error</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_LRX_H_TO_COUNT_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>LRX_H_TO_COUNT</name>
	<description>Host Low Power RX Timeout, LP_RX-H Timeout. Sets the value of the DSI-2 Low Power RX timeout count in clk clock periods that once reached will initiate a timeout error and follow the recovery procedure documented in the DSI-2 specification. A value of 0x000000 disables the timeout.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_NUM_LANES_REG</name>
	<description>configure numer of active lanes</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>NUM_LANES</name>
	<description>Sets the number of active lanes that are to be used for transmitting data. 4'b0000
- No active lanes (reset default)
4'b0001 - 1 Active Lanes
4'b0010 - 2 Active Lanes
4'b0011 - 3 Active Lanes (not supported)
4'b0100 - 4 Active Lanes (not supported)</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_PACKET_CONTROL</name>
	<description>Tx packet control register</description>
	<addressOffset>0x00000184</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>PKT_BTA_ONLY</name>
	<description>Perform BTA only, no packet tx</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PKT_BTA_AFTER_SENT</name>
	<description>Perform BTA after packet is sent</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PKT_LP_OR_HS</name>
	<description>low power or high speed</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PKT_HEADER_DTYPE</name>
	<description>Packet header DSI Data Type</description>
	<bitRange>[23:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PKT_VC</name>
	<description>Virtual channel</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PKT_WC</name>
	<description>Packet word count</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_PKT_RD_LEVEL</name>
	<description>Read level of APB to pkt interface fifo</description>
	<addressOffset>0x00000194</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PKT_FIFO_RD_LEVEL</name>
	<description>Read level of APB to pkt interface fifo</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_PKT_RX_HEADER</name>
	<description>Packet 2 APB RX header</description>
	<addressOffset>0x0000019c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PKT_RX_HEADER_DTYPE</name>
	<description>Packet header DSI Data Type</description>
	<bitRange>[23:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_RX_VC</name>
	<description>Virtual channel</description>
	<bitRange>[17:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_RX_WC</name>
	<description>Packet word count</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_PKT_RX_PAYLOAD</name>
	<description>Packet 2 APB RX payload</description>
	<addressOffset>0x00000198</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PKT_PKT_RX_PAYLOAD</name>
	<description>APB to pkt interface RX payload read</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_PKT_STATUS</name>
	<description>Status of APB to packet interface</description>
	<addressOffset>0x0000018c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>PKT_RX_PACKET_RCVD</name>
	<description>All RX packet payload data has been received</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_RX_HEADER_RCVD</name>
	<description>RX packet header has been received</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_RX_FIFO_UNDERFLOW</name>
	<description>RX fifo underflow</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_RX_FIFO_OVERFLOW</name>
	<description>RX fifo overflow</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_TX_FIFO_UNDERFLOW</name>
	<description>TX fifo underflow</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_TX_FIFO_OVERFLOW</name>
	<description>TX fifo overflow</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_DPHY_DIRECTION</name>
	<description>DPHY direction
0 - TX had control
1 - RX has control</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_TX_DONE</name>
	<description>TX packet done</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKT_STATE_NOT_IDLE</name>
	<description>State machine not idle</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_PKT_WR_LEVEL</name>
	<description>Write level of APB to pkt interface fifo</description>
	<addressOffset>0x00000190</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PKT_FIFO_WR_LEVEL</name>
	<description>Write level of APB to pkt interface fifo</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_RX_ERROR_STATUS_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007fb</resetMask>
	<fields><field>
	<name>BTA_TIMEOUT</name>
	<description>BTA timeout</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>REV_LP_DATA_RX_TIMEOUT</name>
	<description>Reverse Low Power Data receive timeout</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HS_FWD_TX_TIMEOUT</name>
	<description>High Speed forward TX timeout</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRC_ERR</name>
	<description>CRC error</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ECC_SINGLE_BIT_ERR_POS</name>
	<description>Bit position for ECC single bit error</description>
	<bitRange>[6:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ECC_MULTI_BIT_ERR</name>
	<description>ECC multi bit error</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ECC_SINGLE_BIT_ERR</name>
	<description>ECC single bit error</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_SEND_PACKET</name>
	<description>Tx send packet</description>
	<addressOffset>0x00000188</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CFG_SEND_PACKET</name>
	<description>Tx send packet, writing to this register causes the packet described in dsi2 host
pkt control to be sent.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_STATUS_OUT_REG</name>
	<description>Contains the status of the status register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LAST_RCVD_TRIGGER</name>
	<description>Last received Trigger. Current status of the RxTriggerEsc[3:0] from the TX DPHY. Each bit represents one of the possible 4 trigger values was received but unfortunately the MIPI DPHY spec does not define with RxTriggerEsc bit represents which trigger value so the value will be DPHY provider dependent. For Mixel DPHYs the values are as follows:
4b0001 reset trigger ( 01100010 )
4b0010 unknown trigger 3 ( 01011101 )
4b0100 unknown trigger 4 ( 00100001 )
4b1000 unknown trigger 5 ( 10100000 )</description>
	<bitRange>[19:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DSI2_PROT_VIOLATION</name>
	<description>Protocol violation error from peripheral error report, cleared upon read</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INVALID_TRANS_LENGTH</name>
	<description>Transmission length error from peripheral error report, cleared upon read</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DSI2_VC_ID_INVALID</name>
	<description>Invalid VC from peripheral error report, cleared upon read</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DSI2_DT_NOT_RECOGNIZED</name>
	<description>Invalid data type from peripheral error report, cleared upon read</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LP_CHECKSUM_ERROR</name>
	<description>Checksum error (long packet only) from peripheral error report, cleared upon read</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ECC_MULTI_BIT_ERROR</name>
	<description>ECC multi-bit error from peripheral error report (not corrected), cleared upon read</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ECC_1BIT_ERROR</name>
	<description>ECC single bit error from peripheral error report (and corrected), cleared upon read</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CONTENTION_DETECTED</name>
	<description>Contention Detection from peripheral error report, cleared upon read</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FALSE_CTRL_ERROR</name>
	<description>False Control Error from peripheral error report, cleared upon read</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PERIPH_TIMEOUT_ERROR</name>
	<description>Peripheral Timeout error from peripheral error report, cleared upon read</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LP_TRANS_SYNC_ERROR</name>
	<description>Low Power Transmit Sync error from peripheral error report, cleared upon read</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ESC_MODE_ENTRY_CMD_ERROR</name>
	<description>Escape Mode Entry Command Error from peripheral error report, cleared upon read</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EOT_SYNC_ERROR</name>
	<description>End of Transmission Sync Error from peripheral error report, cleared upon read</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SOT_SYNC_ERROR</name>
	<description>Start of Transmission Sync Error from peripheral error report, cleared upon read</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SOT_ERROR</name>
	<description>Start of Transmission Error from peripheral error report, cleared upon read</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_TWAKEUP_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>TWAKEUP</name>
	<description>PHY Twakeup timing parameter. Sets the number of clk_esc clock periods to keep a clock or data lane in Mark-1 state after exiting ULPS. The MIPI PHY spec (D-PHY and C-PHY) requires a minimum of 1ms in Mark-1 state after leaving ULPS.

Because each lane requires a wakeup timer, the default hardware configuration ignores the lower 8 bits to reduce logic and area. This gives a timer resolution of 256 esc clocks. If higher resolution is required, the controller can be delivered with full 19 bit support at the expense of extra logic and area.</description>
	<bitRange>[18:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_TX_GAP_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>TX_GAP</name>
	<description>Sets the number of byte clock periods (clk input) that the controller will wait after the clock lane has been put into LP mode before enabling the clock lane for HS mode again.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_TX_PAYLOAD</name>
	<description>TX Payload data write register</description>
	<addressOffset>0x00000180</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CFG_TX_PAYLOAD</name>
	<description>Tx Payload data write register. Writes to this registers load the payload fo with
32 bit values.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_T_POST_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>T_POST</name>
	<description>Sets the number of byte clock periods (clk input) to wait before putting the clock lane into LP mode after the data lanes have been put into LP mode.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_T_PRE_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>T_PRE</name>
	<description>Sets the number of byte clock periods (clk input) that the controller will wait after enabling the clock lane for HS operation before enabling the data lanes for HS operation.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_BLLP_MODE</name>
	
	<addressOffset>0x00000140</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>VID_BLLP_MODE</name>
	<description>Optimize bllp periods to Low Power mode when possible
0 blanking packets are sent during BLLP periods
1 LP mode is used for BLLP periods</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_ENABLE</name>
	
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>VID_ENABLE</name>
	<description>Enables the video interface
0 = video interface off; all packets go through rx packet interface
1 = video interface on; video packets routed out video interface</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_HBP</name>
	
	<addressOffset>0x0000012c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_HBP</name>
	<description>Sets the DSI-2 packet payload size, in bytes, of the horizontal back porch blanking packet. This input is ignored if cfg_vid_override = 1b0.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_HFP</name>
	
	<addressOffset>0x00000128</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_HFP</name>
	<description>Sets the DSI-2 packet payload size, in bytes, of the horizontal front porch blanking packet. This input is ignored if cfg_vid_override = 1b0.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_HSA</name>
	
	<addressOffset>0x00000130</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_HSA</name>
	<description>Sets the DSI-2 packet payload size, in bytes, of the horizontal sync width filler blanking packet. This input is ignored if cfg_vid_override = 1b0.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_HSYNC_POLARITY</name>
	
	<addressOffset>0x00000118</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>VID_HSYNC_POLARITY</name>
	<description>Sets Polarity of vid_hsync input, 0 active low, 1 active high</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_OVERRIDE</name>
	
	<addressOffset>0x00000120</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>VID_OVERRIDE</name>
	<description>Overrides internal counters and uses values on configuration inputs.
1b0 Sync timing parameters are calculated off video input.
1b1 Sync timing parameters are set by cfg_vid_* configuration signals.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_PACKETS_P_LINE</name>
	
	<addressOffset>0x00000134</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>VID_PACKETS_P_LINE</name>
	<description>Sets the number of packets that will be sent for a video line. Default reset value is 3d1. Currently, only the default is supported:
3b001 Video Line is sent in a single packet</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_PIX_ALIGNMENT</name>
	
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>VID_PIX_ALIGNMENT</name>
	<description>Some RGB modes can be aligned either MSB or LSB onto the video_pX[35:0] inputs. See section DSI2 spec 4.9.5 for assignments.
0 LSB alignment
1 MSB alignment</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_PIX_FORMAT</name>
	
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>VID_PIX_FORMAT</name>
	<description>Sets the DSI-2 packet type of the pixels. Value is the actual data type sent across the MIPI interface.
0x0B Compressed Pixel Stream, 32-bit or 64-bit
0x0C - Loosely Packed Pixel Stream, 20-bit YCbCr, 4:2:2
0x1C - Packed Pixel Stream, 24-bit YCbCr, 4:2:2 format
0x2C - Packed Pixel Stream, 16-bit YCbCr, 4:2:2 format
0x0D - Packed Pixel Stream, 30-bit RGB, 10-10-10 format
0x1D - Packed Pixel Stream, 36-bit RGB, 12-12-12 format
0x3D - Packed Pixel Stream, 12-bit YCbCr, 4:2:0 format
0x0E - Packed Pixel Stream, 16-bit RGB, 5-6-5 format
0x1E - Packed Pixel Stream, 18-bit RGB, 6-6-6
0x2E - Loosely Packed Pixel Stream, 18-bit RGB, 6-6-6
0x3E - Packed Pixel Stream, 24-bit RGB, 8-8-8</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_PIX_PAYLOAD_SIZE</name>
	
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_PIX_PAYLOAD_SIZE</name>
	<description>The number of bytes in a video payload packet. Normally this can be set to zero and let the payload size to be calculated based on cfg_vid_pixels_packet. However, in cases like DSC operation where the number of bytes may not be a multiple of 32 or 64, cfg_vid_pixel_payload_size should be set to reflect the total number of bytes to be sent.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_PIX_P_PACKET</name>
	
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_PIX_P_PACKET</name>
	<description>Sets the number of pixels that are sent in a packet for each video line. If cfg_vid_packets_per_line is set to 3d1, cfg_vid_pixels_per_packet would be set to the total pixels for each video line. If cfg_vid_packets_per_line is set to 2d2, then this should be set to half the number of pixels on a video line.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_START_DELAY</name>
	
	<addressOffset>0x00000124</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_START_DELAY</name>
	<description>In order to optimize DSI-2 utility, the video interface buffers a certain number of pixels before initiating a DSI-2 packet. This configuration port controls the number of clk clock cycles to wait before requesting the DSI-2 Host Controller to start sending data.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_USE_NULL_PKT_BLLP</name>
	
	<addressOffset>0x00000144</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>VID_USE_NULL_PKT_BLLP</name>
	<description>Selects type of blanking packet to be sent during bllp region
0 - Blanking packet used in bllp region
1 - Null packet used in bllp region</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_VACTIVE</name>
	
	<addressOffset>0x00000148</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_VACTIVE</name>
	<description>Sets the number of lines in the vertical active area. This input is ignored if cfg_vid_override = 1b0.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_VBP</name>
	
	<addressOffset>0x00000138</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_VBP</name>
	<description>Sets the number of lines in the vertical back porch. This input is ignored if cfg_vid_override = 1b0.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_VC</name>
	
	<addressOffset>0x0000014c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>VID_VC</name>
	<description>Sets the Virtual Channel (VC) of packets that will be sent to the receive packet interface. Unless cfg_disable_vc_check is set, packets with VC not equal to this value are discarded and the &quot;DSI-2 VC ID Invalid&quot; bit (bit 12) in the DSI-2 error report is set.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_VFP</name>
	
	<addressOffset>0x0000013c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VID_VFP</name>
	<description>Sets the number of lines in the vertical front porch. This input is ignored if cfg_vid_override = 1b0.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_VIDEO_MODE</name>
	
	<addressOffset>0x0000011c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>VID_VID_VIDEO_MODE</name>
	<description>Select DSI-2 video mode that the host VID module should generate packets for.
2b00 Non-Burst mode with Sync Pulses
2b01 Non-Burst mode with Sync Events
2b10 Burst Mode
2b11 Reserved, not valid</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_CFG_VID_VSYNC_POLARITY</name>
	
	<addressOffset>0x00000114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>VID_VSYNC_POLARITY</name>
	<description>Sets polarity of vid_vsync input, 0 active low, 1 active high</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DSIDPHY_REG</name>
	<version>1.0</version>
	<description>DSIDPHY_REG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x51001500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DPHY_BIST_DC_OUT_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>DPHY_BIST_DC_OUT</name>
	<description>Output signal used in the DC test modes.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DPHY_BIST_ENBL_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>DPHY_BIST_ENBL</name>
	<description>Six-bit signal that enables the testing modes
[000000] Testing Disabled
[000001] HS-TX Sequence Test (1)
[000010] HS-TX Sequence Test (2)
[000011] HS-TX Sequence PRBS Test (1)
[000100] HS-TX Sequence PRBS Test (2)
[001001] HS-TX Test (1)
[001010] HS-TX Test (2)
[001011] HS-TX PRBS Test (1)
[001100] HS-TX PRBS Test (2)
[001101] HS-TX SDI Test
[010000] LP-TX LPDT Test
[010001] LP-TX DC Test
[010011] LP-RX DC Tests
[010100] LP-CD DC Tests</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DPHY_BIST_PATTERN_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DPHY_BIST_PATTERN</name>
	<description>This is the programmable test pattern used by BIST pattern generator and pattern matcher. The TEST_PATTERN bus value will be used as the payload data during the test, the HS SYNC token shouldnt be part of the TEST_PATTERN</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DPHY_CLK_DATA_LANE_PROG_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00c30608</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>UC_PRG_HS_TRAIL</name>
	<description>Clock Lane: Bits used to program T_CLK_TRAIL time in the end of high speed transmission mode</description>
	<bitRange>[25:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UC_PRG_HS_ZERO</name>
	<description>Clock Lane: Bits used to program T_CLK_ZERO time in the beginning of high speed transmission mode.</description>
	<bitRange>[20:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UC_PRG_HS_PREPARE</name>
	<description>Clock Lane: Bit used to program T_CLK_PREPARE time in the beginning of high speed transmission mode.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>U_PRG_HS_TRAIL</name>
	<description>Data Lane: Bits used to program T_HS_TRAIL time in the end of high speed transmission mode</description>
	<bitRange>[12:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>U_PRG_HS_ZERO</name>
	<description>Data Lane: Bits used to program T_HS_ZERO time in the beginning of high speed transmission mode.</description>
	<bitRange>[7:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>U_PRG_HS_PREPARE</name>
	<description>Data Lane: Bits used to program T_HS_PREPARE time in the beginning of high speed transmission mode</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DPHY_GLOBAL_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000037</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>ULPS_PLL_CTRL</name>
	<description>When the PHY enters ULPS, this input determines if the PLL will be powered down or not.
1b0: Feature disabled
1b1: Feature enabled [Default]</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ULPS_PHY_CTRL</name>
	<description>When the PHY enters ULPS, this input determines if the PHY will be powered down or not.
1b0: Feature disabled
1b1: Feature enabled [Default]</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LOCK_BYP</name>
	<description>When clock lane exits from ULPS, this input determines if the PLL LOCK signal will be used to gate the TxByteClkHS
1b0: PLL LOCK signal will gate TxByteClkHS clock [Default]
1b1: PLL LOCK signal will not gate TxByteClkHS clock, CIL based counter will be used to gate the TxByteClkHS</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUTO_PD_EN</name>
	<description>Powers down inactive lanes reported by CFG_NUM_LANES input bus.
1b0: inactive lanes are powered up and driving LP11.
1b1: inactive lanes are powered down [Default]</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PHY_PD</name>
	<description>Power Down input for PHY. When high, all blocks are powered down</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_PD</name>
	<description>Power-down signal When high, the PLL is powered down</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DPHY_PLL_CONTROL_REG</name>
	<description>PLL control</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0004f7fd</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields><field>
	<name>PLL_LOCK_LATCH</name>
	<description>Enable signal to use latched LOCK signal
1b0: LOCK&lt;= Normal LOCK signal [Default]
1b1: LOCK&lt;= Latched LOCK signal</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_BYPASS</name>
	<description>Enable signal to bypass PLL:
1b0: CLKOUT&lt;= CLKREF * ( M / ( N * O ))
1b1: CLKOUT&lt;= CLKEXT</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_TST</name>
	<description>Test Pins. Should be connected to chip configuration registers.
4'b1001: TST_PLL [Default] at normal operation</description>
	<bitRange>[18:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_CM</name>
	<description>Control M (feedback) divider</description>
	<bitRange>[14:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_CN</name>
	<description>Control N (input) divider</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_CO</name>
	<description>Control O (output) divider</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DPHY_STATUS_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>PLL_LOCK</name>
	<description>Lock Detect output. Asserted when PLL is frequency locked</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DPHY_TX_RCAL_REG</name>
	<description>On-chip termination control</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TX_RCAL</name>
	<description>On-chip termination control bits for manual calibration of HS-TX. Only active when BYPASS_RCAL asserted.
1b0: 20% higher than mid-range. Highest impedance setting.
1b1: Mid-range impedance setting.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_DPHY_CLK_RST_N_CTRL_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>DPHY_TX_ESC_CLK_DIV</name>
	<description>0: div/4, required with RCHS of 64MHz
1: div/6, required with RCHS of 92MHz
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DSI2_RESET_N</name>
	<description>Hold the DSI2 in reset. This should be set to 'b0 when configuring the DSI2 to avoid metastability</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_ERROR_STATUS_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>ROW_ACCESS_ERROR</name>
	<description>There was a row access error in the memory. A read and a write took place at the same cycle. Reason could be that the FIFO was almost full</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOST_BTA_TIMEOUT</name>
	<description>Host BTA timeout has occurred.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LS_RX_TIMEOUT</name>
	<description>Low Power RX timeout has occurred</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HS_TX_TIMEOUT</name>
	<description>High Speed transmit has timed out.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRC_ERROR</name>
	<description>CRC calculated on the received data does not match the CRC the transmitter sent at the end of the packet.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ECC_TWO_BIT_ERROR</name>
	<description>Single bit error in the packet header was detected and corrected.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ECC_ONE_BIT_ERROR</name>
	<description>Two packet header bit errors were detected and not corrected</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_BLANKING</name>
	<description>Only asserted if cfg_vid_video_mode is set to Burst Mode and cfg_vid_bllp_mode is set to 1b1. Asserted if not enough blanking time between end of a video line and the next vid_hsync. If video line transmission to the controller is occurring when a new vid_hsync is detected, this error signal will be asserted. This may indicate that VID_CLK is too fast, or that the cfg_vid_* parameters are incorrectly set.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_FIFO_UNDERFLOW</name>
	<description>Asserted if internal video FIFO underflows. The video rate might be lower than the MIPI rate. This may indicate that VID_CLK is too slow, or that the cfg_vid_* parameters are incorrectly set.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_FIFO_OVERFLOW</name>
	<description>Asserted if internal video FIFO overflows. The video rate might be higher than the MIPI rate or the delay for MIPI is long enough that the FIFO overflows. This may indicate that VID_CLK is too fast, or that the cfg_vid_* parameters are incorrectly set.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_SYNC_PULSE</name>
	<description>Only asserted if cfg_vid_video_mode is set to Non-Burst mode with Sync Pulses. New vid_hsync was detected while still sending blanking from last video line. This can occur if video rate is set to higher than MIPI rate and there is not enough cycles to transmit the video blanking after transmitting the video line. This may indicate that VID_CLK is too fast, or that the cfg_vid_* parameters are incorrectly set.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR</name>
	<description>Asserted if an error occurs during operation. Signal is asserted if any of the other vid_error signals (sync_pulse, fifo_overflow, fifo_underflow, or blanking) are asserted. Signal can be used as an enable to latch the other vid_error signals.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_INTERRUPT_EN_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>ROW_ACCESS_ERROR_IRQ_EN</name>
	<description>Enable Row Access Error IRQ</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOST_BTA_TIMEOUT_IRQ_EN</name>
	<description>Enable BTA timeout IRQ</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LP_RX_TIMEOUT_IRQ_EN</name>
	<description>Enable Low Power RX timeout IRQ</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HS_TX_TIMEOUT_IRQ_EN</name>
	<description>Enable High Speed TX timeout IRQ</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRC_ERROR_IRQ_EN</name>
	<description>Enable CRC error IRQ</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ECC_TWO_BIT_ERROR_IRQ_EN</name>
	<description>Enable ECC 2 bit error IRQ</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ECC_ONE_BIT_ERROR_IRQ_EN</name>
	<description>Enable ECC 1 bit error IRQ</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_BLANKING_IRQ_EN</name>
	<description>Enable VID blanking error IRQ</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_FIFO_UNDERFLOW_IRQ_EN</name>
	<description>Enable VID FIFO underflow IRQ</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_FIFO_OVERFLOW_IRQ_EN</name>
	<description>Enable VID FIFO overflow IRQ</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_SYNC_PULSE_IRQ_EN</name>
	<description>Enable VID sync pulse error IRQ</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VID_ERROR_IRQ_EN</name>
	<description>Enable VID error IRQ</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_MEMCTRL_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DSI2_MS</name>
	
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DSI2_MSE</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DSI2_TRIGGER_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TRIGGER_DATA</name>
	<description>Transmit trigger.
The format of trigger_send is as follows:
1b00 = Trigger 0 (Reset-Trigger)
1b01 = Trigger 1 ([Reserved])
1b10 = Trigger 2 ([Reserved])
1b11 = Trigger 3 ([Reserved])</description>
	<bitRange>[1:0]</bitRange>
	<access>writeOnce</access>
	</field></fields>
</register><register>
	<name>DSI2_ULPS_CFG_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>ULPS_ACTIVE</name>
	<description>Ultra Low Power State status. Bits assert high to indicate that the corresponding data lanes are in Ultra Low Power State.
Bit [0] Data lane 0
Bit [1] Data Lane 1</description>
	<bitRange>[5:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ULPS_CLK_ACTIVE</name>
	<description>Ultra Low Power State clock lane status. Asserted high to indicate that the clock lane is in Ultra Low Power State.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ULPS_ENABLE</name>
	<description>Ultra-Low Power State enable. When asserted (active high) the controller instructs the PHY to put the corresponding data lane into Ultra Low Power State.
Bit [0] Data lane 0
Bit [1] Data Lane 1</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ULPS_CLK_ENABLE</name>
	<description>Ultra-Low Power State enable for clock lane. When set (1'b1) the controller instructs the PHY to put the clock lane into Ultra Low Power State.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>EMMC</name>
	<version>1.0</version>
	<description>EMMC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30058000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>3952</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>EMMC_ADMA_ERR_STAT_R_REG</name>
	<description>This register stores the ADMA state during an ADMA error. This register is applicable for an SD/eMMC/UHS-II mode.</description>
	<addressOffset>0x00000054</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>ADMA_LEN_ERR</name>
	<description>ADMA Length Mismatch Error States
This error occurs in the following instances:
- While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length
- When the total data length cannot be divided by the block length
Values:
0x0 (NO_ERR): No Error
0x1 (ERROR): Error</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADMA_ERR_STATES</name>
	<description>ADMA Error States
These bits indicate the state of ADMA when an error occurs during ADMA data transfer.
Values:
0x0 (ST_STOP): Stop DMA - SYS_ADR register points to a location next to the error descriptor
0x1 (ST_FDS): Fetch Descriptor - SYS_ADR register points to the error descriptor
0x2 (UNUSED): Never set this state
0x3 (ST_TFR): Transfer Data - SYS_ADR register points to a location next to the error descriptor</description>
	<bitRange>[1:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_ADMA_SA_LOW_R_REG</name>
	<description>This register holds the lower 32-bit system address for DMA transfer. This register is applicable for an SD/eMMC/UHS-II mode.</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ADMA_SA_LOW</name>
	<description>ADMA System Address

These bits indicate the lower 32 bits of the ADMA system address.
- SDMA: If Host Version 4 Enable is set to 1, this register stores the system address of the data location
- ADMA2: This register stores the byte address of the executing command of the descriptor table
- ADMA3: This register is set by ADMA3. ADMA2 increments the address of this register that points to the next line, every time a Descriptor line is fetched.
</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_ARGUMENT_R_REG</name>
	<description>This register is used to configure the SD/eMMC command argument.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ARGUMENT</name>
	<description>Command Argument.
These bits specify the SD/eMMC command argument that is specified in bits 39-8 of the Command format.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_AT_CTRL_R_REG</name>
	<description>This register controls some aspects of tuning and auto-tuning features. Do not program this register when HOST_CTRL2_R.SAMPLE_C</description>
	<addressOffset>0x00000540</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x01000004</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>SWIN_TH_VAL</name>
	<description>Sampling window threshold value setting
The maximum value that can be set here depends on the length of delayline used for tuning. A delayLine with 128 taps can use values from 0x0 to 0x7F.
This field is valid only when SWIN_TH_EN is '1'. Should be programmed only when SAMPLE_CLK_SEL is '0'
     - 0x0 : Threshold values is 0x1, windows of length 1 tap and above can be selected as sampling window.
     - 0x1 : Threshold values is 0x2, windows of length 2 taps and above can be selected as sampling window.
     - 0x2 : Threshold values is 0x1, windows of length 3 taps and above can be selected as sampling window.
     - ........
     - 0x7F : Threshold values is 0x1, windows of length 127 taps and above can be selected as sampling window.     </description>
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POST_CHANGE_DLY</name>
	<description>Time taken for phase switching and stable clock output.
Specifies the maximum time (in terms of cclk cycles) that the delay line can take to switch its output phase after a change in tuning_cclk_sel or autotuning_cclk_sel.
Values:
0x0 (LATENCY_LT_1): Less than 1-cycle latency
0x1 (LATENCY_LT_2): Less than 2-cycle latency
0x2 (LATENCY_LT_3): Less than 3-cycle latency
0x3 (LATENCY_LT_4): Less than 4-cycle latency</description>
	<bitRange>[20:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRE_CHANGE_DLY</name>
	<description>Maximum Latency specification between cclk_tx and cclk_rx.
Values:
0x0 (LATENCY_LT_1): Less than 1-cycle latency
0x1 (LATENCY_LT_2): Less than 2-cycle latency
0x2 (LATENCY_LT_3): Less than 3-cycle latency
0x3 (LATENCY_LT_4): Less than 4-cycle latency</description>
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TUNE_CLK_STOP_EN</name>
	<description>Clock stopping control for Tuning and auto-tuning circuit.
When enabled, clock gate control output of DWC_mshc (clk2card_on) is pulled low before changing phase select codes on tuning_cclk_sel and autotuning_cclk_sel. This effectively stops the Device/Card
clock, cclk_rx and also drift_cclk_rx. Changing phase code when clocks are stopped ensures glitch free phase switching. Set this bit to 0 if the PHY or delayline can guarantee glitch free switching.
Values:
0x1 (ENABLE_CLK_STOPPING): Clocks stopped during phase code change
0x0 (DISABLE_CLK_STOPPING): Clocks not stopped. PHY ensures glitch free phase switching.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_TUNE_EN</name>
	<description>This fields enables software-managed tuning flow.
Values:
0x1 (SW_TUNING_ENABLE): Software-managed tuning enabled. AT_STAT_R.CENTER_PH_CODE Field is now writable.
0x0 (SW_TUNING_DISABLE): Software-managed tuning disabled.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RPT_TUNE_ERR</name>
	<description>Framing errors are not generated when executing tuning. This debug bit allows users to report these errors.
Values:
0x1 (DEBUG_ERRORS): Debug mode for reporting framing errors
0x0 (ERRORS_DISABLED): Default mode where as per SD-HCI no errors are reported.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWIN_TH_EN</name>
	<description>Sampling window Threshold enable
Selects the tuning mode
Field should be programmed only when SAMPLE_CLK_SEL is '0'
Values:
0x1 (THRESHOLD_MODE): Tuning engine selects the first complete sampling window that meets the threshold set by SWIN_TH_VAL field
0x0 (LARGEST_WIN_MODE): Tuning engine sweeps all taps and settles at the largest window</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_AT_STAT_R_REG</name>
	<description>Register to read the Center, Left and Right codes used by tuning and auto-tuning engines. Center code field is also used for so</description>
	<addressOffset>0x00000544</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L_EDGE_PH_CODE</name>
	<description>Left Edge Phase code. Reading this field returns the phase code value used by Auto-tuning engine to sample data on Left edge of sampling window.
</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_EDGE_PH_CODE</name>
	<description>Right Edge Phase code. Reading this field returns the phase code value used by Auto-tuning engine to sample data on Right edge of sampling window.
</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CENTER_PH_CODE</name>
	<description>Centered Phase code. Reading this field returns the current value on tuning_cclk_sel output. Setting AT_CTRL_R.SW_TUNE_EN enables software to write to this field and its contents are reflected on tuning_cclk_sel.
</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_AUTO_CMD_STAT_R_REG</name>
	<description>This register is used to indicate the CMD12 response error of Auto CMD12, and the CMD23 response error of Auto CMD23. The Host </description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CMD_NOT_ISSUED_AUTO_CMD12</name>
	<description>Command Not Issued By Auto CMD12 Error
If this bit is set to 1, CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register.
This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.
Values:
0x1 (TRUE): Not Issued
0x0 (FALSE): No Error</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUTO_CMD_RESP_ERR</name>
	<description>Auto CMD Response Error
This bit is set when Response Error Check Enable in the Transfer Mode register is set to 1 and an error is detected in R1 response of either Auto CMD12 or CMD13. This status is ignored if any bit between D00 to D04 is set to 1.
Values:
0x1 (TRUE): Error
0x0 (FALSE): No Error</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUTO_CMD_IDX_ERR</name>
	<description>Auto CMD Index Error
This bit is set if the command index error occurs in response to a command.
Values:
0x1 (TRUE): Error
0x0 (FALSE): No Error</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUTO_CMD_EBIT_ERR</name>
	<description>Auto CMD End Bit Error
This bit is set when detecting that the end bit of command response is 0.
Values:
0x1 (TRUE): End Bit Error Generated
0x0 (FALSE): No Error</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUTO_CMD_CRC_ERR</name>
	<description>Auto CMD CRC Error
This bit is set when detecting a CRC error in the command response.
Values:
0x1 (TRUE): CRC Error Generated
0x0 (FALSE): No Error</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUTO_CMD_TOUT_ERR</name>
	<description>Auto CMD Timeout Error
This bit is set if no response is returned with 64 SDCLK cycles from the end bit of the command.
If this bit is set to 1, error status bits (D04-D01) are meaningless.
Values:
0x1 (TRUE): Time out
0x0 (FALSE): No Error</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUTO_CMD12_NOT_EXEC</name>
	<description>Auto CMD12 Not Executed
If multiple memory block data transfer is not started due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12. Setting this bit to 1 means that the Host Controller cannot issue Auto CMD12 to stop multiple memory block data transfer, due to some error. If this bit is set to 1, error status bits (D04-D01) is meaningless.
This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.
Values:
0x1 (TRUE): Not Executed
0x0 (FALSE): Executed</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_BGAP_CTRL_R_REG</name>
	<description>This register is used by the host driver to control any operation related to Block Gap. This register is applicable for an SD/e</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>INT_AT_BGAP</name>
	<description>Interrupt At Block Gap.
This bit is valid only in the 4-bit mode of an SDIO card and is used to select a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer.

Values:

0x0 (DISABLE): Disabled
0x1 (ENABLE): Enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RD_WAIT_CTRL</name>
	<description>Read Wait Control.
This bit is used to enable the read wait protocol to stop read data using DAT[2] line if the card supports read wait. Otherwise, the Host Controller has to stop the card clock to hold the read data. 

Values:
0x0 (DISABLE): Disable Read Wait Control
0x1 (ENABLE): Enable Read Wait Control</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CONTINUE_REQ</name>
	<description>Continue Request.
This bit is used to restart the transaction, which was stopped using the Stop At Block Gap Request. The Host Controller automatically clears this bit when the transaction restarts. If stop at block gap request is set to 1, any write to this bit is ignored.

Values:
0x0 (NO_AFFECT): No Affect
0x1 (RESTART): Restart</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>STOP_BG_REQ</name>
	<description>Stop At Block Gap Request.
This bit is used to stop executing read and write transactions at the next block gap for non-DMA, SDMA, and ADMA transfers.

Values:
0x0 (XFER): Transfer
0x1 (STOP): Stop</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_BLOCKCOUNT_R_REG</name>
	<description>This register is used to configure the number of data blocks. This register is applicable for both SD and eMMC modes.</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLOCK_CNT</name>
	<description>16-bit Block Count.
- If the Host Version 4 Enable bit is set 0 or the 16-bit Block Count register is set to non-zero, the 16-bit Block Count register is selected.
- If the Host Version 4 Enable bit is set 1 and the 16-bit Block Count register is set to zero, the 32-bit Block Count register is selected.
Following are the values for BLOCK_CNT:
- 0x0: Stop Count
- 0x1: 1 Block
- 0x2: 2 Blocks
- ... - ...
- 0xFFFF: 65535 Blocks
Note: For Host Version 4 Enable = 0, this register must be set to 0000h before programming the 32-bit block count register when Auto CMD23 is enabled for non-DMA and ADMA modes.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_BLOCKSIZE_R_REG</name>
	<description>This register is used to configure an SDMA buffer boundary and the number of bytes in a data block. This register is applicable</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDMA_BUF_BDARY</name>
	<description>SDMA Buffer Boundary.
These bits specify the size of contiguous buffer in system memory. The SDMA transfer waits at every boundary specified by these fields and the Host Controller generates the DMA interrupt to request the Host Driver to update the SDMA System Address register.

Values:
0x0 (BYTES_4K): 4K bytes SDMA Buffer Boundary
0x1 (BYTES_8K): 8K bytes SDMA Buffer Boundary
0x2 (BYTES_16K): 16K bytes SDMA Buffer Boundary
0x3 (BYTES_32K): 32K bytes SDMA Buffer Boundary
0x4 (BYTES_64K): 64K bytes SDMA Buffer Boundary
0x5 (BYTES_128K): 128K bytes SDMA Buffer Boundary
0x6 (BYTES_256K): 256K bytes SDMA Buffer Boundary
0x7 (BYTES_512K): 512K bytes SDMA Buffer Boundary
</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XFER_BLOCK_SIZE</name>
	<description>Transfer Block Size.
These bits specify the block size of data transfers. In case of memory, it is set to 512 bytes. It can be accessed only if no transaction is executing. Read operations during transfers may return
an invalid value, and write operations are ignored.
Following are the values for XFER_BLOCK_SIZE:
- 0x1: 1 byte
- 0x2: 2 bytes
- 0x3: 3 bytes
- ...... 
- 0x1FF: 511 byte
- 0x200: 512 bytes
- ......   
- 0x800: 2048 bytes
Note: This register must be programmed with a non-zero value for data transfer.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_BOOT_CTRL_R_REG</name>
	<description>This register is used to control the eMMC Boot operation.</description>
	<addressOffset>0x0000052e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BOOT_TOUT_CNT</name>
	<description>Boot Ack Timeout Counter Value.
This value determines the interval by which boot ack timeout (50 ms) is detected when boot ack is expected during boot operation.
- 0xF : Reserved
- 0xE : TMCLK x 2^27
- ..   - ............
- 0x1 : TMCLK x 2^14
- 0x0 : TMCLK x 2^13</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOT_ACK_ENABLE</name>
	<description>Boot Acknowledge Enable
When this bit set, DWC_mshc checks for boot acknowledge start pattern of 0-1-0 during boot operation. This bit is applicable for both mandatory and alternate boot mode.
Values:
0x1 (TRUE): Boot Ack enable
0x0 (FALSE): Boot Ack disable</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VALIDATE_BOOT</name>
	<description>Validate Mandatory Boot Enable bit
This bit is used to validate the MAN_BOOT_EN bit.
Values:
0x1 (TRUE): Validate Mandatory boot enable bit
0x0 (FALSE): Ignore Mandatory boot Enable bit</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>MAN_BOOT_EN</name>
	<description>Mandatory Boot Enable
This bit is used to initiate the mandatory boot operation. The application sets this bit along with VALIDATE_BOOT bit. Writing 0 is ignored. The DWC_mshc clears this bit after the boot transfer is completed or terminated.
Values:
0x1 (MAN_BOOT_EN): Mandatory boot enable
0x0 (MAN_BOOT_DIS): Mandatory boot disable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_BUF_DATA_R_REG</name>
	<description>This register is used to access the packet buffer. This register is applicable for an SD/eMMC/UHS-II mode.</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUF_DATA</name>
	<description>Buffer Data.
These bits enable access to the Host Controller packet buffer.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_CAPABILITIES1_R_REG</name>
	<description>This register provides the Host Driver with information specific to the Host Controller implementation. The host controller may</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x206e30a0</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SLOT_TYPE_R</name>
	<description>Slot Type
These bits indicate usage of a slot by a specific Host System.
Values:
0x0 (REMOVABLE_SLOT): Removable Card Slot
0x1 (EMBEDDED_SLOT): Embedded Slot for one Device
0x2 (SHARED_SLOT): Shared Bus Slot (SD mode)
0x3 (UHS2_EMBEDDED_SLOT): UHS-II MultipleEmbedded Devices</description>
	<bitRange>[31:30]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ASYNC_INT_SUPPORT</name>
	<description>Asynchronous Interrupt Support (SD Mode only)
Values:
0x0 (FALSE): Asynchronous Interrupt Not Supported
0x1 (TRUE): Asynchronous Interrupt Supported</description>
	<bitRange>[29:29]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_ADDR_64_V3</name>
	<description>64-bit System Address Support for V3
This bit sets the Host controller to support 64-bit System Addressing of V3 mode.
SDMA cannot be used in 64-bit Addressing in Version 3 Mode.
If this bit is set to 1, 64-bit ADMA2 with using 96-bit Descriptor can be enabled by setting Host Version 4 Enable (HOST_VER4_ENABLE = 0) and DMA select (DMA_SEL = 11b).
Values:
0x0 (FALSE): 64-bit System Address for V3 is Not Supported
0x1 (TRUE): 64-bit System Address for V3 is Supported</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_ADDR_64_V4</name>
	<description>64-bit System Address Support for V4
This bit sets the Host Controller to support 64-bit System Addressing of V4 mode. When this bit is set to 1, full or part of 64-bit address must be used to decode the Host Controller Registers so that Host Controller Registers can be placed above system memory area. 64-bit address decode of Host Controller registers is effective regardless of setting to 64-bit Addressing in Host Control 2.
If this bit is set to 1, 64-bit DMA Addressing for version 4 is enabled by setting Host Version 4 Enable
(HOST_VER4_ENABLE = 1) and by setting 64-bit Addressing (ADDRESSING =1) in the Host Control 2 register. SDMA can be used and ADMA2 uses 128-bit Descriptor.
Values:
0x0 (FALSE): 64-bit System Address for V4 is Not Supported
0x1 (TRUE): 64-bit System Address for V4 is Supported</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VOLT_18</name>
	<description>Voltage Support for 1.8V
Values:
0x0 (FALSE): 1.8V Not Supported
0x1 (TRUE): 1.8V Supported</description>
	<bitRange>[26:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VOLT_30</name>
	<description>Voltage Support for SD 3.0V or Embedded 1.2V
Values:
0x0 (FALSE): SD 3.0V or Embedded 1.2V Not Supported
0x1 (TRUE): SD 3.0V or Embedded Supported</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VOLT_33</name>
	<description>Voltage Support for 3.3V
Values:
0x0 (FALSE): 3.3V Not Supported
0x1 (TRUE): 3.3V Supported</description>
	<bitRange>[24:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SUS_RES_SUPPORT</name>
	<description>Suspense/Resume Support
This bit indicates whether the Host Controller supports Suspend/Resume functionality. If this bit is 0, the Host Driver does not issue either Suspend or Resume commands because the Suspend and Resume mechanism is not supported.
Values:
0x0 (FALSE): Not Supported
0x1 (TRUE): Supported</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDMA_SUPPORT</name>
	<description>SDMA Support
This bit indicates whether the Host Controller is capable of using SDMA to transfer data between the system memory and the Host Controller directly.
Values:
0x0 (FALSE): SDMA not Supported
0x1 (TRUE): SDMA Supported</description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HIGH_SPEED_SUPPORT</name>
	<description>High Speed Support
This bit indicates whether the Host Controller and the Host System supports High Speed mode and they can supply the SD Clock frequency from 25 MHz to 50 MHz.
Values:
0x0 (FALSE): High Speed not Supported
0x1 (TRUE): High Speed Supported</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADMA2_SUPPORT</name>
	<description>ADMA2 Support
This bit indicates whether the Host Controller is capable of using ADMA2.
Values:
0x0 (FALSE): ADMA2 not Supported
0x1 (TRUE): ADMA2 Supported</description>
	<bitRange>[19:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EMBEDDED_8_BIT</name>
	<description>8-bit Support for Embedded Device
This bit indicates whether the Host Controller is capable of using an 8-bit bus width mode. This bit is not effective when the Slot Type is set to 10b.
Values:
0x0 (FALSE): 8-bit Bus Width not Supported
0x1 (TRUE): 8-bit Bus Width Supported</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_BLK_LEN</name>
	<description>Maximum Block Length
This bit indicates the maximum block size that the Host driver can read and write to the buffer in the Host Controller. The buffer transfers this block size without wait cycles. The transfer block length is always 512 bytes for the SD Memory irrespective of this bit
Values:
0x0 (ZERO): 512 Byte
0x1 (ONE): 1024 Byte
0x2 (TWO): 2048 Byte
0x3 (THREE): Reserved</description>
	<bitRange>[17:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BASE_CLK_FREQ</name>
	<description>Base Clock Frequency for SD clock
These bits indicate the base (maximum) clock frequency for the SD Clock. The definition of these bits depend on the Host Controller Version.
- 6-Bit Base Clock Frequency: This mode is supported by the Host Controller version 1.00 and 2.00. The upper 2 bits are not effective and are always 0. The unit values are 1 MHz. The supported clock range is 10 MHz to 63 MHz.
-- 0x00 : Get information through another method
-- 0x01 : 1 MHz
-- 0x02 : 2 MHz
-- .............
-- 0x3F : 63 MHz
-- 0x40-0xFF : Not Supported
- 8-Bit Base Clock Frequency: This mode is supported by the Host Controller version 3.00. The unit values are 1 MHz. The supported clock range is 10 MHz to 255 MHz.
-- 0x00 : Get information through another method
-- 0x01 : 1 MHz
-- 0x02 : 2 MHz
-- ............
-- 0xFF : 255 MHz
If the frequency is 16.5 MHz, the larger value is set to 0001001b (17 MHz) because the Host Driver uses this value to calculate the clock divider value and it does not exceed the upper limit of the SD Clock frequency. If these bits are all 0, the Host system has to get information using a different method.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TOUT_CLK_UNIT</name>
	<description>Timeout Clock Unit
This bit shows the unit of base clock frequency used to detect Data TImeout Error.
Values:
0x0 (KHZ): KHz
0x1 (MHZ): MHz</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TOUT_CLK_FREQ</name>
	<description>
Timeout Clock Frequency

This bit shows the base clock frequency used to detect Data Timeout Error. The Timeout Clock unit defines the unit of timeout clock frequency. It can be KHz or MHz.
- 0x00 : Get information through another method
- 0x01 :  1KHz /  1MHz
- 0x02 :  2KHz /  2MHz
- 0x03 :  3KHz /  3MHz
-  ...........
- 0x3F : 63KHz / 63MHz
</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_CAPABILITIES2_R_REG</name>
	<description>This register provides the Host Driver with information specific to the Host Controller implementation. The host controller may</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000077</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>VDD2_18V_SUPPORT</name>
	<description>1.8V VDD2 Support
This bit indicates support of VDD2 for the Host System.
Values:
0x0 (FALSE): 1.8V VDD2 is not Supported
0x1 (TRUE): 1.8V VDD2 is Supported</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ADMA3_SUPPORT</name>
	<description>ADMA3 Support
This bit indicates whether the Host Controller is capable of using ADMA3.
Values:
0x0 (FALSE): ADMA3 not Supported
0x1 (TRUE): ADMA3 Supported</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_MUL</name>
	<description>Clock Multiplier
These bits indicate the clock multiplier of the programmable clock generator. Setting these bits to 0 means that the Host Controller does not support a programmable clock generator.
- 0x0: Clock Multiplier is not Supported
- 0x1: Clock Multiplier M = 2
- 0x2: Clock Multiplier M = 3
-   .........
- 0xFF: Clock Multiplier M = 256</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RE_TUNING_MODES</name>
	<description>Re-Tuning Modes (UHS-I only)
These bits select the re-tuning method and limit the maximum data length.
Values:
0x0 (MODE1): Timer
0x1 (MODE2): Timer and Re-Tuning Request (Not supported)
0x2 (MODE3): Auto Re-Tuning (for transfer)
0x3 (RSVD_MODE): Reserved</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USE_TUNING_SDR50</name>
	<description>Use Tuning for SDR50 (UHS-I only)
</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RETUNE_CNT</name>
	<description>Timer Count for Re-Tuning (UHS-I only)
- 0x0: Re-Tuning Timer disabled
- 0x1: 1 seconds
- 0x2: 2 seconds
- 0x3: 4 seconds
-  ........
- 0xB: 1024 seconds
- 0xC: Reserved
- 0xD: Reserved
- 0xE: Reserved
- 0xF: Get information from other source</description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DRV_TYPED</name>
	<description>Driver Type D Support (UHS-I only)
This bit indicates support of Driver Type D for 1.8 Signaling.
Values:
Description
0x0 (FALSE): Driver Type D is not supported
0x1 (TRUE): Driver Type D is supported</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DRV_TYPEC</name>
	<description>Driver Type C Support (UHS-I only)
This bit indicates support of Driver Type C for 1.8 Signaling.
Values:
0x0 (FALSE): Driver Type C is not supported
0x1 (TRUE): Driver Type C is supported</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DRV_TYPEA</name>
	<description>Driver Type A Support (UHS-I only)
This bit indicates support of Driver Type A for 1.8 Signaling.
Values:
0x0 (FALSE): Driver Type A is not supported
0x1 (TRUE): Driver Type A is supported</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UHS2_SUPPORT</name>
	<description>UHS-II Support (UHS-II only)
This bit indicates whether Host Controller supports UHS-II.
Values:
0x0 (FALSE): UHS-II is not supported
0x1 (TRUE): UHS-II is supported</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DDR50_SUPPORT</name>
	<description>DDR50 Support (UHS-I only)
Values:
0x0 (FALSE): DDR50 is not supported
0x1 (TRUE): DDR50 is supported</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDR104_SUPPORT</name>
	<description>SDR104 Support (UHS-I only)
This bit mentions that SDR104 requires tuning.
Values:
0x0 (FALSE): SDR104 is not supported
0x1 (TRUE): SDR104 is supported</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDR50_SUPPORT</name>
	<description>SDR50 Support (UHS-I only)
Thsi bit indicates that SDR50 is supported. The bit 13 (USE_TUNING_SDR50) indicates whether SDR50 requires tuning or not.
Values:
0x0 (FALSE): SDR50 is not supported
0x1 (TRUE): SDR50 is supported</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_CLK_CTRL_R_REG</name>
	<description>This register controls SDCLK (card clock) in an SD/eMMC mode and RCLK in the UHS-II mode. This register is applicable for an SD</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FREQ_SEL</name>
	<description>SDCLK/RCLK Frequency Select.
These bits are used to select the frequency of the SDCLK signal. These bits depend on setting of Preset Value Enable in the Host Control 2 register. If Preset Value Enable = 0, these bits are set by the Host Driver. If Preset Value Enable = 1, these bits are automatically set to a value specified in one of the Preset Value register. The value is reflected on the lower 8-bit of the card_clk_freq_sel signal. 
10-bit Divided Clock Mode:
- 0x3FF : 1/2046 Divided clock
- N    : 1/2N Divided Clock
- 0x002  : 1/4 Divided Clock
- 0x001 : 1/2 Divided Clock
- 0x000 : Base clock (10MHz - 255 MHz)
Programmable Clock Mode : Enables the Host System to select a fine grain SD clock frequency:
- 0x3FF : Base clock  * M /1024
- N-1  : Base clock  * M /N
- 0x002  : Base clock  * M /3
- 0x001 : Base clock  * M /2
- 0x000 : Base clock  * M</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UPPER_FREQ_SEL</name>
	<description>These bits specify the upper 2 bits of 10-bit SDCLK/RCLK Frequency Select control. The value is reflected on the upper 2 bits of the card_clk_freq_sel signal.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_GEN_SELECT</name>
	<description>Clock Generator Select.
This bit is used to select the clock generator mode in SDCLK/RCLK Frequency Select. If Preset Value Enable = 0, this bit is set by the Host Driver. If Preset Value Enable = 1, this bit is automatically set to a value specified in one of the Preset Value registers. The value is reflected on the card_clk_gen_sel signal.

Values:
0x0 (FALSE): Divided Clock Mode
0x1 (TRUE): Programmable Clock Mode</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PLL_ENABLE</name>
	<description>PLL Enable.
This bit is used to activate the PLL (applicable when Host Version 4 Enable = 1). When Host Version 4 Enable = 0, INTERNAL_CLK_EN bit may be used to activate PLL. The value is reflected on the card_clk_en signal.
Note: If this bit is not used to to active the PLL when Host Version 4 Enable = 1, it is recommended to set this bit to '1' .

Values:
0x0 (FALSE): PLL is in low power mode
0x1 (TRUE): PLL is enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SD_CLK_EN</name>
	<description>SD/eMMC Clock Enable.
This bit stops the SDCLK or RCLK when set to 0. The SDCLK/RCLK Frequency Select bit can be changed when this bit is set to 0.
The value is reflected on the clk2card_on pin.

Values:
0x0 (FALSE): Disable providing SDCLK/RCLK
0x1 (TRUE): Enable providing SDCLK/RCLK</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INTERNAL_CLK_STABLE</name>
	<description>Internal Clock Stable
This bit enables the Host Driver to check the clock stability twice after the Internal Clock Enable bit is set and after the PLL Enable bit is set. This bit reflects the synchronized value of the intclk_stable signal after the Internal Clock Enable bit is set to 1 and also reflects the synchronized value of the card_clk_stable signal after the PLL Enable bit is set to 1.

Values:
0x0 (FALSE): Not Ready
0x1 (TRUE): Ready</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INTERNAL_CLK_EN</name>
	<description>Internal Clock Enable.
This bit is set to 0 when the Host Driver is not using the Host Controller or the Host Controller awaits a wakeup interrupt. The Host Controller must stop its internal clock to enter a very low power state. However, registers can still be read and written to. The value is reflected on the intclk_en signal.
Note: If this bit is not used to control the internal clock (base clock and master clock), it is recommended to set this bit to '1'.

Values:
0x0 (FALSE): Stop
0x1 (TRUE): Oscillate</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_CMD_R_REG</name>
	<description>This register is used to provide the information related to a command and a response packet. This register is applicable for an</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CMD_INDEX</name>
	<description>Command Index.
These bits are set to the command number that is specified in bits 45-40 of the Command Format.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_TYPE</name>
	<description>Command Type.
These bits indicate the command type.
Note: While issuing Abort CMD using CMD12/CMD52 or reset CMD using CMD0/CMD52, CMD_TYPE field shall be set to 0x3.

Values:
0x3 (ABORT_CMD): Abort
0x2 (RESUME_CMD): Resume
0x1 (SUSPEND_CMD): Suspend
0x0 (NORMAL_CMD): Normal
</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_PRESENT_SEL</name>
	<description>Data Present Select.
This bit is set to 1 to indicate that data is present and that the data is transferred using the DAT line.
This bit is set to 0 in the following instances:
- Command using the CMD line
- Command with no data transfer but using busy signal on the DAT[0] line
- Resume Command

Values:
0x0 (NO_DATA): No Data Present
0x1 (DATA): Data Present
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_IDX_CHK_ENABLE</name>
	<description>Command Index Check Enable.
This bit enables the Host Controller to check the index field in the response to verify if it has the same value as the command index. If the value is not the same, it is reported as a Command Index error.
Note:
- Index Check enable must be set to 0 for the command with no response, R2 response, R3 response and R4 response.
- For the tuning command, this bit must always be set to enable the index check.

Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_CRC_CHK_ENABLE</name>
	<description>Command CRC Check Enable.
This bit enables the Host Controller to check the CRC field in the response. If an error is detected, it is reported as a Command CRC error.
Note:
- CRC Check enable must be set to 0 for the command with no response, R3 response, and R4 response.
- For the tuning command, this bit must always be set to 1 to enable the CRC check.

Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable
</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SUB_CMD_FLAG</name>
	<description>Sub Command Flag.
This bit distinguishes between a main command and a sub command.

Values:
0x0 (MAIN): Main Command
0x1 (SUB): Sub Command
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_TYPE_SELECT</name>
	<description>Response Type Select.
This bit indicates the type of response expected from the card.

Values:
0x0 (NO_RESP): No Response
0x1 (RESP_LEN_136): Response Length 136
0x2 (RESP_LEN_48): Response Length 48
0x3 (RESP_LEN_48B): Response Length 48; Check
Busy after response
</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_CQCAP_REG</name>
	<description>This register indicates the capabilities of the command queuing engine.</description>
	<addressOffset>0x00000184</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000030c8</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRYPTO_SUPPORT</name>
	<description>Crypto Support   
This bit indicates whether the Host Controller supports cryptographic operations.
Values:
0x0 (FALSE): Crypto not Supported
0x1 (TRUE): Crypto Supported</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CQCCAP_RSVD2</name>
	<description>These bits [27:16] of the CQCAP register are reserved. They always return 0.
</description>
	<bitRange>[27:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ITCFMUL</name>
	<description>Internal Timer Clock Frequency Multiplier (ITCFMUL)
This field indicates the frequency of the clock used for interrupt coalescing timer and for
determining the SQS polling period. See ITCFVAL definition for details. Values 0x5 to 0xF are reserved.
Values:
0x0 (CLK_1KHz): 1KHz clock
0x1 (CLK_10KHz): 10KHz clock
0x2 (CLK_100KHz): 100KHz clock
0x3 (CLK_1MHz): 1MHz clock
0x4 (CLK_10MHz): 10MHz clock</description>
	<bitRange>[15:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ITCFVAL</name>
	<description>Internal Timer Clock Frequency Value (ITCFVAL)
This field scales the frequency of the timer clock provided by ITCFMUL. The Final clock frequency of actual timer clock is calculated as ITCFVAL* ITCFMUL.
</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_CURR_CAPABILITIES1_R_REG</name>
	<description>This register indicate the maximum current capability for each voltage, for VDD1. The value is meaningful if the Voltage Suppor</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MAX_CUR_18V</name>
	<description>Maximum Current for 1.8V
This bit specifies the Maximum Current for 1.8V VDD1 power supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_CUR_30V</name>
	<description>Maximum Current for 3.0V
This bit specifies the Maximum Current for 3.0V VDD1 power supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MAX_CUR_33V</name>
	<description>Maximum Current for 3.3V
This bit specifies the Maximum Current for 3.3V VDD1 power supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_CURR_CAPABILITIES2_R_REG</name>
	<description>This register indicates the maximum current capability for each voltage (for VDD2). The value is meaningful if Voltage Support </description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MAX_CUR_VDD2_18V</name>
	<description>Maximum Current for 1.8V VDD2
This bit specifies the Maximum Current for 1.8V VDD2 power supply for the UHS-II card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_EMBEDDED_CTRL_R_REG</name>
	<description>This register controls the embedded device. When the Host Controller is connected to a removable device, this register is not u</description>
	<addressOffset>0x00000f6c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BACK_END_PWR_CTRL</name>
	<description>Back-End Power Control (SD Mode)

Each bit of this field controls back-end power supply for an embedded device.
- 0 : Back-End Power is off
- 1 : Back-End Power is supplied

D24 : Back-End Power for Device 1

D25 : Back-End Power for Device 2

D26 : Back-End Power for Device 3

D27 : Back-End Power for Device 4

D28 : Back-End Power for Device 5

D29 : Back-End Power for Device 6

D30 : Back-End Power for Device 7
</description>
	<bitRange>[30:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INT_PIN_SEL</name>
	<description>Interrupt Pin Select

These bits enable the interrupt pin inputs.
- 000 : Interrupts (INT_A,INT_B,INT_C) are disabled
- xx1 : INT_A is enabled
- x1x : INT_B is enabled
- 1xx : INT_C is enabled</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_PIN_SEL</name>
	<description>Clock Pin Select (SD Mode)

This bit is selected by one of clock pin outputs.
- 0x0 : Clock pins are disabled
- 0x1 : CLK[1] is selected
- 0x2 : CLK[2] is selected
-  .      . 
-  .      . 
-  .      . 
- 0x7 : CLK[7] is selected
</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_WIDTH_PRESET</name>
	<description>Bus Width Preset (SD Mode)

Each bit of this field specifies the bus width for each embedded device. The shared bus supports mixing of 4-bit and 8-bit bus width devices.
- D08 : Bus Width Preset for Device 1
- D09 : Bus Width Preset for Device 2
- D10 : Bus Width Preset for Device 3
- D11 : Bus Width Preset for Device 4
- D12 : Bus Width Preset for Device 5
- D13 : Bus Width Preset for Device 6
- D14 : Bus Width Preset for Device 7

Function of each bit is defined as follows:
- 0 : 4-bit bus width mode
- 1 : 8-bit bus width mode
</description>
	<bitRange>[14:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>NUM_INT_PIN</name>
	<description>Number of Interrupt Input Pins

This field indicates support of interrupt input pins for an embedded system.
</description>
	<bitRange>[5:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>NUM_CLK_PIN</name>
	<description>Number of Clock Pins (SD Mode)

This field indicates support of clock pins to select one of devices for shared bus system. Up to 7 clock pins can be supported.
- 0x0 : Shared bus is not supported
- 0x1 : 1 SDCLK is supported
- 0x2 - 2 SDCLK is supported
-  .    .
-  .    .
-  .    .
- 0x7 : 7 SDCLK is supported
</description>
	<bitRange>[2:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_EMMC_CTRL_R_REG</name>
	<description>This register is used to control the eMMC operation.</description>
	<addressOffset>0x0000052c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EMMC_RST_N_OE</name>
	<description>Output Enable control for EMMC Device Reset signal PAD control.
This field drived sd_rst_n_oe output of DWC_mshc
Values:
0x1 (ENABLE): sd_rst_n_oe is 1
0x0 (DISABLE): sd_rst_n_oe is 0</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMMC_RST_N</name>
	<description>EMMC Device Reset signal control.
This register field controls the sd_rst_n output of DWC_mshc
Values:
0x1 (RST_DEASSERT): Reset to eMMC device is deasserted
0x0 (RST_ASSERT): Reset to eMMC device asserted (active low)</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DISABLE_DATA_CRC_CHK</name>
	<description>Disable Data CRC Check
This bit controls masking of CRC16 error for Card Write in eMMC mode. This is useful in bus testing (CMD19) for an eMMC device. In bus testing, an eMMC card does not send CRC status for a block, which may generate CRC error. This CRC error can be masked using this bit during bus testing.
Values:
0x1 (DISABLE): DATA CRC check is disabled
0x0 (ENABLE): DATA CRC check is enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_IS_EMMC</name>
	<description>eMMC Card present
This bit indicates the type of card connected. An application program this bit based on the card connected to MSHC.
Values:
0x1 (EMMC_CARD): Card connected to MSHC is an eMMC card
0x0 (NON_EMMC_CARD): Card connected to MSHC is a non-eMMC card</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_ERROR_INT_SIGNAL_EN_R_REG</name>
	<description>This register is used to select the interrupt status that is notified to the Host System as an interrupt. All these status bits</description>
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VENDOR_ERR_SIGNAL_EN3</name>
	<description>The 16th bit of Error Interrupt Signal Enable is reserved.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VENDOR_ERR_SIGNAL_EN2</name>
	<description>The 15th bit of Error Interrupt Signal Enable is reserved.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VENDOR_ERR_SIGNAL_EN1</name>
	<description>The 14th bit of Error Interrupt Signal Enable is reserved.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOT_ACK_ERR_SIGNAL_EN</name>
	<description>Boot Acknowledgment Error (eMMC Mode only).
Setting this bit to 1 enables generating interrupt signal when Boot Acknowledgement Error in Error Interrupt Status register is set.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_ERR_SIGNAL_EN</name>
	<description>Response Error Signal Enable (SD Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TUNING_ERR_SIGNAL_EN</name>
	<description>Tuning Error Signal Enable (UHS-I Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADMA_ERR_SIGNAL_EN</name>
	<description>ADMA Error Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUTO_CMD_ERR_SIGNAL_EN</name>
	<description>Auto CMD Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CUR_LMT_ERR_SIGNAL_EN</name>
	<description>Current Limit Error Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_END_BIT_ERR_SIGNAL_EN</name>
	<description>Data End Bit Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_CRC_ERR_SIGNAL_EN</name>
	<description>Data CRC Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_TOUT_ERR_SIGNAL_EN</name>
	<description>Data Timeout Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_IDX_ERR_SIGNAL_EN</name>
	<description>Command Index Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_END_BIT_ERR_SIGNAL_EN</name>
	<description>Command End Bit Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_CRC_ERR_SIGNAL_EN</name>
	<description>Command CRC Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_TOUT_ERR_SIGNAL_EN</name>
	<description>Command Timeout Error Signal Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_ERROR_INT_STAT_EN_R_REG</name>
	<description>This register sets the Interrupt Status for Error Interrupt Status register (ERROR_INT_STAT_R), when ERROR_INT_STAT_EN_R is set</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VENDOR_ERR_STAT_EN3</name>
	<description>The 15th bit of Error Interrupt Status Enable register is reserved.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VENDOR_ERR_STAT_EN2</name>
	<description>The 14th bit of Error Interrupt Status Enable register is reserved.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VENDOR_ERR_STAT_EN1</name>
	<description>The 13th bit of Error Interrupt Status Enable register is reserved.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOOT_ACK_ERR_STAT_EN</name>
	<description>Boot Acknowledgment Error (eMMC Mode only)
Setting this bit to 1 enables setting of Boot Acknowledgment Error in Error Interrupt Status register (ERROR_INT_STAT_R).

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_ERR_STAT_EN</name>
	<description>Response Error Status Enable (SD Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TUNING_ERR_STAT_EN</name>
	<description>Tuning Error Status Enable (UHS-I Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADMA_ERR_STAT_EN</name>
	<description>ADMA Error Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUTO_CMD_ERR_STAT_EN</name>
	<description>Auto CMD Error Status Enable (SD/eMMC Mode only).
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CUR_LMT_ERR_STAT_EN</name>
	<description>Current Limit Error Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_END_BIT_ERR_STAT_EN</name>
	<description>Data End Bit Error Status Enable (SD/eMMC Mode only).
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_CRC_ERR_STAT_EN</name>
	<description>Data CRC Error Status Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_TOUT_ERR_STAT_EN</name>
	<description>Data Timeout Error Status Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_IDX_ERR_STAT_EN</name>
	<description>Command Index Error Status Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_END_BIT_ERR_STAT_EN</name>
	<description>Command End Bit Error Status Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_CRC_ERR_STAT_EN</name>
	<description>Command CRC Error Status Enable (SD/eMMC Mode only)
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_TOUT_ERR_STAT_EN</name>
	<description>Command Timeout Error Status Enable (SD/eMMC Mode only).
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_ERROR_INT_STAT_R_REG</name>
	<description>This register enables an interrupt when the Error Interrupt Status Enable is enabled and at least one of the statuses is set to</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BOOT_ACK_ERR</name>
	<description>Boot Acknowledgement Error.
This bit is set when there is a timeout for boot acknowledgement or when detecting boot ack status having a value other than 010. This is applicable only when boot acknowledgement is expected in eMMC mode.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_ERR</name>
	<description>Response Error.
Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver during DMA execution. If Response Error Check Enable is set to 1 in the Transfer Mode register, Host Controller Checks R1 or R5 response. If an error is detected in a response, this bit is set to 1.This is applicable in SD/eMMC mode.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TUNING_ERR</name>
	<description>Tuning Error.
This bit is set when an unrecoverable error is detected in a tuning circuit except during the tuning procedure (occurrence of an error during tuning procedure is indicated by Sampling Clock Select in the Host Control 2 register). By detecting Tuning Error, Host Driver needs to abort a command executing and perform tuning. To reset tuning circuit, Sampling Clock Select is set to 0 before executing tuning procedure. The Tuning Error is higher priority than the other error interrupts generated during data transfer. By detecting Tuning Error, the Host Driver must discard data transferred by a current read/write command and retry data transfer after the Host Controller retrieved from the tuning circuit error. This is applicable in SD/eMMC mode.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADMA_ERR</name>
	<description>ADMA Error.
This bit is set when the Host Controller detects error during ADMA-based data transfer. The error could be due to following reasons:
- Error response received from System bus (Master I/F)
- ADMA3,ADMA2 Descriptors invalid
- CQE Task or Transfer descriptors invalid
When the error occurs, the state of the ADMA is saved in the ADMA Error Status register.
In eMMC CQE mode:
The Host Controller generates this Interrupt when it detects an invalid descriptor data (Valid=0) at the ST_FDS state. ADMA Error State in the ADMA Error Status indicates that an error has occurred in ST_FDS state. The Host Driver may find that Valid bit is not set at the error descriptor.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUTO_CMD_ERR</name>
	<description>Auto CMD Error.
This error status is used by Auto CMD12 and Auto CMD23 in SD/eMMC mode. This bit is set when detecting that any of the bits D00 to D05 in Auto CMD Error Status register has changed from 0 to 1. D07 is effective in case of Auto CMD12. Auto CMD Error Status register is valid while this bit is set to 1 and may be cleared by clearing of this bit.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CUR_LMT_ERR</name>
	<description>Current Limit Error.
By setting the SD Bus Power bit in the Power Control register, the Host Controller is requested to supply power for the SD Bus. If the Host Controller supports the Current Limit function, it can
be protected from an illegal card by stopping power supply to the card in which case this bit indicates a failure status. A reading of 1 for this bit means that the Host Controller is not supplying
power to the SD card due to some failure. A reading of 0 for this bit means that the Host Controller is supplying power and no error has occurred. The Host Controller may require some sampling time to
detect the current limit. DWC_mshc Host Controller does not support this function, this bit is always set to 0.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Power Fail</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_END_BIT_ERR</name>
	<description>Data End Bit Error.
This error occurs in SD/eMMC mode either when detecting 0 at the end bit position of read data that uses the DAT line or at the end bit position of the CRC status.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_CRC_ERR</name>
	<description>Data CRC Error.
This error occurs in SD/eMMC mode when detecting CRC error when transferring read data which uses the DAT line, when detecting the Write CRC status having a value of other than 010 or when write CRC status timeout.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_TOUT_ERR</name>
	<description>Data Timeout Error.
This bit is set in SD/eMMC mode when detecting one of the following timeout conditions:
- Busy timeout for R1b, R5b type
- Busy timeout after Write CRC status
- Write CRC Status timeout
- Read Data timeout

Values:
0x0 (FALSE): No error
0x1 (TRUE): Time out</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_IDX_ERR</name>
	<description>Command Index Error.
This bit is set if a Command Index error occurs in the command respons in SD/eMMC mode.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_END_BIT_ERR</name>
	<description>Command End Bit Error.
This bit is set when detecting that the end bit of a command response is 0 in SD/eMMC mode. 

Values:
0x0 (FALSE): No error
0x1 (TRUE): End Bit error generated</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_CRC_ERR</name>
	<description>Command CRC Error.
Command CRC Error is generated in SD/eMMC mode for following two cases.
- If a response is returned and the Command Timeout Error is set to 0 (indicating no timeout), this bit is set to 1 when detecting a CRC error in the command response.
- The Host Controller detects a CMD line conflict by monitoring the CMD line when a command is issued. If the Host Controller drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SD clock edge, then the Host Controller aborts the command (stop driving CMD line) and set this bit to 1. The Command Timeout Error is also set to 1 to distinguish a CMD line conflict.

Values:
0x0 (FALSE): No error
0x1 (TRUE): CRC error generated</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_TOUT_ERR</name>
	<description>Command Timeout Error.
In SD/eMMC Mode,this bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command. If the Host Controller detects a CMD line conflict, along with Command CRC Error bit, this bit is set to 1, without waiting for 64 SD/eMMC card clock cycles.

Values:
0x0 (FALSE): No error
0x1 (TRUE): Time out</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_FORCE_AUTO_CMD_STAT_R_REG</name>
	<description>The register is not a physically implemented but is an address at which the Auto CMD Error Status register can be written.This </description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</name>
	<description>Force Event for Command Not Issued By Auto CMD12 Error
Values:
0x1 (TRUE): Command Not Issued By Auto CMD12 Error Status is set
0x0 (FALSE): Not Affected</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_AUTO_CMD_RESP_ERR</name>
	<description>Force Event for Auto CMD Response Error
Values:
0x1 (TRUE): Auto CMD Response Error Status is set
0x0 (FALSE): Not Affected</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_AUTO_CMD_IDX_ERR</name>
	<description>Force Event for Auto CMD Index Error
Values:
0x1 (TRUE): Auto CMD Index Error Status is set
0x0 (FALSE): Not Affected</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_AUTO_CMD_EBIT_ERR</name>
	<description>Force Event for Auto CMD End Bit Error
Values:
0x1 (TRUE): Auto CMD End Bit Error Status is set
0x0 (FALSE): Not Affected</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_AUTO_CMD_CRC_ERR</name>
	<description>Force Event for Auto CMD CRC Error
Values:
0x1 (TRUE): Auto CMD CRC Error Status is set
0x0 (FALSE): Not Affected</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_AUTO_CMD_TOUT_ERR</name>
	<description>Force Event for Auto CMD Timeout Error
Values:
0x1 (TRUE): Auto CMD Timeout Error Status is set
0x0 (FALSE): Not Affected</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_AUTO_CMD12_NOT_EXEC</name>
	<description>Force Event for Auto CMD12 Not Executed
Values:
0x1 (TRUE): Auto CMD12 Not Executed Status is set
0x0 (FALSE): Not Affected</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>EMMC_FORCE_ERROR_INT_STAT_R_REG</name>
	<description>This register is not physically implemented but is an address at which the Error Interrupt Status register can be written. The </description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FORCE_VENDOR_ERR3</name>
	<description>This bit (FORCE_VENDOR_ERR3) of the FORCE_ERROR_INT_STAT_R register is reserved. It always returns 0.
</description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_VENDOR_ERR2</name>
	<description>This bit (FORCE_VENDOR_ERR2) of the FORCE_ERROR_INT_STAT_R register is reserved. It always returns 0.
</description>
	<bitRange>[14:14]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_VENDOR_ERR1</name>
	<description>This bit (FORCE_VENDOR_ERR1) of the FORCE_ERROR_INT_STAT_R register is reserved. It always returns 0.
</description>
	<bitRange>[13:13]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_BOOT_ACK_ERR</name>
	<description>Force Event for Boot Ack error
Values:

0x0 (FALSE): Not Affected
0x1 (TRUE): Boot ack Error Status is set</description>
	<bitRange>[12:12]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_RESP_ERR</name>
	<description>Force Event for Response Error (SD Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Response Error Status is set</description>
	<bitRange>[11:11]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_TUNING_ERR</name>
	<description>Force Event for Tuning Error (UHS-I Mode only)
</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_ADMA_ERR</name>
	<description>Force Event for ADMA Error
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): ADMA Error Status is set</description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_AUTO_CMD_ERR</name>
	<description>Force Event for Auto CMD Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): ADMA Error Status is set</description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_CUR_LMT_ERR</name>
	<description>Force Event for Current Limit Error
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Current Limit Error Status is set</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_DATA_END_BIT_ERR</name>
	<description>Force Event for Data End Bit Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Data End Bit Error Status is set</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_DATA_CRC_ERR</name>
	<description>Force Event for Data CRC Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Data CRC Error Status is set</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_DATA_TOUT_ERR</name>
	<description>Force Event for Data Timeout Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Data Timeout Error Status is set</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_CMD_IDX_ERR</name>
	<description>Force Event for Command Index Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command Index Error Status is set</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_CMD_END_BIT_ERR</name>
	<description>Force Event for Command End Bit Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command End Bit Error Status is set</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_CMD_CRC_ERR</name>
	<description>Force Event for Command CRC Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command CRC Error Status is set</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FORCE_CMD_TOUT_ERR</name>
	<description>Force Event for Command Timeout Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command Timeout Error Status is set</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>EMMC_HOST_CNTRL_VERS_R_REG</name>
	<description>This register is used to indicate the Host Controller Version number.</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000005</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>VENDOR_VERSION_NUM</name>
	<description>Vendor Version Number             

This field is reserved for the vendor version number. Host Driver must not use this status.
</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPEC_VERSION_NUM</name>
	<description>Specification Version Number
These bits indicate the Host controller specification version. The upper and lower 4-bits indicate the version. Values 0x06-0xFF are reserved.
Values:
0x0 (VER_1_00): SD Host Controller Specification Version 1.00
0x1 (VER_2_00): SD Host Controller Specification Version 2.00
0x2 (VER_3_00): SD Host Controller Specification Version 3.00
0x3 (VER_4_00): SD Host Controller Specification Version 4.00
0x4 (VER_4_10): SD Host Controller Specification Version 4.10
0x5 (VER_4_20): SD Host Controller Specification Version 4.20</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_HOST_CTRL1_R_REG</name>
	<description>This register is used to control the operation of the Host Controller. This register is applicable for an SD/eMMC/UHS-II mode.</description>
	<addressOffset>0x00000028</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CARD_DETECT_SIG_SEL</name>
	<description>Card Detect Signal Selection.
This bit selects a source for card detection. When the source for the card detection is switched, the interrupt must be disabled during the switching period.

Values:
0x1 (CARD_DT_TEST_LEVEL): Card Detect Test Level is selected (for test purpose)
0x0 (SDCD_PIN): SDCD# (card_detect_n signal) is selected (for normal use)</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_DETECT_TEST_LVL</name>
	<description>Card Detect Test Level.
This bit is enabled while the Card Detect Signal Selection is set to 1 and it indicates whether a card inserted or not.

Values:
0x1 (CARD_INSERTED): Card Inserted
0x0 (No_CARD): No Card</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EXT_DAT_XFER</name>
	<description>Extended Data Transfer Width.
This bit controls 8-bit bus width mode of embedded device.

Values:
0x1 (EIGHT_BIT): 8-bit Bus Width
0x0 (DEFAULT): Bus Width is selected by the Data Transfer Width</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_SEL</name>
	<description>DMA Select.
This field is used to select the DMA type.
When Host Version 4 Enable is 1 in Host Control 2 register:
- 0x0 : SDMA is selected
- 0x1 : Reserved
- 0x2 : ADMA2 is selected
- 0x3 : ADMA2 or ADMA3 is selected
When Host Version 4 Enable is 0 in Host Control 2 register:
- 0x0 : SDMA is selected
- 0x1 : Reserved
- 0x2 : 32-bit Address ADMA2 is selected
- 0x3 : 64-bit Address ADMA2 is selected

Values:
0x0 (SDMA): SDMA is selected
0x1 (RSVD_BIT): Reserved
0x2 (ADMA2): ADMA2 is selected
0x3 (ADMA2_3): ADMA2 or ADMA3 is selected</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HIGH_SPEED_EN</name>
	<description>High Speed Enable (SD/eMMC Mode only).
In SD/eMMC mode, this bit is used to determine the selection of preset value for High Speed mode.
Before setting this bit, the Host Driver checks the High Speed Support in the Capabilities register.
Note: DWC_MSHC always outputs the sd_cmd_out and sd_dat_out lines at the rising edge of cclk_tx clock irrespective of this bit.Please refer the section Connecting the Clock IO interface  in the Mobile Storage Host Controller user guide on clocking requirement for an SD/eMMC card.

Values:
0x1 (HIGH_SPEED): High Speed mode
0x0 (NORMAL_SPEED): Normal Speed mode</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DAT_XFER_WIDTH</name>
	<description>Data Transfer Width.
For SD/eMMC mode,this bit selects the data transfer width of the Host Controller. The Host Driver sets it to match the data width of the SD/eMMC card.

Values:
0x1 (FOUR_BIT): 4-bit mode
0x0 (ONE_BIT): 1-bit mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LED_CTRL</name>
	<description>LED Control.
This bit is used to caution the user not to remove the card while the SD card is being accessed. The value is reflected on the led_control signal.

Values:
0x0 (OFF): LED off
0x1 (ON): LED on</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_HOST_CTRL2_R_REG</name>
	<description>This register is used to control how the Host Controller operates. This register is applicable for an SD/eMMC/UHS-II mode.</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PRESET_VAL_ENABLE</name>
	<description>Preset Value Enable
This bit enables automatic selection of SDCLK frequency and Driver strength Preset Value registers. When Preset Value Enable is set, SDCLK frequency generation (Frequency Select and Clock Generator
Select) and the driver strength selection are performed by the controller. These values are selected from set of Preset Value registers based on selected speed mode.
Note: For more information, see the FAQ on Preset Register in the DWC_mshc Databook.
Values:
0x0 (FALSE): SDCLK and Driver Strength are controlled by Host Driver
0x1 (TRUE): Automatic Selection by Preset Value are Enabled</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ASYNC_INT_ENABLE</name>
	<description>Asynchronous Interrupt Enable
This bit can be set if a card supports asynchronous interrupts and Asynchronous Interrupt Support is set to 1 in the Capabilities register.
Values:
0x0 (FALSE): Disabled
0x1 (TRUE): Enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADDRESSING</name>
	<description>64-bit Addressing
This bit is effective when Host Version 4 Enable is set to 1.
Values:
0x0 (FALSE): 32 bits addressing
0x1 (TRUE): 64 bits addressing</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOST_VER4_ENABLE</name>
	<description>Host Version 4 Enable
This bit selects either Version 3.00 compatible mode or Version 4 mode.
Functions of following fields are modified for Host Version 4 mode:
- SDMA Address: SDMA uses ADMA System Address (05Fh-058h) instead of SDMA System Address register (003h-000h)
- ADMA2/ADMA3 selection: ADMA3 is selected by DMA select in Host Control 1 register
- 64-bit ADMA Descriptor Size: 128-bit descriptor is used instead of 96-bit descriptor when 64-bit Addressing is set to 1
- Selection of 32-bit/64-bit System Addressing: Either 32-bit or 64-bit system addressing is selected by 64-bit Addressing bit in this register
- 32-bit Block Count: SDMA System Address register (003h-000h) is modified to 32-bit Block Count register
Note: It is recommended not to program ADMA3 Integrated Descriptor Address registers, UHS-II registers and Command Queuing registers (if applicable) while operating in Host version less than 4 mode (Host Version 4 Enable = 0).
Values:
0x0 (FALSE): Version 3.00 compatible mode
0x1 (TRUE): Version 4 mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD23_ENABLE</name>
	<description>CMD23 Enable
If the card supports CMD23, this bit is set to 1. This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 data transfer.
Values:
0x0 (FALSE): Auto CMD23 is disabled
0x1 (TRUE): Auto CMD23 is enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADMA2_LEN_MODE</name>
	<description>ADMA2 Length Mode
This bit selects ADMA2 Length mode to be either 16-bit or 26-bit.
Values:
0x0 (FALSE): 16-bit Data Length Mode
0x1 (TRUE): 26-bit Data Length Mode</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UHS2_IF_ENABLE</name>
	<description>UHS-II Interface Enable
This bit is used to enable the UHS-II Interface. The value is reflected on the uhs2_if_en pin.
Values:
0x0 (FALSE): SD/eMMC Interface Enabled
0x1 (TRUE): UHS-II Interface Enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SAMPLE_CLK_SEL</name>
	<description>Sampling Clock Select
This bit is used by the Host Controller to select the sampling clock in SD/eMMC mode to receive CMD and DAT. This bit is set by the tuning procedure and is valid after the completion of tuning (when Execute Tuning is cleared). Setting this bit to 1 means that tuning is completed successfully and setting this bit to 0 means that tuning has failed. The value is reflected on the sample_cclk_sel pin.
Values:
0x0 (FALSE): Fixed clock is used to sample data
0x1 (TRUE): Tuned clock is used to sample data</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EXEC_TUNING</name>
	<description>Execute Tuning
This bit is set to 1 to start the tuning procedure in UHS-I/eMMC speed modes and this bit is automatically cleared when tuning procedure is completed.
Values:
0x0 (FALSE): Not Tuned or Tuning completed
0x1 (TRUE): Execute Tuning</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DRV_STRENGTH_SEL</name>
	<description>Driver Strength Select
This bit is used to select the Host Controller output driver in 1.8V signaling UHS-I/eMMC speed modes. The bit depends on setting of Preset Value Enable. The value is reflected on the uhs1_drv_sth pin.
Values:
0x0 (TYPEB): Driver TYPEB is selected
0x1 (TYPEA): Driver TYPEA is selected
0x2 (TYPEC): Driver TYPEC is selected
0x3 (TYPED): Driver TYPED is selected</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SIGNALING_EN</name>
	<description>1.8V Signaling Enable
This bit controls voltage regulator for I/O cell in UHS-I/eMMC speed modes. Setting this bit from 0 to 1 starts changing the signal voltage from 3.3V to 1.8V. Host Controller clears this bit if switching to 1.8 signaling
fails. The value is reflected on the uhs1_swvolt_en pin.
Note: This bit must be set for all UHS-I speed modes (SDR12/SDR25/SDR50/SDR104/DDR50).
Values:
0x0 (V_3_3): 3.3V Signalling
0x1 (V_1_8): 1.8V Signalling</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UHS_MODE_SEL</name>
	<description>UHS Mode/eMMC Speed Mode Select
These bits are used to select UHS mode in the SD mode of operation. In eMMC mode, these bits are used to select eMMC Speed mode.
UHS Mode (SD/UHS-II mode only):
- 0x0: SDR12
- 0x1: SDR25
- 0x2: SDR50
- 0x3: SDR104
- 0x4: DDR50
- 0x5: Reserved
- 0x6: Reserved
- 0x7: UHS-II
eMMC Speed Mode (eMMC mode only):
- 0x0: Legacy
- 0x1: High Speed SDR
- 0x2: Reserved
- 0x3: HS200
- 0x4: High Speed DDR
- 0x5: Reserved
- 0x6: Reserved
- 0x7: HS400
Values:
0x0 (SDR12): SDR12/Legacy
0x1 (SDR25): SDR25/High Speed SDR
0x2 (SDR50): SDR50
0x3 (SDR104): SDR104/HS200
0x4 (DDR50): DDR50/High Speed DDR
0x5 (RSVD5): Reserved
0x6 (RSVD6): Reserved
0x7 (UHS2): UHS-II/HS400</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_MBIU_CTRL_R_REG</name>
	<description>This register is used to select the valid burst types that the AHB Master bus interface can generate. &#13;
When more than one bit </description>
	<addressOffset>0x00000510</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x0000000e</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>BURST_INCR16_EN</name>
	<description>INCR16 Burst
Controls generation of INCR16 transfers on Master interface.
Values:
0x0 (FALSE): AHB INCR16 burst type is not generated on Master I/F
0x1 (TRUE): AHB INCR16 burst type can be generated on Master I/F</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_INCR8_EN</name>
	<description>INCR8 Burst
Controls generation of INCR8 transfers on Master interface.
Values:
0x0 (FALSE): AHB INCR8 burst type is not generated on Master I/F
0x1 (TRUE): AHB INCR8 burst type can be generated on Master I/F</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_INCR4_EN</name>
	<description>INCR4 Burst
Controls generation of INCR4 transfers on Master interface.
Values:
0x0 (FALSE): AHB INCR4 burst type is not generated on Master I/F
0x1 (TRUE): AHB INCR4 burst type can be generated on Master I/F</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UNDEFL_INCR_EN</name>
	<description>Undefined INCR Burst
Controls generation of undefined length INCR transfer on Master interface.
Values:
0x0 (FALSE): Undefined INCR type burst is the least preferred burst on AHB Master I/F
0x1 (TRUE): Undefined INCR type burst is the most preferred burst on AHB Master I/F</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_MSHC_CTRL_R_REG</name>
	<description>This register is used to control the operation of MSHC Host Controller.</description>
	<addressOffset>0x00000508</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>SW_CG_DIS</name>
	<description>Internal clock gating disable control
This bit must be used to disable IP's internal clock gating when required. when disabled clocks are not gated. Clocks to the core (except hclk) must be stopped when programming this bit.
Values:
0x0 (ENABLE): Internal clock gates are active and clock gating is controlled internally
0x1 (DISABLE): Internal clock gating is disabled, clocks are not gated internally</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_CONFLICT_CHECK</name>
	<description>Command conflict check
This bit enables command conflict check.
Note: DWC_mshc controller monitors the CMD line whenever a command is issued and checks whether the value driven on sd_cmd_out matches the value on sd_cmd_in at next subsequent edge
of cclk_tx to determine command conflict error. This bit is cleared only if the feed back delay (including IO Pad delay) is more than (t_card_clk_period - t_setup), where t_setup is the setup time of
a flop in DWC_mshc. The I/O pad delay is consistent across CMD and DATA lines, and it is within the value:
(2*t_card_clk_period - t_setup)  
Values:
0x0 (DISABLE_CMD_CONFLICT_CHK): Disable command conflict check
0x1 (CMD_CONFLICT_CHK_LAT1): Check for command conflict after 1 card clock cycle</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_MSHC_VER_ID_R_REG</name>
	<description>This register reflects the current release number of DWC_mshc/DWC_mshc_lite.</description>
	<addressOffset>0x00000500</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3138302a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSHC_VER_ID</name>
	<description>Current release number
This field indicates the Synopsys DesignWare Cores DWC_mshc/DWC_mshc_lite current release number that is read by an application.
An application reading this register in conjunction with the MSHC_VER_TYPE_R register, gathers details of the current release.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_MSHC_VER_TYPE_R_REG</name>
	<description>This register reflects the current release type of DWC_mshc/DWC_mshc_lite.</description>
	<addressOffset>0x00000504</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x67612a2a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSHC_VER_TYPE</name>
	<description>Current release type
This field indicates the Synopsys DesignWare Cores DWC_mshc/DWC_mshc_lite current release type that is read by an application.
An application reading this register in conjunction with the MSHC_VER_ID_R register, gathers details of the current release.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_NORMAL_INT_SIGNAL_EN_R_REG</name>
	<description>This register is used to select the interrupt status that is indicated to the Host System as the interrupt. All these status bi</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CQE_EVENT_SIGNAL_EN</name>
	<description>Command Queuing Engine Event Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FX_EVENT_SIGNAL_EN</name>
	<description>FX Event Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RE_TUNE_EVENT_SIGNAL_EN</name>
	<description>Re-Tuning Event (UHS-I only) Signal Enable.
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INT_C_SIGNAL_EN</name>
	<description>INT_C (Embedded) Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INT_B_SIGNAL_EN</name>
	<description>INT_B (Embedded) Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INT_A_SIGNAL_EN</name>
	<description>INT_A (Embedded) Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_INTERRUPT_SIGNAL_EN</name>
	<description>Card Interrupt Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_REMOVAL_SIGNAL_EN</name>
	<description>Card Removal Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_INSERTION_SIGNAL_EN</name>
	<description>Card Insertion Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUF_RD_READY_SIGNAL_EN</name>
	<description>Buffer Read Ready Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUF_WR_READY_SIGNAL_EN</name>
	<description>Buffer Write Ready Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INTERRUPT_SIGNAL_EN</name>
	<description>DMA Interrupt Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGAP_EVENT_SIGNAL_EN</name>
	<description>Block Gap Event Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XFER_COMPLETE_SIGNAL_EN</name>
	<description>Transfer Complete Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_COMPLETE_SIGNAL_EN</name>
	<description>Command Complete Signal Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_NORMAL_INT_STAT_EN_R_REG</name>
	<description>This register enables the Interrupt Status for Normal Interrupt Status register (NORMAL_INT_STAT_R) when NORMAL_INT_STAT_R is s</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CQE_EVENT_STAT_EN</name>
	<description>CQE Event Status Enable

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FX_EVENT_STAT_EN</name>
	<description>FX Event Status Enable
This bit is added from Version 4.10.

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RE_TUNE_EVENT_STAT_EN</name>
	<description>Re-Tuning Event (UHS-I only) Status Enable

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INT_C_STAT_EN</name>
	<description>INT_C (Embedded) Status Enable

If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts.

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled
</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INT_B_STAT_EN</name>
	<description>INT_B (Embedded) Status Enable

If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts.

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INT_A_STAT_EN</name>
	<description>INT_A (Embedded) Status Enable

If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts.

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_INTERRUPT_STAT_EN</name>
	<description>Card Interrupt Status Enable

If this bit is set to 0, the Host Controller clears the interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.

By setting this bit to 0, interrupt input must be masked by implementation so that the interrupt input is not affected by external signal in any state (for example, floating).

Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_REMOVAL_STAT_EN</name>
	<description>Card Removal Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_INSERTION_STAT_EN</name>
	<description>Card Insertion Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUF_RD_READY_STAT_EN</name>
	<description>Buffer Read Ready Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUF_WR_READY_STAT_EN</name>
	<description>Buffer Write Ready Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INTERRUPT_STAT_EN</name>
	<description>DMA Interrupt Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGAP_EVENT_STAT_EN</name>
	<description>Block Gap Event Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XFER_COMPLETE_STAT_EN</name>
	<description>Transfer Complete Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_COMPLETE_STAT_EN</name>
	<description>Command Complete Status Enable
Values:

0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_NORMAL_INT_STAT_R_REG</name>
	<description>This register reflects the status of the Normal Interrupt. This register is applicable for an SD/eMMC/UHS-II mode.</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ERR_INTERRUPT</name>
	<description>Error Interrupt.
If any of the bits in the Error Interrupt Status register are set, then this bit is set.

Values:
0x0 (FALSE): No Error
0x1 (TRUE): Error</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CQE_EVENT</name>
	<description>Command Queuing Event
This status is set if Command Queuing/Crypto related event has occurred in eMMC/SD mode. Read CQHCI's CQIS/CRNQIS register for more details.

Values:
0x0 (FALSE): No Event
0x1 (TRUE): Command Queuing Event is detected</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FX_EVENT</name>
	<description>FX Event.
This status is set when R[14] of response register is set to 1 and Response Type R1/R5 is set to 0 in Transfer Mode register. This interrupt is used with response check function.

Values:
0x0 (FALSE): No Event
0x1 (TRUE): FX Event is detected</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RE_TUNE_EVENT</name>
	<description>Re-tuning Event.
This bit is set if the Re-Tuning Request changes from 0 to 1. Re-Tuning request is not supported.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INT_C</name>
	<description>INT_C (Embedded).
This bit is set if INT_C is enabled and if INT_C# pin is in low level. The INT_C# pin is not supported.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INT_B</name>
	<description>INT_B (Embedded).
This bit is set if INT_B is enabled and if INT_B# pin is in low level. The INT_B# pin is not supported.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INT_A</name>
	<description>INT_A (Embedded).
This bit is set if INT_A is enabled and if INT_A# pin is in low level. The INT_A# pin is not supported.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CARD_INTERRUPT</name>
	<description>Card Interrupt.
This bit reflects the synchronized value of:
- DAT[1] Interrupt Input for SD Mode
- DAT[2] Interrupt Input for UHS-II Mode

Values:
0x0 (FALSE): No Card Interrupt
0x1 (TRUE): Generate Card Interrupt</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CARD_REMOVAL_STAT_R</name>
	<description>Card Removal.
This bit is set if the Card Inserted in the Present State register changes from 1 to 0.

Values:
0x0 (FALSE): Card state stable or Debouncing
0x1 (TRUE): Card Removed</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_INSERTION</name>
	<description>Card Insertion
This bit is set if the Card Inserted in the Present State register changes from 0 to 1.

Values:
0x0 (FALSE): Card state stable or Debouncing
0x1 (TRUE): Card Inserted</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUF_RD_READY</name>
	<description>Buffer Read Ready.
This bit is set if the Buffer Read Enable changes from 0 to 1.

Values:
0x0 (FALSE): Not ready to read buffer
0x1 (TRUE): Ready to read buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUF_WR_READY</name>
	<description>Buffer Write Ready.
This bit is set if the Buffer Write Enable changes from 0 to 1.

Values:
0x0 (FALSE): Not ready to write buffer
0x1 (TRUE): Ready to write buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INTERRUPT</name>
	<description>DMA Interrupt.
This bit is set if the Host Controller detects the SDMA Buffer Boundary during transfer. In case of ADMA, by setting the Int field in the descriptor table, the Host controller generates this interrupt. This interrupt is not generated after a Transfer Complete.

Values:
0x0 (FALSE): No DMA Interrupt
0x1 (TRUE): DMA Interrupt is generated</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGAP_EVENT</name>
	<description>Block Gap Event.
This bit is set when both read/write transaction is stopped at block gap due to a Stop at Block Gap Request.

Values:
0x0 (FALSE): No Block Gap Event
0x1 (TRUE): Transaction stopped at block gap</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XFER_COMPLETE</name>
	<description>Transfer Complete.
This bit is set when a read/write transfer and a command with status busy is completed.

Values:
0x0 (FALSE): Not complete
0x1 (TRUE): Command execution is completed</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_COMPLETE</name>
	<description>Command Complete.
In an SD/eMMC Mode, this bit is set when the end bit of a response except for Auto CMD12 and Auto CMD23.
This interrupt is not generated when the Response Interrupt Disable in Transfer Mode Register is set to 1.

Values:
0x0 (FALSE): No command complete
0x1 (TRUE): Command Complete</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_DDR50_R_REG</name>
	<description>This register defines the Preset Value for DDR50 and High Speed DDR speed modes in the SD and eMMC modes, respectively.</description>
	<addressOffset>0x0000006e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate Driver strength value supported for DDR50 bus speed mode. These bits are meaningless for 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when Host Controller supports programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
These bits specify a 10-bit preset value that must be set in the SDCLK/RCLK Frequency Select field of the Clock Control register, as described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_DS_R_REG</name>
	<description>This register defines Preset Value for Default Speed mode in SD mode.</description>
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate the Driver strength value supported by 1.8V signaling bus speed modes. This field is meaningless for the Default speed mode as it uses 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when Host Controller supports programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_HS_R_REG</name>
	<description>This register defines Preset Value for High Speed mode in SD mode.</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate the Driver strength value supported by 1.8V signaling bus speed modes. This field is meaningless for High speed mode as it uses 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when Host Controller supports programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_INIT_R_REG</name>
	<description>This register defines Preset Value for Initialization in SD/eMMC mode.</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate that the Driver strength is supported by 1.8V signaling bus speed modes. These bits are meaningless for 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when the Host Controller supports a programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_SDR104_R_REG</name>
	<description>This register defines Preset Value for SDR104 and HS200 speed modes in the SD and eMMC modes, respectively.</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate Driver strength value supported for SDR104 bus speed mode. These bits are meaningless for 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when Host Controller supports programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
These bits specify a 10-bit preset value that must be set in the SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_SDR12_R_REG</name>
	<description>This register defines Preset Value for SDR12 and Legacy speed mode in SD and eMMC mode respectively.</description>
	<addressOffset>0x00000066</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate the Driver strength value supported for the SDR12 bus speed mode. These bits are meaningless for 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when Host Controller supports programmable clock generator
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_SDR25_R_REG</name>
	<description>This register defines Preset Value for SDR25 and High Speed SDR speed mode in SD and eMMC mode respectively.</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate the Driver strength value supported for the SDR25 bus speed mode. These bits are meaningless for 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when Host Controller supports programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_SDR50_R_REG</name>
	<description>This register defines Preset Value for SDR50 speed mode in SD mode.</description>
	<addressOffset>0x0000006a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate Driver strength value supported for SDR50 bus speed mode. These bits are meaningless for 3.3V signaling.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when Host Controller supports programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PRESET_UHS2_R_REG</name>
	<description>This register is used to hold the preset value for UHS-II and HS400 speed modes in the SD and eMMC modes, respectively.</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DRV_SEL_VAL</name>
	<description>Driver Strength Select Value
These bits indicate the Driver strength value supported by 1.8V signaling bus speed modes in the SD mode. This field is meaningless for UHS-II mode. In eMMC mode, these bits can be used for selecting
the Drive strength value for HS400 mode.
Values:
0x0 (TYPEB): Driver Type B is selected
0x1 (TYPEA): Driver Type A is selected
0x2 (TYPEC): Driver Type C is selected
0x3 (TYPED): Driver Type D is selected</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_GEN_SEL_VAL</name>
	<description>Clock Generator Select Value
This bit is effective when the Host Controller supports a programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FREQ_SEL_VAL</name>
	<description>SDCLK/RCLK Frequency Select Value
These bits specify the 10-bit preset value that must be set in the SDCLK/RCLK Frequency Select field of the Clock Control register, as described by a Host System.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PSTATE_REG</name>
	<description>This register indicates the present status of the Host Controller. This register is applicable for an SD/eMMC/UHS-II mode.</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x020c0000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>UHS2_IF_DETECT</name>
	<description>UHS-II Interface Detection.
For SD/eMMC mode, this bit always returns 0.

Values:
0x0 (FALSE): UHS-II interface is not detected
0x1 (TRUE): UHS-II interface is detected
</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LANE_SYNC</name>
	<description>Lane Synchronization.
For SD/eMMC mode, this bit always returns 0.

Values:
0x0 (FALSE): UHS-II PHY is not initialized
0x1 (TRUE): UHS-II PHY is initialized
</description>
	<bitRange>[30:30]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IN_DORMANT_ST</name>
	<description>In Dormant Status
For SD/eMMC mode, this bit always returns 0.

Values:
0x0 (FALSE): Not in DORMANT state
0x1 (TRUE): In DORMANT state
</description>
	<bitRange>[29:29]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SUB_CMD_STAT</name>
	<description>Sub Command Status.
This bit is used to distinguish between a main command and a sub command status.

Values:
0x0 (FALSE): Main Command Status
0x1 (TRUE): Sub Command Status
</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_ISSUE_ERR</name>
	<description>Command Not Issued by Error.
This bit is set if a command cannot be issued after setting the command register due to an error except the Auto CMD12 error.

Values:
0x0 (FALSE): No error for issuing a command
0x1 (TRUE): Command cannot be issued
</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HOST_REG_VOL</name>
	<description>Host Regulator Voltage Stable.
This bit is used to check whether the host regulator voltage is stable for switching the voltage of UHS-I mode. This bit reflects the synchronized value of the host_reg_vol_stable signal.

Values:
Description
0x0 (FALSE): Host Regulator Voltage is not stable
0x1 (TRUE): Host Regulator Voltage is stable
</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_LINE_LVL</name>
	<description>Command-Line Signal Level.
This bit is used to check the CMD line level to recover from errors and for debugging. These bits reflect the value of the sd_cmd_in signal.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DAT_3_0</name>
	<description>DAT[3:0] Line Signal Level.
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the sd_dat_in (lower nibble) signal. </description>
	<bitRange>[23:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WR_PROTECT_SW_LVL</name>
	<description>Write Protect Switch Pin Level.
This bit is supported only for memory and combo cards. This bit reflects the synchronized value of the card_write_prot signal.

Values:
0x0 (FALSE): Write protected
0x1 (TRUE): Write enabled</description>
	<bitRange>[19:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CARD_DETECT_PIN_LEVEL</name>
	<description>Card Detect Pin Level.
This bit reflects the inverse synchronized value of the card_detect_n signal.

Values:
0x0 (FALSE): No card present
0x1 (TRUE): Card Present</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CARD_STABLE</name>
	<description>Card Stable.
This bit indicates the stability of the Card Detect Pin Level. A card is not detected if this bit is set to 1 and the value of the CARD_INSERTED bit is 0.

Values:
0x0 (FALSE): Reset or Debouncing
0x1 (TRUE): No Card or Inserted</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CARD_INSERTED</name>
	<description>Card Inserted.
This bit indicates whether a card has been inserted. The Host Controller debounces this signal so that Host Driver need not wait for it to stabilize.

Values:
0x0 (FALSE): Reset, Debouncing, or No card
0x1 (TRUE): Card Inserted</description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUF_RD_ENABLE</name>
	<description>Buffer Read Enable.
This bit is used for non-DMA transfers. This bit is set if valid data exists in the Host buffer.

Values:
0x0 (DISABLED): Read disable
0x1 (ENABLED): Read enable</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUF_WR_ENABLE</name>
	<description>Buffer Write Enable.
This bit is used for non-DMA transfers. This bit is set if space is available for writing data.

Values:
0x0 (DISABLED): Write disable
0x1 (ENABLED): Write enable</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_XFER_ACTIVE</name>
	<description>Read Transfer Active.
This bit indicates whether a read transfer is active for SD/eMMC mode.

Values:
0x0 (INACTIVE): No valid data
0x1 (ACTIVE): Transferring data</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WR_XFER_ACTIVE</name>
	<description>Write Transfer Active.
This status indicates whether a write transfer is active  for SD/eMMC mode.

Values:
0x0 (INACTIVE): No valid data
0x1 (ACTIVE): Transferring data</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DAT_7_4</name>
	<description>DAT[7:4] Line Signal Level.
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the sd_dat_in (upper nibble) signal.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RE_TUNE_REQ</name>
	<description>Re-Tuning Request.
DWC_mshc does not generate retuning request. The software must maintain the Retuning timer. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DAT_LINE_ACTIVE</name>
	<description>DAT Line Active (SD/eMMC Mode only).
This bit indicates whether one of the DAT lines on the SD/eMMC bus is in use.
In the case of read transactions, this bit indicates whether a read transfer is executing on the SD/eMMC bus.
In the case of write transactions, this bit indicates whether a write transfer is executing on the SD/eMMC bus.
For a command with busy, this status indicates whether the command executing busy is executing on an SD or eMMC bus.

Values:
0x0 (INACTIVE): DAT Line Inactive
0x1 (ACTIVE): DAT Line Active</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_INHIBIT_DAT</name>
	<description>Command Inhibit (DAT).
This bit is applicable for SD/eMMC mode and is generated if either DAT line active or Read transfer active is set to 1.
If this bit is set to 0, it indicates that the Host Controller can issue subsequent SD/eMMC commands.

Values:
0x0 (READY): Can issue command which used DAT line
0x1 (NOT_READY): Cannot issue command which used
DAT line</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_INHIBIT</name>
	<description>Command Inhibit (CMD).
This bit indicates the following :
- SD/eMMC mode: If this bit is set to 0, it indicates that the CMD line is not in use and the Host controller can issue an SD/eMMC command using the CMD line. This bit is set when the command register is written. This bit is cleared when the command response is received. This bit is not cleared by the response of auto CMD12/23 but cleared by the response of read/write command.

Values:
0x0 (READY): Host Controller is ready to issue a command
0x1 (NOT_READY): Host Controller is not ready to issue a command</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_PWR_CTRL_R_REG</name>
	<description>This register is used to control the bus power for the Card. This register is applicable for an SD, eMMC, and UHS-II modes.</description>
	<addressOffset>0x00000029</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SD_BUS_VOL_VDD2</name>
	<description>SD Bus Voltage Select for VDD2.
This is irrelevant for SD/eMMC card.

Values:
0x7 (NOT_USED7): Not used
0x6 (NOT_USED6): Not used
0x5 (V_1_8): 1.8V
0x4 (V_1_2): Reserved for 1.2V
0x3 (RSVD3): Reserved
0x2 (RSVD2): Reserved
0x1 (RSVD1): Reserved
0x0 (NO_VDD2): VDD2 Not Supported</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SD_BUS_PWR_VDD2</name>
	<description>SD Bus Power for VDD2.
This is irrelevant for SD/eMMC card.

Values:
0x0 (OFF): Power off
0x1 (ON): Power on</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SD_BUS_VOL_VDD1</name>
	<description>SD Bus Voltage Select for VDD1/eMMC Bus Voltage Select for VDD.
These bits enable the Host Driver to select the voltage level for an SD/eMMC card. Before setting this register, the Host Driver checks the Voltage Support bits in the Capabilities register.
If an unsupported voltage is selected, the Host System does not supply the SD Bus voltage. The value set in this field is available on the DWC_mshc output signal (sd_vdd1_sel), which is used by the voltage switching circuitry.
SD Bus Voltage Select options:
- 0x7 : 3.3V(Typical)
- 0x6 : 3.0V(Typical)
- 0x5 : 1.8V(Typical) for Embedded
- 0x4 : 0x0   - Reserved
eMMC Bus Voltage Select options:
- 0x7 : 3.3V(Typical)
- 0x6 : 1.8V(Typical)
- 0x5 : 1.2V(Typical)
- 0x4 : 0x0   - Reserved

Values:
0x7 (V_3_3): 3.3V (Typ.)
0x6 (V_3_0): 3.0V (Typ.)
0x5 (V_1_8): 1.8V (Typ.) for Embedded
0x4 (RSVD4): Reserved
0x3 (RSVD3): Reserved
0x2 (RSVD2): Reserved
0x1 (RSVD1): Reserved
0x0 (RSVD0): Reserved</description>
	<bitRange>[3:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SD_BUS_PWR_VDD1</name>
	<description>SD Bus Power for VDD1.
This bit enables VDD1 power of the card. This setting is available on the sd_vdd1_on output of DWC_mshc so that it can be used to control the VDD1 power supply of the card. Before setting this bit, the SD Host Driver sets the SD Bus Voltage Select bit. If the Host Controller detects a No Card state, this bit is cleared.
In SD mode, if this bit is cleared, the Host Controller stops the SD Clock by clearing the SD_CLK_IN bit in the CLK_CTRL_R register.

Values:
0x0 (OFF): Power off
0x1 (ON): Power on</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_P_EMBEDDED_CNTRL_REG</name>
	<description>This register points to the location of UHS-II embedded control registers.</description>
	<addressOffset>0x000000e6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000f6c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REG_OFFSET_EMBEDDED_CNTRL_ADDR</name>
	<description>Offset Address of Embedded Control register.            
</description>
	<bitRange>[11:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_P_VENDOR_SPECIFIC_AREA_REG</name>
	<description>This register used as a pointer for the Vendor Specific Area 1.</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000500</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REG_OFFSET_ADDR_VENDOR</name>
	<description>Base offset Address for Vendor-Specific registers.            
</description>
	<bitRange>[11:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_P_VNDR2_SPECIFIC_AREA_REG</name>
	<description>This register is used as a pointer for the Vendor Specific Area 2.</description>
	<addressOffset>0x000000ea</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000180</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REG_OFFSET_ADDR_VNDR2</name>
	<description>Base offset Address for Command Queuing registers.           
</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_RESP01_R_REG</name>
	<description>This register stores 39-08 bits of the Response Field for an SD/eMMC mode.  The response for an SD/eMMC command can be a maximu</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RESP01</name>
	<description>Command Response.
These bits reflect 39-8 bits of SD/eMMC Response Field.
Note: For Auto CMD, the 32-bit response (bits 39-8 of the Response Field) is updated in the RESP67_R register.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_RESP23_R_REG</name>
	<description>This register stores 71-40 bits of the Response Field for an SD/eMMC mode. This register is used to store the response from the</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RESP23</name>
	<description>Command Response.
These bits reflect 71-40 bits of the SD/eMMC Response Field. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_RESP45_R_REG</name>
	<description>This register stores 103-72 bits of the Response Field for an SD/eMMC mode.  The response for SD/eMMC command can be a maximum </description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RESP45</name>
	<description>Command Response.
These bits reflect 103-72 bits of the Response Field. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_RESP67_R_REG</name>
	<description>This register stores 135-104 bits of the Response Field for an SD/eMMC mode.    The SD/eMMC response can be a maximum of 128 bi</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RESP67</name>
	<description>Command Response.
These bits reflect bits 135-104 of SD/EMMC Response Field.
Note: For Auto CMD, this register also reflects the 32-bit response (bits 39-8 of the Response Field).</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_SDMASA_R_REG</name>
	<description>This register is used to configure a 32-bit Block Count or an SDMA System Address based on the Host Version 4 Enable bit in the</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLOCKCNT_SDMASA</name>
	<description>32-bit Block Count (SDMA System Address).
- SDMA System Address (Host Version 4 Enable = 0): This register contains the system memory address for an SDMA transfer in the 32-bit addressing mode. When the Host Controller stops an SDMA transfer, this register points to the system address of the next contiguous data position. It can be accessed only if no transaction is executing. Reading this register during data transfers may
return an invalid value.
- 32-bit Block Count (Host Version 4 Enable = 1): From the Host Controller Version 4.10 specification, this register is redefined as 32-bit Block Count. The Host Controller decrements the block count of this register for every block transfer and the data transfer stops when the count reaches zero. This register must be accessed when no transaction is executing. Reading this register during data transfers may return invalid value.
Following are the values for BLOCKCNT_SDMASA:
- 0xFFFF_FFFF: 4G - 1 Block
- ...  
- 0x0000_0002: 2 Blocks
- 0x0000_0001: 1 Block
- 0x0000_0000: Stop Count
Note:
- For Host Version 4 Enable = 0, the Host driver does not program the system address in this register while operating in ADMA mode. The system address must be programmed in the ADMA System Address register.
- For Host Version 4 Enable = 0, the Host driver programs a non-zero 32-bit block count value in this register when Auto CMD23 is enabled for non-DMA and ADMA modes. Auto CMD23 cannot be used with SDMA.
- This register must be programmed with a non-zero value for data transfer if the 32-bit Block count register is used instead of the 16-bit Block count register.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_SLOT_INTR_STATUS_R_REG</name>
	<description>This register indicates the Interrupt status of each slot.</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>INTR_SLOT</name>
	<description>Interrupt signal for each Slot     

These status bits indicate the logical OR of Interrupt signal and Wakeup signal for each slot. A maximum of 8 slots can be defined. If one interrupt signal is associated with multiple slots, the Host
Driver can identify the interrupt that is generated by reading these bits. By a power on reset or by setting Software Reset For All bit, the interrupt signals are de-asserted and this status reads 00h.
- Bit 00: Slot 1
- Bit 01: Slot 2
- Bit 02: Slot 3
- ..........
- ..........
- Bit 07: Slot 8

Note: MSHC Host Controller support single card slot. This register shall always return 0.

</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>EMMC_SW_RST_R_REG</name>
	<description>This register is used to generate a reset pulse by writing 1 to each bit of this register. After completing the reset, the Host</description>
	<addressOffset>0x0000002f</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SW_RST_DAT</name>
	<description>Software Reset For DAT line.
This bit is used in SD/eMMC mode and it resets only a part of the data circuit and the DMA circuit is also reset.
The following registers and bits are cleared by this bit:
- Buffer Data Port register
-- Buffer is cleared and initialized.  
- Present state register
-- Buffer Read Enable
-- Buffer Write Enable
-- Read Transfer Active
-- Write Transfer Active
-- DAT Line Active
-- Command Inhibit (DAT)
- Block Gap Control register
-- Continue Request 
-- Stop At Block Gap Request
- Normal Interrupt status register
-- Buffer Read Ready
-- Buffer Write Ready
-- DMA Interrupt
-- Block Gap Event
-- Transfer Complete

Values:
0x0 (FALSE): Work
0x1 (TRUE): Reset</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_RST_CMD</name>
	<description>Software Reset For CMD line.
This bit resets only a part of the command circuit to be able to issue a command.  This reset is effective only for a command issuing circuit (including response error statuses related to Command Inhibit (CMD) control) and does not affect the data transfer circuit. Host Controller can continue data transfer even after this reset is executed while handling subcommand-response errors.
The following registers and bits are cleared by this bit:
- Present State register : Command Inhibit (CMD) bit
- Normal Interrupt Status register : Command Complete bit
- Error Interrupt Status : Response error statuses related to Command Inhibit (CMD) bit

Values:
0x0 (FALSE): Work
0x1 (TRUE): Reset</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_RST_ALL</name>
	<description>Software Reset For All.
This reset affects the entire Host Controller except for the card detection circuit. During its initialization, the Host Driver sets this bit to 1 to reset the Host Controller. All registers are reset except the capabilities register. If this bit is set to 1, the Host Driver must issue reset command and reinitialize the card.

Values:
0x0 (FALSE): Work
0x1 (TRUE): Reset</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_TOUT_CTRL_R_REG</name>
	<description>This register is used to set the Data Timeout Counter value for an SD/eMMC mode according to the timer clock defined by the Cap</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>TOUT_CNT</name>
	<description>Data Timeout Counter Value.
This value determines the interval by which DAT line timeouts are detected. The Timeout clock frequency is generated by dividing the base clock TMCLK value by this value. When setting this
register, prevent inadvertent timeout events by clearing the Data Timeout Error Status Enable (in the Error Interrupt Status Enable register).
The values for these bits are:
- 0xF :  Reserved
- 0xE : TMCLK x 2^27
- 0x1 : TMCLK x 2^14
- 0x0 : TMCLK x 2^13
Note: During a boot operating in an eMMC mode, an application must configure the boot data timeout value (approximately 1 sec) in this bit.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_WUP_CTRL_R_REG</name>
	<description>This register is mandatory for the Host Controller, but the wakeup functionality depends on the Host Controller system hardware</description>
	<addressOffset>0x0000002b</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CARD_REMOVAL</name>
	<description>Wakeup Event Enable on SD Card Removal.
This bit enables wakeup event through Card Removal assertion in the Normal Interrupt Status register. For the SDIO card, Wake Up Support (FN_WUS) in the Card Information Structure (CIS) register does not affect this bit.

Values:

0x0 (DISABLED): Disable
0x1 (ENABLED): Enable
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_INSERT</name>
	<description>Wakeup Event Enable on SD Card Insertion.
This bit enables wakeup event through Card Insertion assertion in the Normal Interrupt Status register. FN_WUS (Wake Up Support) in CIS does not affect this bit.

Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CARD_INT</name>
	<description>Wakeup Event Enable on Card Interrupt.
This bit enables wakeup event through a Card Interrupt assertion in the Normal Interrupt Status register. This bit can be set to 1 if FN_WUS (Wake Up Support) in CIS is set to 1.

Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>EMMC_XFER_MODE_R_REG</name>
	<description>This register is used to control the operation of data transfers for an SD/eMMC mode. The Host driver sets this register before</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESP_INT_DISABLE</name>
	<description>Response Interrupt Disable.
The Host Controller supports response check function to avoid overhead of response error check by the Host driver. Response types of only R1 and R5 can be checked by the Controller.
If Host Driver checks the response error, set this bit to 0 and wait for Command Complete Interrupt and then check
the response register.
If the Host Controller checks the response error, set this bit to 1 and set the Response Error Check Enable bit to 1. The Command Complete Interrupt is disabled by this bit
regardless of the Command Complete Signal Enable.
Note: During tuning (when the Execute Tuning bit in the Host Control2 register is set), the Command Complete Interrupt is not generated irrespective of the Response Interrupt Disable setting.

Values:
0x0 (ENABLED): Response Interrupt is enabled
0x1 (DISABLED): Response Interrupt is disabled
</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_ERR_CHK_ENABLE</name>
	<description>Response Error Check Enable.
The Host Controller supports response check function to avoid overhead of response error check by Host driver. Response types of only R1 and R5 can be checked by the Controller.
If the Host Controller checks the response error, set this bit to 1 and set Response Interrupt Disable to 1. If an error is detected, the Response Error interrupt is generated in the Error Interrupt Status register.
Note:
- Response error check must not be enabled for any response type other than R1 and R5.
- Response check must not be enabled for the tuning command.

Values:
0x0 (DISABLED): Response Error Check is disabled
0x1 (ENABLED): Response Error Check is enabled
</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_TYPE</name>
	<description>Response Type R1/R5.
This bit selects either R1 or R5 as a response type when the Response Error Check is selected.
Error statuses checked in R1:
- OUT_OF_RANGE
- ADDRESS_ERROR
- BLOCK_LEN_ERROR
- WP_VIOLATION
- CARD_IS_LOCKED
- COM_CRC_ERROR
- CARD_ECC_FAILED
- CC_ERROR
- ERROR
Response Flags checked in R5:
- COM_CRC_ERROR
- ERROR
- FUNCTION_NUMBER
- OUT_OF_RANGE

Values:
0x0 (RESP_R1): R1 (Memory)
0x1 (RESP_R5): R5 (SDIO)
</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MULTI_BLK_SEL</name>
	<description>Multi/Single Block Select.
This bit is set when issuing multiple-block transfer commands using the DAT line. If this bit is set to 0, it is not necessary to set the Block Count register.

Values:
0x0 (SINGLE): Single Block
0x1 (MULTI): Multiple Block
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DATA_XFER_DIR</name>
	<description>Data Transfer Direction Select.
This bit defines the direction of DAT line data transfers. This bit is set to 1 by the Host Driver to transfer data
from the SD/eMMC card to the Host Controller and it is set to 0 for all other commands.

Values:
0x1 (READ): Read (Card to Host)
0x0 (WRITE): Write (Host to Card)
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUTO_CMD_ENABLE</name>
	<description>Auto Command Enable.
This field determines use of Auto Command functions.
Note: In SDIO, this field must be set as 00b (Auto Command Disabled).

Values:
0x0 (AUTO_CMD_DISABLED): Auto Command Disabled
0x1 (AUTO_CMD12_ENABLED): Auto CMD12 Enable
0x2 (AUTO_CMD23_ENABLED): Auto CMD23 Enable
0x3 (AUTO_CMD_AUTO_SEL): Auto CMD Auto Select
</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLOCK_COUNT_ENABLE</name>
	<description>Block Count Enable.
This bit is used to enable the Block Count register, which is relevant for multiple block transfers.
If this bit is set to 0, the Block Count register is disabled, which is useful in executing an infinite transfer. The Host Driver must set this bit to 0 when ADMA is used.

Values:
0x1 (ENABLED): Enable
0x0 (DISABLED): Disable
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_EN_EMMC</name>
	<description>DMA Enable.
This bit enables the DMA functionality. If this bit is set to 1, a DMA operation begins when the Host Driver writes to the Command register. You can select one of the DMA modes by using DMA Select in the Host Control 1 register.

Values:
0x1 (ENABLED): DMA Data transfer
0x0 (DISABLED): No data transfer or Non-DMA data
transfer
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPADC</name>
	<version>1.0</version>
	<description>GPADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020800</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GP_ADC_CLEAR_INT_REG</name>
	<description>General Purpose ADC Clear Interrupt Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL2_REG</name>
	<description>General Purpose ADC Second Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_STORE_DEL</name>
	<description>0: Data is stored after handshake synchronisation
1: Data is stored 2 ADC_CLK cycles after internal start trigger
7: Data is stored 8 ADC_CLK cycles after internal start trigger</description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SMPL_TIME</name>
	<description>0: The sample time (switch is closed) is two ADC_CLK cycles
1: The sample time is 1*8 ADC_CLK cycles
2: The sample time is 2*8 ADC_CLK cycles
15: The sample time is 15*8 ADC_CLK cycles</description>
	<bitRange>[12:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONV_NRS</name>
	<description>0: 1 sample is taken or 2 in case ADC_CHOP is active.
1: 2 samples are taken.
2: 4 samples are taken.
7: 128 samples are taken.</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_I20U</name>
	<description>1: Adds 20uA constant load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_ATTN</name>
	<description>0: No attenuator (input voltages up to 0.9V allowed)
1: Enabling 2x attenuator (input voltages up to 1.8V allowed)
2: Enabling 3x attenuator (input voltages up to 2.7V allowed)
3: Enabling 4x attenuator (input voltages up to 3.6V allowed)
Enabling the attenuator requires a longer sampling time.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL3_REG</name>
	<description>General Purpose ADC Third Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_INTERVAL</name>
	<description>Defines the interval between two ADC conversions in case GP_ADC_CONT is set.
0: No extra delay between two conversions.
1: 1.024 ms interval between two conversions.
2: 2.048 ms interval between two conversions.
255: 261.12 ms interval between two conversions.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN_DEL</name>
	<description>Defines the delay for enabling the ADC after enabling the LDO.
0: Not allowed
1: 4x ADC_CLK period.
n: n*4x ADC_CLK period.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00010000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>GP_ADC_RESULT_MODE</name>
	<description>Sample mode
0: Sample extention, the result is aligned on the MSBs. The lowest calculated LSB is extended over the unused bits.
1: Sample truncation, the result is aligned on the 8 LSBs. Any additional accurancy isn't available.
2: Normal mode, the result is aligned on the MSBs. Any unused LSBs are kept zero.
3: N.A.</description>
	<bitRange>[16:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_DIE_TEMP_EN</name>
	<description>Enables the die-temperature sensor. Output can be measured on GPADC input 4.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_DIFF_TEMP_SEL</name>
	<description>0= Gnd, 1 =sensor near radio, 2 =sensor near charger, 3 =sensor near bandgap
with sensors disabled (GP_ADC_DIFF_TEMP_EN = 0) :0 = GND 1 = Z, 2= V(ntc) from charger, 3 = V(temp) from charger</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_DIFF_TEMP_EN</name>
	<description>1: Enable the on-chip temperature sensors</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_LDO_HOLD</name>
	<description>0: GPADC LDO tracking bandgap reference
1: GPADC LDO hold sampled bandgap reference</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CHOP</name>
	<description>0: Chopper mode off
1: Chopper mode enabled. Takes two samples with opposite GP_ADC_SIGN to cancel the internal offset voltage of the ADC; Highly recommended for DC-measurements.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SIGN</name>
	<description>0: Default
1: Conversion with opposite sign at input and output to cancel out the internal offset of the ADC and low-frequency</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MUTE</name>
	<description>0: Normal operation
1: Mute ADC input. Takes sample at mid-scale (to dertermine the internal offset and/or noise of the ADC with regards to VDD_REF which is also sampled by the ADC).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SE</name>
	<description>0: Differential mode
1: Single ended mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MINT</name>
	<description>0: Disable (mask) GP_ADC_INT.
1: Enable GP_ADC_INT to ICU.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to GP_ADC_CLEAR_INT_REG.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GP_ADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the GP_ADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in GP_ADC_RESULT_REG. Still GP_ADC_START has to be set to start the execution. The time between conversions is configurable with GP_ADC_INTERVAL.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN</name>
	<description>0: LDO is off and ADC is disabled..
1: LDO is turned on and afterwards the ADC is enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFN_REG</name>
	<description>General Purpose ADC Negative Offset Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFN</name>
	<description>Offset adjust of 'negative' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=1 OR GP_ADC_CHOP=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFP_REG</name>
	<description>General Purpose ADC Positive Offset Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFP</name>
	<description>Offset adjust of 'positive' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=0 OR GP_ADC_CHOP=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_VAL</name>
	<description>Returns the 10 up to 16 bits linear value of the last AD conversion. The upper 10 bits are always valid, the lower 6 bits are only valid in case oversampling has been applied. Two samples results in one extra bit and 64 samples results in six extra bits.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_SEL_REG</name>
	<description>General Purpose ADC Input Selection Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>GP_ADC_LDO_SENSE_SEL</name>
	<description>Enable and select the current sensing logic for one of the LDO's
0: LDO current sense disabled
1: Sense current of LDO_SUPPLY_VBUS (V33)
2: Sense current of LDO_1V4
3: Sense current of LDO_1V8
4: Sense current of LDO_CORE (VDD1V2)
5: Sense current of LDO_1V8P
6: Sense current of LDO_SUPPLY_VBAT (V33)
7: Reserved</description>
	<bitRange>[16:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL_MUX2</name>
	<description>0: No rail selected
1: V18P
2: V18
3: V14
4: V12
5: VSYS monitor
6: VBUS monitor
7: VBAT monitor</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL_MUX1</name>
	<description>0: No rail selected
1: NC
2: Reserved
3: I_sense_bus
4: Reserved
5: V30
6: VMIPI
7: V18F</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL_P_TST</name>
	<description>When set to 1, GP_ADC_SEL_P selection becomes
0: VSSA
1: VDDA_CONT
2: RF_TEST_OUT[0]
3: RF_TEST_OUT[1]
4: RF_TEST_IN[0]
5: RF_TEST_IN[1]
6: ANA_TEST
7: Bandgap Current sensing</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL_P</name>
	<description>ADC positive input selection.
0: ADC0 (P1[0])
1: ADC1 (P1[1])
2: ADC2 (P1[2])
3: ADC3 (P0[10])
4: Temperature Sensor
5: VBAT_HIGH
6: VBAT_LOW
7: VDDD</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL_N</name>
	<description>ADC negative input selection. Differential only (GP_ADC_SE=0).
0: ADC0 (P1[0])
1: ADC1 (P1[1])
2: ADC2 (P1[2])
3: ADC3 (P0[10])
All other combinations are reserved.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_TRIM_REG</name>
	<description>General Purpose ADC Trim Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>GP_ADC_LDO_LEVEL</name>
	<description>GPADC LDO level
0: 825mV
1: 850mV
2: 875mV
3: 900mV (reset)
4: 925mV (default)
5: 950mV
6: 975mV
7:1000mV</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPIO</name>
	<version>1.0</version>
	<description>GPIO registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>388</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GPIO_CLK_SEL_REG</name>
	<description>Select which clock to map on ports P0/P1</description>
	<addressOffset>0x0000016c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>DIVN_OUTPUT_EN</name>
	<description>DIVN output enable bit-field. When set, it enables the mapping of DIVN clock on dedicated GPIO (P0_20). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_OUTPUT_EN</name>
	<description>XTAL32M output enable bit-field. When set, it enables the mapping of XTAL32M clock on dedicated GPIO (P1_04). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_OUTPUT_EN</name>
	<description>RCX output enable bit-field. When set, it enables the mapping of RCX clock on dedicated GPIO (P1_22). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCLP_OUTPUT_EN</name>
	<description>RCLP output enable bit-field. When set, it enables the mapping of RCLP clock on dedicated GPIO (P1_23). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_OUTPUT_EN</name>
	<description>XTAL32K output enable bit-field. When set, it enables the mapping of XTAL32K clock on dedicated GPIO (P0_31).The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FUNC_CLOCK_EN</name>
	<description>If set, it enables the mapping of the selected clock signal, according to FUNC_CLOCK_SEL bit-field.
The clock can be mapped to any GPIO (PX_YY), as long as PX_YY_MODE_REG[PID]= (FUNC_CLOCK) and PX_YY_MODE_REG[PUPD]=3 (Output). Bits 4-9 are ignored in this case. If not set, then each clock is mapped to a dedicated GPIO, according to bits 4-9.&quot;</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FUNC_CLOCK_SEL</name>
	<description>Select which clock to map when PID = FUNC_CLOCK.
0x0: XTAL32K
0x1: RCLP
0x2: RCX
0x3: XTAL32M
0x4: DIVN
0x5: Reserved
0x6: Reserved
0x7: Reserved
FUNC_CLOCK_EN = 1 else masked</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_MAP_CTRL_REG</name>
	<description>LCDC mapping control Register</description>
	<addressOffset>0x0000017c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>MAP_ON_P1_07_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P1_07, overruling P1_07_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : Not applicable
  - MIPI DPI-2   : Not applicable
  - MIPI DBI-B  : DBIB_DB7 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F : Not applicable</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P1_01_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P1_01, overruling P1_01_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F   : BLUE0 (Output)
  - MIPI DPI-2    : DPI_BLUE0 (DATA[4]) (Output)
  - MIPI DBI-B   : DBIB_DB4 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F  : Not applicable</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P1_00_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P1_00, overruling P1_00_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F : GREEN1 (Output)
  - MIPI DPI-2   : DPI_GREEN1 (DATA[3]) (Output)
  - MIPI DBI-B  : DBIB_DB3 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F : Not applicable</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_24_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_24, overruling P0_24_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F : GREEN0 (Output)
  - MIPI DPI-2  : DPI_GREEN0 (DATA[2]) (Output)
  - MIPI DBI-B  : DBIB_DB2 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F : Not applicable</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_23_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_23, overruling P0_23_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : RED1 (Output)
  - MIPI DPI-2   : DPI_RED1 (DATA[1]) (Output)
  - MIPI DBI-B   : DBIB_DB1 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F  : Not applicable</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_22_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_22, overruling P0_22_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : XRST (Output)
  - MIPI DPI-2   : DPI_SD (Output)
  - MIPI DBI-B   : DBIB_RDX (Output)
  - LCD SPI I/F  : LCD_SPI_SD2 (Output)</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_21_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_21, overruling P0_21_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : BLUE1 (Output)
  - MIPI DPI-2   : DPI_BLUE1 (DATA[5]) (Output)
  - MIPI DBI-B   : DBIB_DB5 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F  : Not applicable</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_19_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_19, overruling P0_19_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : VCOM/FRP (Input)
  - MIPI DPI-2   : Not applicable
  - MIPI DBI-B   : DBIB_DB6 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F  : EXTCOMIN (Input)</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_18_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_18, overruling P0_18_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : ENB (Output)
  - MIPI DPI-2   : DPI_DE (Output)
  - MIPI DBI-B   : DBIB_RESX (Output)
  - LCD SPI I/F  : LCD_SPI_CS (Output)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_17_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_17, overruling P0_17_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : RED0 (Output)
  - MIPI DPI-2   : DPI_RED0 (DATA[0]) (Output)
  - MIPI DBI-B   : DBIB_DB0 (direction controlled by the LCDC DBI-B I/F)
  - LCD SPI I/F  : LCD_SPI_SD3 (Output)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_16_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_16, overruling P0_16_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : VST (Output)
  - MIPI DPI-2   : DPI_VSYNC (Output)
  - MIPI DBI-B   : DBIB_WRX (Output)
  - LCD SPI I/F  : LCD_SPI_SD1 (Output)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_15_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_15, overruling P0_15_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : HST (Output)
  - MIPI DPI-2   : DPI_HSYNC (Output)
  - MIPI DBI-B   : DBIB_D/CS (Output)
  - LCD SPI I/F  : LCD_SPI_SD (direction controlled by the LCDC SPI I/F)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_14_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_14, overruling P0_14_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F : HCK (Output)
  - MIPI DPI-2   : DPI_CLK (Output)
  - MIPI DBI-B  : DBIB_CSX (Output)
  - LCD SPI I/F : LCD_SPI_SCLK (Output)</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_10_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_10, overruling P0_10_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F : XFRP (Input)
  - MIPI DPI-2   : DPI_READY (Input)
  - MIPI DBI-B  : DBIB_TE (Input)
  - LCD SPI I/F : LCD_TE (Input)</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_ON_P0_09_EN</name>
	<description>0 = Normal operation
1 = Enables the mapping of LCDC signals on P0_09, overruling P0_09_MODE_REG. The signals mapped, depending on the mode, are the following:
  - JDI LCD I/F  : VCK (Output)
  - MIPI DPI-2   : DPI_CM (Output)
  - MIPI DPI-B  : DBIB_STALL (Input)
  - LCD SPI I/F : LCD_SPI_SI (Input)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_00_MODE_REG</name>
	<description>P0_00 Mode Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port:
0: GPIO
1: UART_RX
2: UART_TX
3: UART2_RX
4: UART2_TX
5: UART2_CTSN
6: UART2_RTSN
7: UART3_RX
8: UART3_TX
9: UART3_CTSN / ISO_RST
10: UART3_RTSN / ISO_CARDINSERT
11: ISO_CLK
12: ISO_DATA
13: SPI_DI
14: SPI_DO
15: SPI_CLK
16: SPI_EN
17: SPI_EN2
18: SPI2_DI
19: SPI2_DO
20: SPI2_CLK
21: SPI2_EN
22: SPI2_EN2
23: SPI3_EN
24: SPI3_EN2
25: I2C_SCL
26: I2C_SDA
27: I2C2_SCL
28: I2C2_SDA
29: I2C3_SCL
30: I2C3_SDA
31: I3C_SCL
32: I3C_SDA
33: USB_SOF
34: ADC (Analog)
35: USB (P2_10 and P2_11)
36: PCM_DI
37: PCM_DO
38: PCM_FSC
39: PCM_CLK
40: PDM_DATA
41: PDM_CLK
42: COEX_EXT_ACT
43: COEX_SMART_ACT
44: COEX_SMART_PRI
45: PORT0_DCF
46: PORT1_DCF
47: PORT2_DCF
48: PORT3_DCF
49: PORT4_DCF
50: CLOCK (see also GPIO_CLK_SEL_REG for the dedicated pins mapping of supported clocks)
51: TIM_PWM
52: TIM2_PWM
53: TIM3_PWM
54: TIM4_PWM
55: TIM5_PWM
56: TIM6_PWM
57: TIM_1SHOT
58: TIM2_1SHOT
59: TIM3_1SHOT
60: TIM4_1SHOT
61: TIM5_1SHOT
62: TIM6_1SHOT
63: CMAC_DIAG (Dedicated Pins)
</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_01_MODE_REG</name>
	<description>P0_01 Mode Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_02_MODE_REG</name>
	<description>P0_02 Mode Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_03_MODE_REG</name>
	<description>P0_03 Mode Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_04_MODE_REG</name>
	<description>P0_04 Mode Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_05_MODE_REG</name>
	<description>P0_05 Mode Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_06_MODE_REG</name>
	<description>P0_06 Mode Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_07_MODE_REG</name>
	<description>P0_07 Mode Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_08_MODE_REG</name>
	<description>P0_08 Mode Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID] </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_09_MODE_REG</name>
	<description>P0_09 Mode Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID] </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_10_MODE_REG</name>
	<description>P0_10 Mode Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_11_MODE_REG</name>
	<description>P0_11 Mode Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_12_MODE_REG</name>
	<description>P0_12 Mode Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_13_MODE_REG</name>
	<description>P0_13 Mode Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_14_MODE_REG</name>
	<description>P0_14 Mode Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_15_MODE_REG</name>
	<description>P0_15 Mode Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_16_MODE_REG</name>
	<description>P0_16 Mode Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_17_MODE_REG</name>
	<description>P0_17 Mode Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_18_MODE_REG</name>
	<description>P0_18 Mode Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_19_MODE_REG</name>
	<description>P0_19 Mode Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_20_MODE_REG</name>
	<description>P0_20 Mode Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_21_MODE_REG</name>
	<description>P0_21 Mode Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_22_MODE_REG</name>
	<description>P0_22 Mode Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_23_MODE_REG</name>
	<description>P0_23 Mode Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_24_MODE_REG</name>
	<description>P0_24 Mode Register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_25_MODE_REG</name>
	<description>P0_25 Mode Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_26_MODE_REG</name>
	<description>P0_26 Mode Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_27_MODE_REG</name>
	<description>P0_27 Mode Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_28_MODE_REG</name>
	<description>P0_28 Mode Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_29_MODE_REG</name>
	<description>P0_29 Mode Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_30_MODE_REG</name>
	<description>P0_30 Mode Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_31_MODE_REG</name>
	<description>P0_31 Mode Register</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_DATA_REG</name>
	<description>P0 Data input / output Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00003015</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_DATA</name>
	<description>Set P0 output register when written; Returns the value of P0 port when read </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_PADPWR_CTRL_REG</name>
	<description>P0 Output Power Control Register</description>
	<addressOffset>0x00000160</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_31_OUT_CTRL</name>
	<description>0 = P0_31 port output is powered by the V30 rail (default)
1 = P0_31 port output is powered by the 1V8P rail
Bit 31 controls the power supply of P0_31.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_30_OUT_CTRL</name>
	<description>0 = P0_30 port output is powered by the V30 rail (default)
1 = P0_30 port output is powered by the 1V8P rail
Bit 30 controls the power supply of P0_30.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_29_OUT_CTRL</name>
	<description>0 = P0_29 port output is powered by the V30 rail (default)
1 = P0_29 port output is powered by the 1V8P rail
Bit 29 controls the power supply of P0_29.</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_28_OUT_CTRL</name>
	<description>0 = P0_28 port output is powered by the V30 rail (default)
1 = P0_28 port output is powered by the 1V8P rail
Bit 28 controls the power supply of P0_28.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_27_OUT_CTRL</name>
	<description>0 = P0_27 port output is powered by the V30 rail (default)
1 = P0_27 port output is powered by the 1V8P rail
Bit 27 controls the power supply of P0_27.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_24_OUT_CTRL</name>
	<description>0 = P0_24 port output is powered by the V30 rail (default)
1 = P0_24 port output is powered by the 1V8P rail
Bit 24 controls the power supply of P0_24.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_23_OUT_CTRL</name>
	<description>0 = P0_23 port output is powered by the V30 rail (default)
1 = P0_23 port output is powered by the 1V8P rail
Bit 23 controls the power supply of P0_23.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_22_OUT_CTRL</name>
	<description>0 = P0_22 port output is powered by the V30 rail (default)
1 = P0_22 port output is powered by the 1V8P rail
Bit 22 controls the power supply of P0_22.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_21_OUT_CTRL</name>
	<description>0 = P0_21 port output is powered by the V30 rail (default)
1 = P0_21 port output is powered by the 1V8P rail
Bit 21 controls the power supply of P0_21.</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_20_OUT_CTRL</name>
	<description>0 = P0_20 port output is powered by the V30 rail (default)
1 = P0_20 port output is powered by the 1V8P rail
Bit 20 controls the power supply of P0_20.</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_19_OUT_CTRL</name>
	<description>0 = P0_19 port output is powered by the V30 rail (default)
1 = P0_19 port output is powered by the 1V8P rail
Bit 19 controls the power supply of P0_19.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_18_OUT_CTRL</name>
	<description>0 = P0_18 port output is powered by the V30 rail (default)
1 = P0_18 port output is powered by the 1V8P rail
Bit 18 controls the power supply of P0_18.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_17_OUT_CTRL</name>
	<description>0 = P0_17 port output is powered by the V30 rail (default)
1 = P0_17 port output is powered by the 1V8P rail
Bit 17 controls the power supply of P0_17.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_16_OUT_CTRL</name>
	<description>0 = P0_16 port output is powered by the V30 rail (default)
1 = P0_16 port output is powered by the 1V8P rail
Bit 16 controls the power supply of P0_16.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_15_OUT_CTRL</name>
	<description>0 = P0_15 port output is powered by the V30 rail (default)
1 = P0_15 port output is powered by the 1V8P rail
Bit 15 controls the power supply of P0_15.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_14_OUT_CTRL</name>
	<description>0 = P0_14 port output is powered by the V30 rail (default)
1 = P0_14 port output is powered by the 1V8P rail
Bit 14 controls the power supply of P0_14.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_11_OUT_CTRL</name>
	<description>0 = P0_11 port output is powered by the V30 rail (default)
1 = P0_11 port output is powered by the 1V8P rail
Bit 11 controls the power supply of P0_11.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_10_OUT_CTRL</name>
	<description>0 = P0_10 port output is powered by the V30 rail (default)
1 = P0_10 port output is powered by the 1V8P rail
Bit 10 controls the power supply of P0_10.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_09_OUT_CTRL</name>
	<description>0 = P0_09 port output is powered by the V30 rail (default)
1 = P0_09 port output is powered by the 1V8P rail
Bit 9 controls the power supply of P0_09.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_08_OUT_CTRL</name>
	<description>0 = P0_08 port output is powered by the V30 rail (default)
1 = P0_08 port output is powered by the 1V8P rail
Bit 8 controls the power supply of P0_08.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_07_OUT_CTRL</name>
	<description>0 = P0_07 port output is powered by the V30 rail (default)
1 = P0_07 port output is powered by the 1V8P rail
Bit 7 controls the power supply of P0_07.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_06_OUT_CTRL</name>
	<description>0 = P0_06 port output is powered by the V30 rail (default)
1 = P0_06 port output is powered by the 1V8P rail
Bit 6 controls the power supply of P0_06.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_05_OUT_CTRL</name>
	<description>0 = P0_05 port output is powered by the V30 rail (default)
1 = P0_05 port output is powered by the 1V8P rail
Bit 5 controls the power supply of P0_05.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_04_OUT_CTRL</name>
	<description>0 = P0_04 port output is powered by the V30 rail (default)
1 = P0_04 port output is powered by the 1V8P rail
Bit 4 controls the power supply of P0_04.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_03_OUT_CTRL</name>
	<description>0 = P0_03 port output is powered by the V30 rail (default)
1 = P0_03 port output is powered by the 1V8P rail
Bit 3 controls the power supply of P0_03.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_02_OUT_CTRL</name>
	<description>0 = P0_02 port output is powered by the V30 rail (default)
1 = P0_02 port output is powered by the 1V8P rail
Bit 2 controls the power supply of P0_02.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_01_OUT_CTRL</name>
	<description>0 = P0_01 port output is powered by the V30 rail (default)
1 = P0_01 port output is powered by the 1V8P rail
Bit 1 controls the power supply of P0_01.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_00_OUT_CTRL</name>
	<description>0 = P0_00 port output is powered by the V30 rail (default)
1 = P0_00 port output is powered by the 1V8P rail
Bit 0 controls the power supply of P0_00.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_DATA_REG</name>
	<description>P0 Reset port pins Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_RESET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_SET_DATA_REG</name>
	<description>P0 Set port pins Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_SET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_WEAK_CTRL_REG</name>
	<description>P0 Weak Pads Control Register</description>
	<addressOffset>0x00000170</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P0_31_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_31 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_30_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_30 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_29_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_29 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_28_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_28 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_27_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_27 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_24_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_24 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_23_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_23 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_22_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_22 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_21_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_21 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_20_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_20 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_19_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_19 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_18_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_18 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_17_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_17 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_16_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_16 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_15_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_15 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_14_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_14 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_11_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_11 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_10_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_10 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_09_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_09 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_08_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_08 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_07_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_07 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_06_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_06 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_05_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_05 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_04_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_04 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_03_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_03 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_02_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_02 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_01_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_01 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_00_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P0_00 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P0_PADPWDR_CTRL_REG).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_00_MODE_REG</name>
	<description>P1_00 Mode Register</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_01_MODE_REG</name>
	<description>P1_01 Mode Register</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_02_MODE_REG</name>
	<description>P1_02 Mode Register</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_03_MODE_REG</name>
	<description>P1_03 Mode Register</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_04_MODE_REG</name>
	<description>P1_04 Mode Register</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_05_MODE_REG</name>
	<description>P1_05 Mode Register</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_06_MODE_REG</name>
	<description>P1_06 Mode Register</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_07_MODE_REG</name>
	<description>P1_07 Mode Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_08_MODE_REG</name>
	<description>P1_08 Mode Register</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_09_MODE_REG</name>
	<description>P1_09 Mode Register</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_10_MODE_REG</name>
	<description>P1_10 Mode Register</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_11_MODE_REG</name>
	<description>P1_11 Mode Register</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_12_MODE_REG</name>
	<description>P1_12 Mode Register</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_13_MODE_REG</name>
	<description>P1_13 Mode Register</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_14_MODE_REG</name>
	<description>P1_14 Mode Register</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_15_MODE_REG</name>
	<description>P1_15 Mode Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_16_MODE_REG</name>
	<description>P1_16 Mode Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_17_MODE_REG</name>
	<description>P1_17 Mode Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_18_MODE_REG</name>
	<description>P1_18 Mode Register</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_19_MODE_REG</name>
	<description>P1_19 Mode Register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_20_MODE_REG</name>
	<description>P1_20 Mode Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_21_MODE_REG</name>
	<description>P1_21 Mode Register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_22_MODE_REG</name>
	<description>P1_22 Mode Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_23_MODE_REG</name>
	<description>P1_23 Mode Register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_24_MODE_REG</name>
	<description>P1_24 Mode Register</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_25_MODE_REG</name>
	<description>P1_25 Mode Register</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_26_MODE_REG</name>
	<description>P1_26 Mode Register</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_27_MODE_REG</name>
	<description>P1_27 Mode Register</description>
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_28_MODE_REG</name>
	<description>P1_28 Mode Register</description>
	<addressOffset>0x00000114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_29_MODE_REG</name>
	<description>P1_29 Mode Register</description>
	<addressOffset>0x00000118</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_30_MODE_REG</name>
	<description>P1_30 Mode Register</description>
	<addressOffset>0x0000011c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_31_MODE_REG</name>
	<description>P1_31 Mode Register</description>
	<addressOffset>0x00000120</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_DATA_REG</name>
	<description>P1 Data input / output Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x20000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_DATA</name>
	<description>Set P1 output register when written; Returns the value of P1 port when read </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_PADPWR_CTRL_REG</name>
	<description>P1 Output Power Control Register</description>
	<addressOffset>0x00000164</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_31_OUT_CTRL</name>
	<description>0 = P1_31 port output is powered by the V30 rail (default)
1 = P1_31 port output is powered by the 1V8P rail
Bit 31 controls the power supply of P1_31.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_30_OUT_CTRL</name>
	<description>0 = P1_30 port output is powered by the V30 rail (default)
1 = P1_30 port output is powered by the 1V8P rail
Bit 30 controls the power supply of P1_30.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_27_OUT_CTRL</name>
	<description>0 = P1_27 port output is powered by the V30 rail (default)
1 = P1_27 port output is powered by the 1V8P rail
Bit 27 controls the power supply of P1_27.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_26_OUT_CTRL</name>
	<description>0 = P1_26 port output is powered by the V30 rail (default)
1 = P1_26 port output is powered by the 1V8P rail
Bit 26 controls the power supply of P1_26.</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_25_OUT_CTRL</name>
	<description>0 = P1_25 port output is powered by the V30 rail (default)
1 = P1_25 port output is powered by the 1V8P rail
Bit 25 controls the power supply of P1_25.</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_24_OUT_CTRL</name>
	<description>0 = P1_24 port output is powered by the V30 rail (default)
1 = P1_24 port output is powered by the 1V8P rail
Bit 24 controls the power supply of P1_24.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_23_OUT_CTRL</name>
	<description>0 = P1_23 port output is powered by the V30 rail (default)
1 = P1_23 port output is powered by the 1V8P rail
Bit 23 controls the power supply of P1_23.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_22_OUT_CTRL</name>
	<description>0 = P1_22 port output is powered by the V30 rail (default)
1 = P1_22 port output is powered by the 1V8P rail
Bit 30 controls the power supply of P1_22.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_20_OUT_CTRL</name>
	<description>0 = P1_20 port output is powered by the V30 rail (default)
1 = P1_20 port output is powered by the 1V8P rail
Bit 20 controls the power supply of P1_20.</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_19_OUT_CTRL</name>
	<description>0 = P1_19 port output is powered by the V30 rail (default)
1 = P1_19 port output is powered by the 1V8P rail
Bit 19 controls the power supply of P1_19.</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_15_OUT_CTRL</name>
	<description>0 = P1_15 port output is powered by the V30 rail (default)
1 = P1_15 port output is powered by the 1V8P rail
Bit 15 controls the power supply of P1_15.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_14_OUT_CTRL</name>
	<description>0 = P1_14 port output is powered by the V30 rail (default)
1 = P1_14 port output is powered by the 1V8P rail
Bit 14 controls the power supply of P1_14.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_13_OUT_CTRL</name>
	<description>0 = P1_13 port output is powered by the V30 rail (default)
1 = P1_13 port output is powered by the 1V8P rail
Bit 13 controls the power supply of P1_13.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_12_OUT_CTRL</name>
	<description>0 = P1_12 port output is powered by the V30 rail (default)
1 = P1_12 port output is powered by the 1V8P rail
Bit 12 controls the power supply of P1_12.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_11_OUT_CTRL</name>
	<description>0 = P1_11 port output is powered by the V30 rail (default)
1 = P1_11 port output is powered by the 1V8P rail
Bit 11 controls the power supply of P1_11.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_07_OUT_CTRL</name>
	<description>0 = P1_07 port output is powered by the V30 rail (default)
1 = P1_07 port output is powered by the 1V8P rail
Bit 7 controls the power supply of P1_07.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_06_OUT_CTRL</name>
	<description>0 = P1_06 port output is powered by the V30 rail (default)
1 = P1_06 port output is powered by the 1V8P rail
Bit 6 controls the power supply of P1_06.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_05_OUT_CTRL</name>
	<description>0 = P1_05 port output is powered by the V30 rail (default)
1 = P1_05 port output is powered by the 1V8P rail
Bit 5 controls the power supply of P1_05.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_04_OUT_CTRL</name>
	<description>0 = P1_04 port output is powered by the V30 rail (default)
1 = P1_04 port output is powered by the 1V8P rail
Bit 4 controls the power supply of P1_04.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_03_OUT_CTRL</name>
	<description>0 = P1_03 port output is powered by the V30 rail (default)
1 = P1_03 port output is powered by the 1V8P rail
Bit 3 controls the power supply of P1_03.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_01_OUT_CTRL</name>
	<description>0 = P1_01 port output is powered by the V30 rail (default)
1 = P1_01 port output is powered by the 1V8P rail
Bit 1 controls the power supply of P1_01.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_00_OUT_CTRL</name>
	<description>0 = P1_00 port output is powered by the V30 rail (default)
1 = P1_00 port output is powered by the 1V8P rail
Bit 0 controls the power supply of P1_00.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_RESET_DATA_REG</name>
	<description>P1 Reset port pins Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_RESET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_SET_DATA_REG</name>
	<description>P1 Set port pins Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_SET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_WEAK_CTRL_REG</name>
	<description>P1 Weak Pads Control Register</description>
	<addressOffset>0x00000174</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P1_31_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_30 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_30_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_30 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_27_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_27 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_26_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_26 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_25_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_25 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_24_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_24 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_23_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_23 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_22_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_22 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_20_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_20 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_19_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_19 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_15_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_15 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_14_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_14 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_13_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_13 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_12_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_12 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_11_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_11 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_07_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_07 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_06_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_06 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_05_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_05 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_04_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_04 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_03_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_03 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_01_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_01 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P1_00_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P1_00 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P1_PADPWDR_CTRL_REG).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_00_MODE_REG</name>
	<description>P2_00 Mode Register</description>
	<addressOffset>0x00000124</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_01_MODE_REG</name>
	<description>P2_01 Mode Register</description>
	<addressOffset>0x00000128</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_02_MODE_REG</name>
	<description>P2_02 Mode Register</description>
	<addressOffset>0x0000012c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_03_MODE_REG</name>
	<description>P2_03 Mode Register</description>
	<addressOffset>0x00000130</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_04_MODE_REG</name>
	<description>P2_04 Mode Register</description>
	<addressOffset>0x00000134</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_05_MODE_REG</name>
	<description>P2_05 Mode Register</description>
	<addressOffset>0x00000138</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_06_MODE_REG</name>
	<description>P2_06 Mode Register</description>
	<addressOffset>0x0000013c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_07_MODE_REG</name>
	<description>P2_07 Mode Register</description>
	<addressOffset>0x00000140</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_08_MODE_REG</name>
	<description>P2_08 Mode Register</description>
	<addressOffset>0x00000144</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_09_MODE_REG</name>
	<description>P2_09 Mode Register</description>
	<addressOffset>0x00000148</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_10_MODE_REG</name>
	<description>P2_10 Mode Register</description>
	<addressOffset>0x0000014c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_11_MODE_REG</name>
	<description>P2_11 Mode Register</description>
	<addressOffset>0x00000150</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_12_MODE_REG</name>
	<description>P2_12 Mode Register</description>
	<addressOffset>0x00000154</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_13_MODE_REG</name>
	<description>P2_13 Mode Register</description>
	<addressOffset>0x00000158</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_14_MODE_REG</name>
	<description>P2_14 Mode Register</description>
	<addressOffset>0x0000015c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_DATA_REG</name>
	<description>P1 Data input / output Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00006000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_DATA</name>
	<description>Set P2 output register when written; Returns the value of P2
port when read </description>
	<bitRange>[14:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_PADPWR_CTRL_REG</name>
	<description>P2 Output Power Control Register</description>
	<addressOffset>0x00000168</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_11_OUT_CTRL</name>
	<description>0 = P2_11 port output is powered by the V30 rail (default)
1 = P2_11 port output is powered by the 1V8P rail
Bit 11 controls the power supply of P2_11.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_10_OUT_CTRL</name>
	<description>0 = P2_10 port output is powered by the V30 rail (default)
1 = P2_10 port output is powered by the 1V8P rail
Bit 10 controls the power supply of P2_10.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_09_OUT_CTRL</name>
	<description>0 = P2_09 port output is powered by the V30 rail (default)
1 = P2_09 port output is powered by the 1V8P rail
Bit 9 controls the power supply of P2_09.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_08_OUT_CTRL</name>
	<description>0 = P2_08 port output is powered by the V30 rail (default)
1 = P2_08 port output is powered by the 1V8P rail
Bit 8 controls the power supply of P2_08.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_07_OUT_CTRL</name>
	<description>0 = P2_07 port output is powered by the V30 rail (default)
1 = P2_07 port output is powered by the 1V8P rail
Bit 7 controls the power supply of P2_07.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_06_OUT_CTRL</name>
	<description>0 = P2_06 port output is powered by the V30 rail (default)
1 = P2_06 port output is powered by the 1V8P rail
Bit 6 controls the power supply of P2_06.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_05_OUT_CTRL</name>
	<description>0 = P2_05 port output is powered by the V30 rail (default)
1 = P2_05 port output is powered by the 1V8P rail
Bit 5 controls the power supply of P2_05.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_04_OUT_CTRL</name>
	<description>0 = P2_04 port output is powered by the V30 rail (default)
1 = P2_04 port output is powered by the 1V8P rail
Bit 4 controls the power supply of P2_04.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_01_OUT_CTRL</name>
	<description>0 = P2_01 port output is powered by the V30 rail (default)
1 = P2_01 port output is powered by the 1V8P rail
Bit 1 controls the power supply of P2_01.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_RESET_DATA_REG</name>
	<description>P0 Reset port pins Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_RESET</name>
	<description>Writing a 1 to P2[y] sets P2[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[14:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P2_SET_DATA_REG</name>
	<description>P1 Set port pins Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_SET</name>
	<description>Writing a 1 to P2[y] sets P2[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[14:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P2_WEAK_CTRL_REG</name>
	<description>P2 Weak Pads Control Register</description>
	<addressOffset>0x00000178</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>P2_11_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_11 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_10_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_10 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_09_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_09 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_08_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_08 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_07_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_07 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_06_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_06 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_05_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_05 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_04_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_04 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P2_01_LOWDRV</name>
	<description>0 = Normal operation
1 = Reduces the driving strength of P2_01 pad
Note: This mode should be coupled with the selection of VDD1V8P supply rail for the specific pad (see also the description of P2_PADPWDR_CTRL_REG).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PAD_DRIVE_CTRL_REG</name>
	<description>Pad drive control for SPI3/SDIO/eMMC</description>
	<addressOffset>0x00000180</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fff</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>EMMC_DRIVE</name>
	<description>pads drive current
0: 4 mA
1: 8 mA
2: 12 mA
3: 16 mA</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMMC_SLEW</name>
	<description>pads slew rate control. Indicative values under certain conditions:
0: Rise=1.7 V/ns, Fall=1.9 V/ns (weak)
1: Rise=2.0 V/ns, Fall=2.3 V/ns
2: Rise=2.3 V/ns, Fall=2.6 V/ns
3: Rise=2.4 V/ns, Fall=2.7 V/ns (strong)
Conditions: external pin capacitance 6 pF, Vcc=1.8V, T=25C and Idrive=16mA.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDIO_DRIVE</name>
	<description>pads drive current
0: 4 mA
1: 8 mA
2: 12 mA
3: 16 mA</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDIO_SLEW</name>
	<description>QSPI pads slew rate control. Indicative values under certain conditions:
0: Rise=1.7 V/ns, Fall=1.9 V/ns (weak)
1: Rise=2.0 V/ns, Fall=2.3 V/ns
2: Rise=2.3 V/ns, Fall=2.6 V/ns
3: Rise=2.4 V/ns, Fall=2.7 V/ns (strong)
Conditions: FLASH pin capacitance 6 pF, Vcc=1.8V, T=25C and Idrive=16mA.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI3_DRIVE</name>
	<description>pads drive current
0: 4 mA
1: 8 mA
2: 12 mA
3: 16 mA</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI3_SLEW</name>
	<description>QSPI pads slew rate control. Indicative values under certain conditions:
0: Rise=1.7 V/ns, Fall=1.9 V/ns (weak)
1: Rise=2.0 V/ns, Fall=2.3 V/ns
2: Rise=2.3 V/ns, Fall=2.6 V/ns
3: Rise=2.4 V/ns, Fall=2.7 V/ns (strong)
Conditions: FLASH pin capacitance 6 pF, Vcc=1.8V, T=25C and Idrive=16mA.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPREG</name>
	<version>1.0</version>
	<description>GPREG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>28</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DEBUG_REG</name>
	<description>Various debug information register.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000101</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ETM_TRACE_MAP_ON_PINS_EN</name>
	<description>1: ETM/TPIU Trace signals mapped on GPIO pins is enabled.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_CPU_IS_HALTED</name>
	<description>1: SNC CPU is halted.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HALT_SNC_CPU_EN</name>
	<description>1: Enable halting the SNC CPU when the SYS CPU (ARM CM33) or CMAC CPU is halted.
Note 1: This bit is retained.
Note 2: Set this bit to '0' before going into deep sleep to prevent unpredictable halting behavior after waking up.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SNC_CPU_FREEZE_EN</name>
	<description>1: Enable Freezing on-chip peripherals (see Note 2) by the SNC CPU.
Note 1: This bit is retained.
Note 2: See [RE]SET_FREEZE_REG for the specific on-chip peripherals.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CROSS_CPU_HALT_SENSITIVITY</name>
	<description>Select the cross CPU halt sensitivity.
0: Level triggered,
1: Pulse triggered.
Note: This bit is retained.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPUWAIT_ON_JTAG</name>
	<description>1: Stall the processor core out of reset (only after a wake-up from JTAG). Debugger access continue when the core is stalled. When set to '0' again the core resumes instruction execution.
This feature is independent of the PDC (Power Domain Controller) settings. If this bit is set and there is SW/JTAG activity during deep sleep, the SYS CPU is stalled after the wake-up.
Note: This bit is retained.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPUWAIT</name>
	<description>1: Stall the processor core out of reset (always after a wake-up). Debugger access continue when the core is stalled. When set to '0' again the core resumes instruction execution.
Note: This bit is retained.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CPU_IS_HALTED</name>
	<description>1: CMAC CPU is halted.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_CPU_IS_HALTED</name>
	<description>1: SYS CPU (ARM CM33) is halted.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HALT_SYS_CPU_EN</name>
	<description>1: Enable halting the SYS CPU (ARM CM33) when the CMAC CPU or SNC CPU is halted.
Note 1: This bit is retained.
Note 2: Set this bit to '0' before going into deep sleep to prevent unpredictable halting behavior after waking up.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HALT_CMAC_CPU_EN</name>
	<description>1: Enable halting the CMAC CPU when the SYS CPU (ARM CM33) or SNC CPU is halted.
Note 1: This bit is retained.
Note 2: Set this bit to '0' before going into deep sleep to prevent unpredictable halting behavior after waking up.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CPU_FREEZE_EN</name>
	<description>1: Enable Freezing on-chip peripherals (see Note 2) by the CMAC CPU.
Note 1: This bit is retained.
Note 2: See [RE]SET_FREEZE_REG for the specific on-chip peripherals.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPU_FREEZE_EN</name>
	<description>1: Enable Freezing on-chip peripherals (see Note 2) by the SYS CPU (ARM CM33).
Default '1', freezing of the on-chip peripherals is enabled when the Cortex-M33 is halted in DEBUG State.
If '0', freezing of the on-chip peripherals is only depending on [RE]SET_FREEZE_REG except the system watchdog timer. The system watchdog timer is always frozen when the Cortex-M33 is halted in DEBUG State.
Note 1: This bit is retained.
Note 2: See [RE]SET_FREEZE_REG for the specific on-chip peripherals.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_STATUS_REG</name>
	<description>General purpose system status register.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CAL_PHASE</name>
	<description>If '1', it designates that the chip is in Calibration Phase i.e. the OTP has been initially programmed but no Calibration has occured. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_FREEZE_REG</name>
	<description>Controls unfreezing of various timers/counters (incl. DMA and USB).</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FRZ_SWTIM6</name>
	<description>If '1', the SW Timer6 continues, '0' is discarded. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM5</name>
	<description>If '1', the SW Timer5 continues, '0' is discarded. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SNC_WDOG</name>
	<description>If '1', the SNC SW Watchdog Timer continues, '0' is discarded. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_CMAC_WDOG</name>
	<description>If '1', the CMAC SW Watchdog Timer continues, '0' is discarded. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM4</name>
	<description>If '1', the SW Timer4 continues, '0' is discarded. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM3</name>
	<description>If '1', the SW Timer3 continues, '0' is discarded. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_PWMLED</name>
	<description>If '1', the PWM LED continues, '0' is discarded. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM2</name>
	<description>If '1', the SW Timer2 continues, '0' is discarded. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA continues, '0' is discarded. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_USB</name>
	<description>If '1', the USB continues, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SYS_WDOG</name>
	<description>If '1', the SYS SW Watchdog Timer continues, '0' is discarded. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_RESERVED</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer continues, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer continues, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_FREEZE_REG</name>
	<description>Controls freezing of various timers/counters (incl. DMA and USB).</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FRZ_SWTIM6</name>
	<description>If '1', the SW Timer6 is frozen, '0' is discarded. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM5</name>
	<description>If '1', the SW Timer5 is frozen, '0' is discarded. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SNC_WDOG</name>
	<description>If '1', the SNC SW Watchdog Timer is frozen, '0' is discarded. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_CMAC_WDOG</name>
	<description>If '1', the CMAC SW Watchdog Timer is frozen, '0' is discarded. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM4</name>
	<description>If '1', the SW Timer4 is frozen, '0' is discarded. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM3</name>
	<description>If '1', the SW Timer3 is frozen, '0' is discarded. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_PWMLED</name>
	<description>If '1', the PWM LED is frozen, '0' is discarded. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM2</name>
	<description>If '1', the SW Timer2 is frozen, '0' is discarded. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA is frozen, '0' is discarded. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_USB</name>
	<description>If '1', the USB is frozen, '0' is discarded. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SYS_WDOG</name>
	<description>If '1', the SYS SW Watchdog Timer is frozen, '0' is discarded. WATCHDOG_CTRL_REG[NMI_RST] must be '0' to allow the freeze function. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_RESERVED</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer is frozen, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer is frozen, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>USBPAD_REG</name>
	<description>USB pads control register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>USBPHY_FORCE_SW2_ON</name>
	<description>0: Pull up resistor SW2 is controlled by the USB controller. It is off when the USB is not enabled.
1: Force the pull up resistor on USBP to be 2.3Kohm</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USBPHY_FORCE_SW1_OFF</name>
	<description>0: Pull up resistor SW1 is controlled by the USB controller. It is off when the USB is not enabled.
1: Force the pull up resistor on USBP to be switched off.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>USBPAD_EN</name>
	<description>0: The power for the USB PHY and USB pads is switched on when the USB is enabled.
1: The power for the USB PHY and USB pads is forced on.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPU_CORE</name>
	<version>1.0</version>
	<description>GPU_CORE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x51001200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>248</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>D2_CACHECTL</name>
	<description>#49: cache control register&#13;

Internal caches can be enabled/disabled and flushed using this register.&#13;
Note that caches will b</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>D2C_CACHECTL_FLUSH_TX</name>
	<description>Flush texture cache</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_CACHECTL_ENABLE_TX</name>
	<description>Texture cache enable</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_CACHECTL_FLUSH_FB</name>
	<description>Flush framebuffer cache</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_CACHECTL_ENABLE_FB</name>
	<description>Framebuffer cache enable</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_COLKEY</name>
	<description>#58: Color key value&#13;

The R, G and B components of the internal color representation of a texel is compared with the color key</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>COLKEY_RGB</name>
	<description>Color Key Value RGB888</description>
	<bitRange>[23:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_COLOR1</name>
	<description>#25: Base color register&#13;

All color registers are *write only*, reading will return undefined results.&#13;
When using textures th</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>COLOR1</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_COLOR2</name>
	<description>#26: Secondary color register&#13;

Secondary color is relevant only when rendering patterns, textures or using&#13;
a D2C_BC2 blendmod</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>COLOR2</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_CONTROL</name>
	<description>#0: geometry control register &#13;

This register controls the pixel enumeration and selection units, deciding &#13;
which pixels are </description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RESERVED</name>
	<description>reserved for SoftDave internal use</description>
	<bitRange>[31:27]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIMITERPRECISION</name>
	<description>increase precision of limiters from 16.16 to 10.22</description>
	<bitRange>[24:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_SPANSTORE</name>
	<description>nextline span start is always equal or left to current-line span start</description>
	<bitRange>[23:23]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_SPANABORT</name>
	<description>shape is horizontally convex. only a single span per scanline</description>
	<bitRange>[22:22]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_UNIONCD</name>
	<description>combine outputs C &amp; D as union (output is final)</description>
	<bitRange>[21:21]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_UNIONAB</name>
	<description>combine outputs A &amp; B as union (output is called C)</description>
	<bitRange>[20:20]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_UNION56</name>
	<description>combine limter 5 &amp; 6 as union (output is called D)</description>
	<bitRange>[19:19]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_UNION34</name>
	<description>combine limter 3 &amp; 4 as union (output is called B)</description>
	<bitRange>[18:18]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_UNION12</name>
	<description>combine limter 1 &amp; 2 as union (output is called A)</description>
	<bitRange>[17:17]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BAND2ENABLE</name>
	<description>enable band postprocess for limiter 2 (see &lt;D2_L2BAND&gt;)</description>
	<bitRange>[16:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BAND1ENABLE</name>
	<description>enable band postprocess for limiter 1 (see &lt;D2_L1BAND&gt;)</description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM6THRESHOLD</name>
	<description>enable limiter 6 threshold mode</description>
	<bitRange>[14:14]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM5THRESHOLD</name>
	<description>enable limiter 5 threshold mode</description>
	<bitRange>[13:13]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM4THRESHOLD</name>
	<description>enable limiter 4 threshold mode</description>
	<bitRange>[12:12]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM3THRESHOLD</name>
	<description>enable limiter 3 threshold mode</description>
	<bitRange>[11:11]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM2THRESHOLD</name>
	<description>enable limiter 2 threshold mode</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM1THRESHOLD</name>
	<description>enable limiter 1 threshold mode</description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_QUAD3ENABLE</name>
	<description>enable quadratic coupling of limiters 5 and 6</description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_QUAD2ENABLE</name>
	<description>enable quadratic coupling of limiters 3 and 4</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_QUAD1ENABLE</name>
	<description>enable quadratic coupling of limiters 1 and 2</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM6ENABLE</name>
	<description>enable limiter 6</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM5ENABLE</name>
	<description>enable limiter 5</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM4ENABLE</name>
	<description>enable limiter 4</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM3ENABLE</name>
	<description>enable limiter 3</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM2ENABLE</name>
	<description>enable limiter 2</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_LIM1ENABLE</name>
	<description>enable limiter 1</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_CONTROL2</name>
	<description>#1: surface control register&#13;

This register controls the colorization, texturing and blending units, deciding &#13;
what color a p</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>D2C_RLEFORMAT2</name>
	<description>bit1 of RLE texel format</description>
	<bitRange>[31:31]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_RLEFORMAT1</name>
	<description>bit0 of RLE texel format</description>
	<bitRange>[30:30]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BDIA</name>
	<description>dst factor for alpha channel will be inverted (meaning 1-a or 1-1 depending on BDFA)</description>
	<bitRange>[29:29]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BSIA</name>
	<description>src factor for alpha channel will be inverted (meaning 1-a or 1-1 depending on BSFA)</description>
	<bitRange>[28:28]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_CLUTFORMAT1</name>
	<description>bit0 of the CLUT entry format</description>
	<bitRange>[27:27]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_COLKEY_ENABLE</name>
	<description>enable color keying (see also &lt;D2_COLKEY&gt; and feature bits of &lt;D2_HWREVISION&gt;)</description>
	<bitRange>[26:26]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_CLUT_ENABLE</name>
	<description>enable the use of the CLUT (see also feature bits of &lt;D2_HWREVISION&gt;); if disabled the texture indices are written to FB</description>
	<bitRange>[25:25]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_RLE_ENABLE</name>
	<description>enable RLE decoder (see also feature bits of &lt;D2_HWREVISION&gt;)</description>
	<bitRange>[24:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_WRITEALPHA2</name>
	<description>bit1 of the 'alpha source' (depends on USE_ACB)</description>
	<bitRange>[23:23]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_WRITEALPHA1</name>
	<description>bit0 of the 'alpha source' (depends on USE_ACB)</description>
	<bitRange>[22:22]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_WRITEFORMAT2</name>
	<description>bit1 of the framebuffer format descriptor</description>
	<bitRange>[21:21]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_WRITEFORMAT1</name>
	<description>bit0 of the framebuffer format descriptor</description>
	<bitRange>[20:20]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_READFORMAT2</name>
	<description>bit1 of the texture format descriptor</description>
	<bitRange>[19:19]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_READFORMAT1</name>
	<description>bit0 of the texture format descriptor</description>
	<bitRange>[18:18]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_TEXTUREFILTERY</name>
	<description>linear filtering on texture v axis</description>
	<bitRange>[17:17]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_TEXTUREFILTERX</name>
	<description>linear filtering on texture u axis</description>
	<bitRange>[16:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_TEXTURECLAMPY</name>
	<description>clamp instead of mask v coordinate</description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_TEXTURECLAMPX</name>
	<description>clamp instead of mask u coordinate</description>
	<bitRange>[14:14]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BC2</name>
	<description>blending for color channels is done with &lt;D2_COLOR2&gt; instead of the real dst value</description>
	<bitRange>[13:13]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BDI</name>
	<description>dst factor for color channels will be inverted (meaning 1-a or 1-1 depending on BDF)</description>
	<bitRange>[12:12]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BSI</name>
	<description>src factor for color channels will be inverted (meaning 1-a or 1-1 depending on BSF)</description>
	<bitRange>[11:11]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BDF</name>
	<description>dst factor for color channels is alpha (factor is 1 per default)</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BSF</name>
	<description>src factor for color channels is alpha (factor is 1 per default)</description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_WRITEFORMAT3</name>
	<description>bit2 of the framebuffer format descriptor</description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BDFA</name>
	<description>dst factor for alpha channel is alpha (factor is 1 per default)</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_BSFA</name>
	<description>src factor for alpha channel is alpha (factor is 1 per default)</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_READFORMAT4</name>
	<description>bit3 of the texture format descriptor</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_READFORMAT3</name>
	<description>bit2 of the texture format descriptor</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>USE_ACB</name>
	<description>use full alpha channel blending, else use write-alpha mode</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_PATTERNSOURCEL5</name>
	<description>Limiter 5 is used as pattern index instead of the default U-Limiter</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_TEXTUREENABLE</name>
	<description>Pixel source is read from texture and used as an alpha to blend between &lt;D2_COLOR1&gt; and &lt;D2_COLOR2&gt;</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2C_PATTERNENABLE</name>
	<description>Pixel source is a pattern color (blend of &lt;D2_COLOR1&gt; and &lt;D2_COLOR2&gt; depending on &lt;D2_PATTERN&gt; and pattern index)</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_CONTROL3</name>
	<description>#2: burst length limit control register&#13;

This register controls the burst length limit for the master bus interfaces&#13;

Log2 of</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x04040404</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>BURSTLENGTH_MDL</name>
	<description>Log2 of the burst length limit for MDL read</description>
	<bitRange>[26:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>BURSTLENGTH_MTX</name>
	<description>Log2 of the burst length limit for MTX read</description>
	<bitRange>[18:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>BURSTLENGTH_MFBW</name>
	<description>Log2 of the burst length limit for MFB write</description>
	<bitRange>[10:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>BURSTLENGTH_MFBR</name>
	<description>Log2 of the burst length limit for MFB read</description>
	<bitRange>[2:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_DLISTSTART</name>
	<description>#50: Displaylist start address&#13;

Setting a new displaylist base address (writing to D2_DLISTSTART) &#13;
*triggers* execution of th</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DLISTSTART</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_HWREVISION</name>
	<description>#1: hardware version and feature set ID&#13;

Read this (constant) register to identify the present hardware revision and&#13;
feature </description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x1fbe000d</resetValue>
	<resetMask>0x1fffffff</resetMask>
	<fields><field>
	<name>FB_BURSTSPLITTING</name>
	<description>bursts can be split with respect to burst length limit</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_ALPHACHANNELBLENDING</name>
	<description>full alpha channel blending available</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_HILIMITERPRECISION</name>
	<description>increasable precision of limiters available</description>
	<bitRange>[26:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_COLORKEY</name>
	<description>color keying available</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_TEXCLUT256</name>
	<description>extend CLUT to 256x32bit ARGB8888</description>
	<bitRange>[24:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_RLEUNIT</name>
	<description>RLE texture decoder available</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_FBPREFETCH</name>
	<description>Framebuffer prefetch available</description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_TEXCLUT</name>
	<description>Color Lookup Table 16x24bit for indexed textureformat available</description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_PERFCOUNT</name>
	<description>Two performance counters available</description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_TXCACHE</name>
	<description>Texture Cache available</description>
	<bitRange>[19:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_FBCACHE</name>
	<description>Framebuffer Cache available</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_DLR</name>
	<description>DisplayListReader available</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FB_SWDAVE</name>
	<description>Software D/AVE</description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HWTYPE</name>
	<description>D/AVE Type</description>
	<bitRange>[15:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HWBRANCH</name>
	<description>Branch number</description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HWREVISION</name>
	<description>Revision number</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>D2_IRQCTL</name>
	<description>#48: interrupt control register&#13;

DAVE2 features three sources for interrupts. They can be enabled and cleared individually.&#13;

</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>D2IRQCTL_CLR_BUS_ERROR</name>
	<description>Clear Interrupt 'Bus error'</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2IRQCTL_ENABLE_BUS_ERROR</name>
	<description>Interruptmask enable 'Bus error'</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2IRQCTL_CLR_FINISH_DLIST</name>
	<description>Clear Interrupt 'Displaylist is finished'. Make sure to clear the IRQ before starting the DLR again! No register writes must be done by the CPU while the DLR is active!</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2IRQCTL_CLR_FINISH_ENUM</name>
	<description>Clear Interrupt 'Enumeration is finished'</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2IRQCTL_ENABLE_FINISH_DLIST</name>
	<description>Interruptmask enable 'Displaylist is finished'</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2IRQCTL_ENABLE_FINISH_ENUM</name>
	<description>Interruptmask enable 'Enumeration is finished'</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L1BAND</name>
	<description>#22: Limiter1 band width parameter&#13;

Postfilter&#13;
First two limiter outputs can be routed through an additional unit before&#13;
cla</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1BAND</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L1START</name>
	<description>#4: Limiter1 start value&#13;

All limiter registers are *write only*, reading will return undefined results.&#13;
Limiters must be ena</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1START</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L1XADD</name>
	<description>#10: Limiter1 X-Axis increment&#13;

The xadd value is the 16:16 fixedpoint difference between two samples with a distance of 1 pix</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1XADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L1YADD</name>
	<description>#16: Limiter1 Y-Axis increment&#13;

The yadd value is the 16:16 fixedpoint difference between two samples with a distance of 1 pix</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1YADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L2BAND</name>
	<description>#23: Limiter2 band width parameter&#13;

see &amp;lt;D2_L1BAND&amp;gt;</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L2BAND</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L2START</name>
	<description>#5: Limiter2 start value&#13;

see &amp;lt;D2_L1START&amp;gt;</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L2START</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L2XADD</name>
	<description>#11: Limiter2 X-Axis increment&#13;

see &amp;lt;D2_L1XADD&amp;gt;</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L2XADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L2YADD</name>
	<description>#17: Limiter2 Y-Axis increment&#13;

see &amp;lt;D2_L1YADD&amp;gt;</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L2YADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L3START</name>
	<description>#6: Limiter3 start value&#13;

see &amp;lt;D2_L1START&amp;gt;</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L3START</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L3XADD</name>
	<description>#12: Limiter3 X-Axis increment</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L3XADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L3YADD</name>
	<description>#18: Limiter3 Y-Axis increment&#13;

see &amp;lt;D2_L1YADD&amp;gt;</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L3YADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L4START</name>
	<description>#7: Limiter4 start value&#13;

see &amp;lt;D2_L1START&amp;gt;</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L4START</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L4XADD</name>
	<description>#13: Limiter4 X-Axis increment&#13;

see &amp;lt;D2_L1XADD&amp;gt;</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L4XADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L4YADD</name>
	<description>#19: Limiter4 Y-Axis increment&#13;

see &amp;lt;D2_L1YADD&amp;gt;</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L4YADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L5START</name>
	<description>#8: Limiter5 start value&#13;

see &amp;lt;D2_L1START&amp;gt;</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L5START</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L5XADD</name>
	<description>#14: Limiter5 X-Axis increment&#13;

see &amp;lt;D2_L1XADD&amp;gt;</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L5XADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L5YADD</name>
	<description>#20: Limiter5 Y-Axis increment&#13;

see &amp;lt;D2_L1YADD&amp;gt;</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L5YADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L6START</name>
	<description>#9: Limiter6 start value&#13;

see &amp;lt;D2_L1START&amp;gt;</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L6START</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L6XADD</name>
	<description>#15: Limiter6 X-Axis increment&#13;

see &amp;lt;D2_L1XADD&amp;gt;</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L6XADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_L6YADD</name>
	<description>#21: Limiter6 Y-Axis increment&#13;

see &amp;lt;D2_L1YADD&amp;gt;</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L6YADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LUSTART</name>
	<description>#36: U Limiter start value&#13;

The start value is a 16:16 fixedpoint number valid at the first pixel of the&#13;
bounding box.</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LUSTART</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LUXADD</name>
	<description>#37: U Limiter X-Axis increment&#13;

The add value for U is the 16:16 fixedpoint difference between two samples with&#13;
a distance o</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LUXADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LUYADD</name>
	<description>#38: U Limiter Y-Axis increment&#13;

The add value for U is the 16:16 fixedpoint difference between two samples with&#13;
a distance o</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LUYADD</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LVSTARTF</name>
	<description>#40: V Limiter start value fractional part&#13;

The start value is a 32:16 fixedpoint number valid at the first pixel of the&#13;
boun</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LVSTARTF</name>
	<description>fractional part.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LVSTARTI</name>
	<description>#39: V Limiter start value integer part</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LVSTARTI</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LVXADDI</name>
	<description>#41: V Limiter X-Axis increment integer part&#13;

The add value for V is the 32:16 fixedpoint difference between two samples with&#13;</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LVXADDI</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LVYADDI</name>
	<description>#42: V Limiter Y-Axis increment integer part&#13;

The add value for V is the 32:16 fixedpoint difference between two samples with&#13;</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LVYADDI</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_LVYXADDF</name>
	<description>#43: V Limiter X and Y increment fractional parts</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>D2_LVYADDI_FRAC</name>
	<description>Y increment fractional part for &lt;D2_LVYADDI&gt;.</description>
	<bitRange>[31:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>D2_LVXADDI_FRAC</name>
	<description>X increment fractional part for &lt;D2_LVXADDI&gt;.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_ORIGIN</name>
	<description>#32: address of the first pixel in framebuffer&#13;

Writing to &amp;lt;D2_ORIGIN&amp;gt; will *trigger* DAVE2 to start rendering.</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ORIGIN</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_PATTERN</name>
	<description>#29: Pattern register&#13;

Each bit in the pattern register is interpreted as a reference to one of the&#13;
two color registers ( 0bi</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PATTERN</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_PERFCOUNT1</name>
	<description>#51: Performance counter&#13;

Writing to the D2_PERFCOUNT1 register resets the first internal performance counter&#13;
to the specifie</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PERFCOUNT1</name>
	
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>D2_PERFCOUNT2</name>
	<description>#52: Performance counter&#13;

Writing to the D2_PERFCOUNT2 register resets the second internal performance counter&#13;
to the specifi</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PERFCOUNT2</name>
	
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>D2_PERFTRIGGER</name>
	<description>#53: Performance counters control register&#13;

Select the internal event that will increment &amp;lt;D2_PERFCOUNT1&amp;gt; respectively &amp;</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PERFTRIGGER2</name>
	<description>Select the internal event that will increment D2_PERFCOUNT2 register.</description>
	<bitRange>[31:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PERFTRIGGER1</name>
	<description>Select the internal event that will increment D2_PERFCOUNT1 register.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_PITCH</name>
	<description>#31: framebuffer pitch and spanstore delay</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SSD</name>
	<description>spanstore delay, the number of scanlines to delay spanstore operations.</description>
	<bitRange>[31:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PITCH</name>
	<description>the width (in pixels) of one framebuffer scanline. A negative width can be used to render bottom-up instead of top-down.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_SIZE</name>
	<description>#30: bounding box dimension</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SIZEY</name>
	<description>the height (in pixels) of the primitives bounding box.</description>
	<bitRange>[31:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SIZEX</name>
	<description>the width (in pixels) of the primitives bounding box.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_STATUS</name>
	<description>#0: status control register&#13;

The current dave status can be polled by reading this register. It contains a &#13;
combination of th</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>D2C_IRQ_BUS_ERROR_SRC</name>
	<description>source interface of bus error</description>
	<bitRange>[10:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>D2C_IRQ_BUS_ERROR</name>
	<description>IRQ on bus error</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>D2C_IRQ_DLIST</name>
	<description>IRQ on display list finish</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>D2C_IRQ_ENUM</name>
	<description>IRQ on enumeration finish</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>D2C_DLISTACTIVE</name>
	<description>display list active, cant direct access hwregs</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>D2C_CACHE_DIRTY</name>
	<description>framebuffer cache dirty, cant flip frame</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>D2C_BUSY_WRITE</name>
	<description>framebuffer writeback busy, cant change framebuffer type</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>D2C_BUSY_ENUM</name>
	<description>enumeration unit busy, cant start new primitive</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>D2_TEXCLUT</name>
	<description>#54: Color Lookup Table for the indexed texture format 16x24bit&#13;

Triggers a write into the CLUT if CLUT size is 16 x 24bit.</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TEXCLUT_INDEX</name>
	<description>Index of the CLUT entry, that shall be written</description>
	<bitRange>[31:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TEXCLUT_RGB</name>
	<description>Color Value RGB888</description>
	<bitRange>[23:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_TEXCLUT_ADDR</name>
	<description>#55: Color Lookup Table write address for the indexed texture format 256x32bit&#13;

Start address for consecutive writes to &amp;lt;D2</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>TEXCLUT_ADDR</name>
	<description>write address</description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_TEXCLUT_DATA</name>
	<description>#56: Color Lookup Table write data for the indexed texture format 256x32bit&#13;

Writes one 32 bit color value into the CLUT if CL</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TEXCLUT_ARGB</name>
	<description>Color value ARGB8888 if CLUTFORMAT = argb8888</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_TEXCLUT_OFFSET</name>
	<description>#57: Offset to the texture index for the indexed texture formats i8, i4, i2 and i1&#13;

The index offset is combined with the text</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>TEXCLUT_OFFSET</name>
	<description>index offset</description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_TEXMASK</name>
	<description>#46: Texture size or texture address mask&#13;

Depending on the clamping mode this register encodes the clamp limit or wrap&#13;
mask.</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TEXVMASK</name>
	<description>V mask.</description>
	<bitRange>[31:11]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TEXUMASK</name>
	<description>U mask.</description>
	<bitRange>[10:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_TEXORIGIN</name>
	<description>#47: Texture base address&#13;

All texture registers are *write only*, reading will return undefined results.&#13;
Patterns and textur</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TEXORIGIN</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>D2_TEXPITCH</name>
	<description>#45: Texels per texture line&#13;

Pitch is equal or bigger than texture width.</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TEXPITCH</name>
	
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPU_REG</name>
	<version>1.0</version>
	<description>GPU_REG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x51001100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GPU_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>PWRS_B</name>
	<description>Power save mode read port memories
0: Disabled
1: Enabled</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPU_RAM_MS</name>
	<description>Margin setting for GPU memories</description>
	<bitRange>[5:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPU_RAM_MSE</name>
	<description>Margin enable for GPU memories</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPU_EN</name>
	<description>GPU enable
0:Enable
1:Disable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C</name>
	<version>1.0</version>
	<description>I2C registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>168</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts.
1 = Generate ACK for a General Call
0 = Generate NACK for General Call </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_STOP_DET_IF_MASTER_ACTIVE</name>
	<description>In Master mode:
1 = issues the STOP_DET interrupt only when master is active.
0 = issues the STOP_DET irrespective of whether master is active or not. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_RX_FIFO_FULL_HLD_CTRL</name>
	<description>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH
1 = Hold bus when RX_FIFO is full
0 = Overflow when RX_FIFO is full</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_TX_EMPTY_CTRL</name>
	<description>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
1 = Controlled generation of TX_EMPTY interrupt
0 = Default behaviour of TX_EMPTY interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP_DET_IFADDRESSED</name>
	<description>1 = slave issues STOP_DET intr only if addressed
0 = slave issues STOP_DET intr always
During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s)
3= high speed mode </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. 
1 = If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.
0 = If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received.
1 = STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.
0 = STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel.
0 = Transmit DMA disabled
1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
0 = Receive DMA disabled
1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_TX_CMD_BLOCK</name>
	<description>In Master mode:
1 = Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.
0.= The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ABORT</name>
	<description>The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_EN</name>
	<description>Controls whether the controller is enabled.
0 = Disables the controller (TX and RX FIFOs are held in an erased state)
1 = Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1. When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 = Slave RX Data is lost
0 = Slave RX Data is not lost </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 =Slave is disabled when it is active
0 =Slave is disabled when it is idle </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
1 = I2C enabled
0 =I2C disabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_MADDR_REG</name>
	<description>I2C High Speed Master Mode Code Address Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>I2C_IC_HS_MAR</name>
	<description>This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code; up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_SCL_HCNT_REG</name>
	<description>High Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed.refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL High time depends on the loading of the bus. For 100pF loading, the SCL High time is 60ns; for 400pF loading, the SCL High time is 120ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_SCL_LCNT_REG</name>
	<description>High Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed. For more information, refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL low time depends on the loading of the bus. For 100pF loading, the SCL low time is 160ns; for 400pF loading, the SCL low time is 320ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_HS_SPKLEN_REG</name>
	<description>I2C HS spike suppression limit Size</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>I2C_HS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>M_SCL_STUCK_AT_LOW</name>
	<description>M_SCL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>M_MASTER_ON_HOLD</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RESTART_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>R_SCL_STUCK_AT_LOW</name>
	<description>1 = R_SCL_STUCK_AT_LOW interrupt is active
0 = R_SCL_STUCK_AT_LOW interrupt is inactive </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_MASTER_ON_HOLD</name>
	<description>Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SCL_STUCK_AT_LOW</name>
	<description>CL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MASTER_ON_HOLD</name>
	<description>ndicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect.
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I2C_SDA_RX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when receiver. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SDA_TX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when transmitter. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000091</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000ab</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LV_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Slave mode due to Rx FIFO is Full and an additional byte has been received
1 = Slave holds the bus due to Rx FIFO is full
0 = Slave is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_HOLD_TX_FIFO_EMPTY</name>
	<description>This bit indicates the BUS Hold in Slave mode for the Read request when the Tx FIFO is empty. The Bus is in hold until the Tx FIFO has data to Transmit for the read request.
1 = Slave holds the bus due to Tx FIFO is empty
0 = Slave is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Master mode due to Rx FIFO is Full and additional byte has been received
1 = Master holds the bus due to Rx FIFO is full
0 = Master is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_TX_FIFO_EMPTY</name>
	<description>the DW_apb_i2c master stalls the write transfer when Tx FIFO is empty, and the the last byte does not have the Stop bit set. This bit indicates the BUS hold when the master holds the bus because of the Tx FIFO being empty, and the the previous transferred command does not have the Stop bit set.
1 =Master holds the bus due to Tx FIFO is empty
0 =Master is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Slave FSM is in IDLE state so the Slave part of the controller is not Active
1 = Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Master FSM is in IDLE state so the Master part of the controller is not Active
1 = Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0 = Receive FIFO is not full
1 = Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>On read
This bit indicates whether software performs a General Call or START BYTE command.
0 = ignore bit 10 GC_OR_START and use IC_TAR normally
1 = perform special I2C command as specified in GC_OR_START
bit
On write
1 = Enables programming of GENERAL_CALL or START_BYTE transmission
0 = Disables programming of GENERAL_CALL or START_BYTE transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>On read
If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0 = General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1 = START BYTE
On write
1 = START byte transmission
0 = GENERAL_CALL byte transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>ABRT_USER_ABRT</name>
	<description>Master-Transmitter : This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>Slave-Transmitter : When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register
1 = Slave trying to transmit to remote master in read mode
0 = Slave trying to transmit to remote master in read mode- scenario not present </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>Slave-Transmitter : Slave lost the bus while transmitting data to a remote master. I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus.
1 = Slave lost arbitration to remote master
0 = Slave lost arbitration to remote master- scenario not present </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>Slave-Transmitter : Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
1 = Slave flushes existing data in TX-FIFO upon getting read command
0 = Slave flushes existing data in TX-FIFO upon getting read command- scenario not present </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>Master-Transmitter or Slave-Transmitter : Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time.
1 = Master or Slave-Transmitter lost arbitration
0 = Master or Slave-Transmitter lost arbitration- scenario not present </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>Master-Transmitter or Master-Receiver : User tries to initiate a Master operation with the Master mode disabled.
1 = User intitating master operation when MASTER disable
0 = User initiating master operation when MASTER disabled- scenario not present </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode.
1 =Master trying to read in 10Bit addressing mode when RESTART disabled
0 =Master not trying to read in 10Bit addressing mode when RESTART disabled </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>Master : To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. 
1 = User trying to send START byte when RESTART disabled
0 = User trying to send START byte when RESTART disabled- scenario not present </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>Master-Transmitter or Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode
1 = User trying to switch Master to HS mode when RESTART disabled
0 = User trying to switch Master to HS mode when RESTART disabled- scenario not present </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>Master : Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). 
1 = ACK detected for START byte
0 = ACK detected for START byte- scenario not present </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>Master : Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
1 = HS Master code ACKed in HS Mode
0 = HS Master code ACKed in HS Mode- scenario not present </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>Master-Transmitter : The controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
1 = GCALL is followed by read from bus
0 = GCALL is followed by read from bus-scenario not present </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>Master-Transmitter : the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call.
1 = GCALL not ACKed by any slave
0 = GCALL not ACKed by any slave-scenario not present </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>Master-Transmitter : This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
1 = Transmitted data not ACKed by addressed slave
0 = Transmitted data non-ACKed by addressed slave-scenario not present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave.
1= Byte 2 of 10Bit Address not ACKed by any slave
0 = This abort is not generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
1 =Byte 1 of 10Bit Address not ACKed by any slave
0 =This abort is not generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
1 =This abort is generated because of NOACK for 7-bit address
0 =This abort is not generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C2</name>
	<version>1.0</version>
	<description>I2C2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020700</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>168</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C2_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts.
1 = Generate ACK for a General Call
0 = Generate NACK for General Call </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_STOP_DET_IF_MASTER_ACTIVE</name>
	<description>In Master mode:
1 = issues the STOP_DET interrupt only when master is active.
0 = issues the STOP_DET irrespective of whether master is active or not. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_RX_FIFO_FULL_HLD_CTRL</name>
	<description>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH
1 = Hold bus when RX_FIFO is full
0 = Overflow when RX_FIFO is full</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_TX_EMPTY_CTRL</name>
	<description>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
1 = Controlled generation of TX_EMPTY interrupt
0 = Default behaviour of TX_EMPTY interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP_DET_IFADDRESSED</name>
	<description>1 = slave issues STOP_DET intr only if addressed
0 = slave issues STOP_DET intr always
During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s)
3= high speed mode </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. 
1 = If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.
0 = If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received.
1 = STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.
0 = STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel.
0 = Transmit DMA disabled
1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
0 = Receive DMA disabled
1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_TX_CMD_BLOCK</name>
	<description>In Master mode:
1 = Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.
0.= The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ABORT</name>
	<description>The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_EN</name>
	<description>Controls whether the controller is enabled.
0 = Disables the controller (TX and RX FIFOs are held in an erased state)
1 = Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1. When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 = Slave RX Data is lost
0 = Slave RX Data is not lost </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 =Slave is disabled when it is active
0 =Slave is disabled when it is idle </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
1 = I2C enabled
0 =I2C disabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_HS_MADDR_REG</name>
	<description>I2C High Speed Master Mode Code Address Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>I2C_IC_HS_MAR</name>
	<description>This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code; up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_HS_SCL_HCNT_REG</name>
	<description>High Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed.refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL High time depends on the loading of the bus. For 100pF loading, the SCL High time is 60ns; for 400pF loading, the SCL High time is 120ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_HS_SCL_LCNT_REG</name>
	<description>High Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed. For more information, refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL low time depends on the loading of the bus. For 100pF loading, the SCL low time is 160ns; for 400pF loading, the SCL low time is 320ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_IC_HS_SPKLEN_REG</name>
	<description>I2C HS spike suppression limit Size</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>I2C_HS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>M_SCL_STUCK_AT_LOW</name>
	<description>M_SCL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>M_MASTER_ON_HOLD</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RESTART_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>R_SCL_STUCK_AT_LOW</name>
	<description>1 = R_SCL_STUCK_AT_LOW interrupt is active
0 = R_SCL_STUCK_AT_LOW interrupt is inactive </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_MASTER_ON_HOLD</name>
	<description>Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SCL_STUCK_AT_LOW</name>
	<description>CL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MASTER_ON_HOLD</name>
	<description>ndicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect.
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I2C_SDA_RX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when receiver. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SDA_TX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when transmitter. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000091</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000ab</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LV_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Slave mode due to Rx FIFO is Full and an additional byte has been received
1 = Slave holds the bus due to Rx FIFO is full
0 = Slave is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_HOLD_TX_FIFO_EMPTY</name>
	<description>This bit indicates the BUS Hold in Slave mode for the Read request when the Tx FIFO is empty. The Bus is in hold until the Tx FIFO has data to Transmit for the read request.
1 = Slave holds the bus due to Tx FIFO is empty
0 = Slave is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Master mode due to Rx FIFO is Full and additional byte has been received
1 = Master holds the bus due to Rx FIFO is full
0 = Master is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_TX_FIFO_EMPTY</name>
	<description>the DW_apb_i2c master stalls the write transfer when Tx FIFO is empty, and the the last byte does not have the Stop bit set. This bit indicates the BUS hold when the master holds the bus because of the Tx FIFO being empty, and the the previous transferred command does not have the Stop bit set.
1 =Master holds the bus due to Tx FIFO is empty
0 =Master is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Slave FSM is in IDLE state so the Slave part of the controller is not Active
1 = Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Master FSM is in IDLE state so the Master part of the controller is not Active
1 = Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0 = Receive FIFO is not full
1 = Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>On read
This bit indicates whether software performs a General Call or START BYTE command.
0 = ignore bit 10 GC_OR_START and use IC_TAR normally
1 = perform special I2C command as specified in GC_OR_START
bit
On write
1 = Enables programming of GENERAL_CALL or START_BYTE transmission
0 = Disables programming of GENERAL_CALL or START_BYTE transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>On read
If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0 = General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1 = START BYTE
On write
1 = START byte transmission
0 = GENERAL_CALL byte transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C2_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>ABRT_USER_ABRT</name>
	<description>Master-Transmitter : This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>Slave-Transmitter : When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register
1 = Slave trying to transmit to remote master in read mode
0 = Slave trying to transmit to remote master in read mode- scenario not present </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>Slave-Transmitter : Slave lost the bus while transmitting data to a remote master. I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus.
1 = Slave lost arbitration to remote master
0 = Slave lost arbitration to remote master- scenario not present </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>Slave-Transmitter : Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
1 = Slave flushes existing data in TX-FIFO upon getting read command
0 = Slave flushes existing data in TX-FIFO upon getting read command- scenario not present </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>Master-Transmitter or Slave-Transmitter : Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time.
1 = Master or Slave-Transmitter lost arbitration
0 = Master or Slave-Transmitter lost arbitration- scenario not present </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>Master-Transmitter or Master-Receiver : User tries to initiate a Master operation with the Master mode disabled.
1 = User intitating master operation when MASTER disable
0 = User initiating master operation when MASTER disabled- scenario not present </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode.
1 =Master trying to read in 10Bit addressing mode when RESTART disabled
0 =Master not trying to read in 10Bit addressing mode when RESTART disabled </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>Master : To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. 
1 = User trying to send START byte when RESTART disabled
0 = User trying to send START byte when RESTART disabled- scenario not present </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>Master-Transmitter or Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode
1 = User trying to switch Master to HS mode when RESTART disabled
0 = User trying to switch Master to HS mode when RESTART disabled- scenario not present </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>Master : Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). 
1 = ACK detected for START byte
0 = ACK detected for START byte- scenario not present </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>Master : Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
1 = HS Master code ACKed in HS Mode
0 = HS Master code ACKed in HS Mode- scenario not present </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>Master-Transmitter : The controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
1 = GCALL is followed by read from bus
0 = GCALL is followed by read from bus-scenario not present </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>Master-Transmitter : the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call.
1 = GCALL not ACKed by any slave
0 = GCALL not ACKed by any slave-scenario not present </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>Master-Transmitter : This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
1 = Transmitted data not ACKed by addressed slave
0 = Transmitted data non-ACKed by addressed slave-scenario not present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave.
1= Byte 2 of 10Bit Address not ACKed by any slave
0 = This abort is not generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
1 =Byte 1 of 10Bit Address not ACKed by any slave
0 =This abort is not generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
1 =This abort is generated because of NOACK for 7-bit address
0 =This abort is not generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C2_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C3</name>
	<version>1.0</version>
	<description>I2C3 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>168</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C3_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts.
1 = Generate ACK for a General Call
0 = Generate NACK for General Call </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_STOP_DET_IF_MASTER_ACTIVE</name>
	<description>In Master mode:
1 = issues the STOP_DET interrupt only when master is active.
0 = issues the STOP_DET irrespective of whether master is active or not. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_RX_FIFO_FULL_HLD_CTRL</name>
	<description>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH
1 = Hold bus when RX_FIFO is full
0 = Overflow when RX_FIFO is full</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_TX_EMPTY_CTRL</name>
	<description>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
1 = Controlled generation of TX_EMPTY interrupt
0 = Default behaviour of TX_EMPTY interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP_DET_IFADDRESSED</name>
	<description>1 = slave issues STOP_DET intr only if addressed
0 = slave issues STOP_DET intr always
During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s)
3= high speed mode </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. 
1 = If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.
0 = If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received.
1 = STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.
0 = STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel.
0 = Transmit DMA disabled
1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
0 = Receive DMA disabled
1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_TX_CMD_BLOCK</name>
	<description>In Master mode:
1 = Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.
0.= The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ABORT</name>
	<description>The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_EN</name>
	<description>Controls whether the controller is enabled.
0 = Disables the controller (TX and RX FIFOs are held in an erased state)
1 = Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1. When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 = Slave RX Data is lost
0 = Slave RX Data is not lost </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 =Slave is disabled when it is active
0 =Slave is disabled when it is idle </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
1 = I2C enabled
0 =I2C disabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_HS_MADDR_REG</name>
	<description>I2C High Speed Master Mode Code Address Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>I2C_IC_HS_MAR</name>
	<description>This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code; up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_HS_SCL_HCNT_REG</name>
	<description>High Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed.refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL High time depends on the loading of the bus. For 100pF loading, the SCL High time is 60ns; for 400pF loading, the SCL High time is 120ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_HS_SCL_LCNT_REG</name>
	<description>High Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed. For more information, refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL low time depends on the loading of the bus. For 100pF loading, the SCL low time is 160ns; for 400pF loading, the SCL low time is 320ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_IC_HS_SPKLEN_REG</name>
	<description>I2C HS spike suppression limit Size</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>I2C_HS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>M_SCL_STUCK_AT_LOW</name>
	<description>M_SCL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>M_MASTER_ON_HOLD</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RESTART_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>R_SCL_STUCK_AT_LOW</name>
	<description>1 = R_SCL_STUCK_AT_LOW interrupt is active
0 = R_SCL_STUCK_AT_LOW interrupt is inactive </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_MASTER_ON_HOLD</name>
	<description>Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SCL_STUCK_AT_LOW</name>
	<description>CL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MASTER_ON_HOLD</name>
	<description>ndicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN=1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect.
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I2C_SDA_RX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when receiver. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SDA_TX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when transmitter. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000091</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000ab</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LV_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Slave mode due to Rx FIFO is Full and an additional byte has been received
1 = Slave holds the bus due to Rx FIFO is full
0 = Slave is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_HOLD_TX_FIFO_EMPTY</name>
	<description>This bit indicates the BUS Hold in Slave mode for the Read request when the Tx FIFO is empty. The Bus is in hold until the Tx FIFO has data to Transmit for the read request.
1 = Slave holds the bus due to Tx FIFO is empty
0 = Slave is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Master mode due to Rx FIFO is Full and additional byte has been received
1 = Master holds the bus due to Rx FIFO is full
0 = Master is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_TX_FIFO_EMPTY</name>
	<description>the DW_apb_i2c master stalls the write transfer when Tx FIFO is empty, and the the last byte does not have the Stop bit set. This bit indicates the BUS hold when the master holds the bus because of the Tx FIFO being empty, and the the previous transferred command does not have the Stop bit set.
1 =Master holds the bus due to Tx FIFO is empty
0 =Master is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Slave FSM is in IDLE state so the Slave part of the controller is not Active
1 = Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Master FSM is in IDLE state so the Master part of the controller is not Active
1 = Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0 = Receive FIFO is not full
1 = Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>On read
This bit indicates whether software performs a General Call or START BYTE command.
0 = ignore bit 10 GC_OR_START and use IC_TAR normally
1 = perform special I2C command as specified in GC_OR_START
bit
On write
1 = Enables programming of GENERAL_CALL or START_BYTE transmission
0 = Disables programming of GENERAL_CALL or START_BYTE transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>On read
If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0 = General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1 = START BYTE
On write
1 = START byte transmission
0 = GENERAL_CALL byte transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C3_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>ABRT_USER_ABRT</name>
	<description>Master-Transmitter : This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>Slave-Transmitter : When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register
1 = Slave trying to transmit to remote master in read mode
0 = Slave trying to transmit to remote master in read mode- scenario not present </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>Slave-Transmitter : Slave lost the bus while transmitting data to a remote master. I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus.
1 = Slave lost arbitration to remote master
0 = Slave lost arbitration to remote master- scenario not present </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>Slave-Transmitter : Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
1 = Slave flushes existing data in TX-FIFO upon getting read command
0 = Slave flushes existing data in TX-FIFO upon getting read command- scenario not present </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>Master-Transmitter or Slave-Transmitter : Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time.
1 = Master or Slave-Transmitter lost arbitration
0 = Master or Slave-Transmitter lost arbitration- scenario not present </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>Master-Transmitter or Master-Receiver : User tries to initiate a Master operation with the Master mode disabled.
1 = User intitating master operation when MASTER disable
0 = User initiating master operation when MASTER disabled- scenario not present </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode.
1 =Master trying to read in 10Bit addressing mode when RESTART disabled
0 =Master not trying to read in 10Bit addressing mode when RESTART disabled </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>Master : To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. 
1 = User trying to send START byte when RESTART disabled
0 = User trying to send START byte when RESTART disabled- scenario not present </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>Master-Transmitter or Master-Receiver : The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode
1 = User trying to switch Master to HS mode when RESTART disabled
0 = User trying to switch Master to HS mode when RESTART disabled- scenario not present </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>Master : Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). 
1 = ACK detected for START byte
0 = ACK detected for START byte- scenario not present </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>Master : Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
1 = HS Master code ACKed in HS Mode
0 = HS Master code ACKed in HS Mode- scenario not present </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>Master-Transmitter : The controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
1 = GCALL is followed by read from bus
0 = GCALL is followed by read from bus-scenario not present </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>Master-Transmitter : the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call.
1 = GCALL not ACKed by any slave
0 = GCALL not ACKed by any slave-scenario not present </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>Master-Transmitter : This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
1 = Transmitted data not ACKed by addressed slave
0 = Transmitted data non-ACKed by addressed slave-scenario not present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave.
1= Byte 2 of 10Bit Address not ACKed by any slave
0 = This abort is not generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
1 =Byte 1 of 10Bit Address not ACKed by any slave
0 =This abort is not generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>Master-Transmitter or Master-Receiver : Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
1 =This abort is generated because of NOACK for 7-bit address
0 =This abort is not generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C3_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I3C</name>
	<version>1.0</version>
	<description>I3C registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020c00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>672</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I3C_BUS_FREE_AVAIL_TIMING_REG</name>
	<description>Bus Free Timing Register</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUS_FREE_TIME</name>
	<description>This register field is used only in Master mode of operation

I3C Bus Free Count Value.

In Pure Bus System, this field represents tCAS parameter. In Mixed Bus system, this field is expected to be programmed to tLOW of I2C Timing.
</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_COMMAND_QUEUE_PORT_REG</name>
	<description>COMMAND_QUEUE_PORT</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>COMMAND</name>
	<description>32 bit command</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>I3C_DATA_BUFFER_STAT_LEVEL_REG</name>
	<description>Data Buffer Status Level Register </description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_BUF_BLR</name>
	<description>Receive Buffer Level Value.

Contains the number of valid data entries in the receive Buffer.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_BUF_EMPTY_LOC</name>
	<description>Transmit Buffer Empty Level Value.

Contains the number of empty locations in the transmit Buffer.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DATA_BUFFER_THLD_CTRL_REG</name>
	<description>Data Buffer Threshold Control Register </description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x03030303</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_START_THLD</name>
	<description>Receive Start Threshold Value.

In master mode of operation when the controller is set up to initiate a read transfer, it waits until either one of the conditions are met before it initiates the read transfer on the I3C Interface.

Data length (as specified in the command) number of locations are empty in the Receive FIFO.

Threshold number of locations (or more) are empty in the Receive FIFO.

The supported values for RX_START_THLD are:

000 - 1
001 - 4
010 - 8
011 - 16
100 - 32
101 - 64</description>
	<bitRange>[26:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_START_THLD</name>
	<description>Transfer Start Threshold Value.

In master mode of operation when the controller is set up to initiate a write transfer, it waits until either one of the following conditions are met before it initiates the write transfer on the I3C Interface.

Data length (as specified in the command) number of locations are filled in the Transmit FIFO

Threshold number of entries (or more) are available in the Transmit FIFO

The supported values for TX_START_THLD are:

000: 1
001: 4
010: 8
011: 16
100: 32
101: 64
</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RX_BUF_THLD</name>
	<description>Receive Buffer Threshold Value.

This field controls the number of entries (or above) in the Receive FIFO that trigger the RX_THLD_STAT interrupt.

If the programmed value is greater than the buffer depth, then threshold will be set to 32. The supported values for RX_BUF_THLD are

000: 1
001: 4
010: 8
011: 16
100: 32
101: 64
</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_EMPTY_BUF_THLD</name>
	<description>Transmit Buffer Threshold Value.

This field controls the number of empty locations (or above) in the Transmit FIFO that trigger the TX_THLD_STAT interrupt.

If the programmed value is greater than the buffer depth, then threshold will be set to 32. The supported values for TX_BUF_THLD are

000: 1
001: 4
010: 8
011: 16
100: 32
101: 64</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEVICE_ADDR_REG</name>
	<description>Device Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DYNAMIC_ADDR_VALID</name>
	<description>Dynamic Address Valid

This bit is used to control whether the DYNAMIC_ADDR is valid or not.

In I3C Main Master mode, the user sets this bit to 1 as it self-assigns its dynamic address.
In all other operation modes, the Controller sets this bit to 1 when Main Master assigns the Dynamic address during ENTDAA or SETDASA mechanism.

Values:

0x0 (INVALID): Dynamic Address is invalid
0x1 (VALID): Dynamic Address is valid
</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DYNAMIC_ADDR</name>
	<description>Device Dynamic Address.

This field is used to program the Device Dynamic Address. The Controller uses this address for I3C transfers.

In Main Master mode, the user/application has to program the Dynamic Address through the Slave interface as it self-assigns its Dynamic Address.
In all other modes, the Main Master assigns this address during ENTDAA or SETDASA mechanism.
</description>
	<bitRange>[22:16]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEVICE_ADDR_TABLE_PTR_REG</name>
	<description>Pointer for Device Address Table Registers </description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00080280</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_ADDR_TABLE_DEPTH</name>
	<description>Depth of Device Address Table</description>
	<bitRange>[31:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>P_DEV_ADDR_TABLE_START_ADDR</name>
	<description>Start Address of Device Address Table.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEVICE_CTRL_EXTENDED_REG</name>
	<description>Device Control Extended Register </description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_OPERATION_MODE</name>
	<description>This bit is used to select the Device Operation Mode before the controller is enabled.

This field shall be written only when the DWC_mipi_i3c is disabled.

0: Master
1: Slave
2: Reserved
3: Reserved

This field will be automatically updated by the controller once the role change happens in secondary master mode..</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEVICE_CTRL_REG</name>
	<description>Device Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000181</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ENABLE</name>
	<description>Controls whether or not DWC_mipi_i3c is enabled.

1: Enables the DWC_mipi_i3c controller.
0: Disables the DWC_mipi_i3c controller.

In Master mode of operation, software can Disable DWC_mipi_i3c while it is active. However, the controller may not get Disabled immediately and will be 'Disabled' after commands in the Command queue (if any) are executed leading to a STOP condition on the bus and Master FSM is in IDLE state (as indicated by PRESENT_STATE Register).
</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESUME</name>
	<description>DWC_mipi_i3c Resume.

This bit is used to resume the Controller after it goes to Halt state.

In the master mode of operation the controller goes to the halt state (as indicated in PRESENT_STATE Register) due to any type of error in the transfer (the type of error is indicated by ERR_STATUS field in the RESPONSE_QUEUE_PORT register).

After the controller has gone to halt state, the application has to write 1'b1 to this bit to resume the controller. This bit is auto-cleared once the controller resumes the transfers by initiating the next command.
</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ABORT</name>
	<description>DWC_mipi_i3c Abort.

This bit is used in master mode of operation.

This bit allows the controller to relinquish the I3C Bus before completing the issued transfer.

In response to an ABORT request, the controller issues the STOP condition after the complete data byte is transferred or received.

This bit is auto-cleared once the transfer is aborted and controller issues a 'Transfer Abort' interrupt.
</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ENABLE_I3C</name>
	<description>DMA Handshake Interface Enable.

This bit is used to enable or disable the DMA Handshaking interface and is applicable to both Master and Slave mode of operation.

1: Enables the DMA handshake control to interact with external DMA.

0: The DMA handshake control has no significance.
</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOT_JOIN_CTRL</name>
	<description>Hot-Join Ack/Nack Control

This bit is used in master mode of operation.

This bit acts as global control to ACK/NACK the Hot-Join Request from the devices. The DWC_mipi_i3c Master will ACK/NACK the Hot-Join request from other devices connected on the I3C Bus, based on programming of this bit.

0: ACK the Hot-join request.
1: NACK and send broadcast CCC to disable Hot-join.

Values:

0x0 (DISABLED): Ack Hot-Join requests
0x1 (ENABLED): Nack and auto-disable Hot-Join request
</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SLAVE_PRESENT</name>
	<description>I2C Slave Present

This bit is used in master mode of operation.

This Bit indicates whether any Legacy I2C Devices are present in the system.

In HDR mode, this field is used to select TSL over TSP in mixed bus configuration.

Values:

0x0 (DISABLED): I2C Slave not present
0x1 (ENABLED): I2C Slave present</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IBA_INCLUDE</name>
	<description>I3C Broadcast Address include.

This bit is used in master mode of operation.

This bit is used to include I3C broadcast address (0x7E) for private transfer.

Note: If I3C broadcast address is not included for the private transfers, In-band Interrupts (IBI) driven from Slaves may not win address arbitration. Hence, the IBIs will get delayed.

Values:

0x0 (NOT_INCLUDED): I3C Broadcast Address is not included for Private Transfers
0x1 (INCLUDED): I3C Broadcast Address is included for Private Transfers
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC1_REG</name>
	<description>Device Address Table of Device1 </description>
	<addressOffset>0x00000280</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC2_REG</name>
	<description>Device Address Table of Device2</description>
	<addressOffset>0x00000284</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC3_REG</name>
	<description>Device Address Table of Device3</description>
	<addressOffset>0x00000288</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC4_REG</name>
	<description>Device Address Table of Device4</description>
	<addressOffset>0x0000028c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC5_REG</name>
	<description>Device Address Table of Device5</description>
	<addressOffset>0x00000290</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC6_REG</name>
	<description>Device Address Table of Device6</description>
	<addressOffset>0x00000294</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC7_REG</name>
	<description>Device Address Table of Device7</description>
	<addressOffset>0x00000298</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_ADDR_TABLE_LOC8_REG</name>
	<description>Device Address Table of Device8</description>
	<addressOffset>0x0000029c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LEGACY_I2C_DEVICE</name>
	<description>Legacy I2C device or not.

This bit should be set to 1 if the device is a legacy I2C device.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_NACK_RETRY_CNT</name>
	<description>This field is used to set the Device NACK Retry count for the particular device.

If the Device NACK's for the device address, the controller automatically retries the same device until this count expires. If the Slave does not ACK for the mentioned number of retries, then Controller generates an error response and move to the Halt state.

This feature is used for Retry Model for the following features mentioned in the I3C Specification:

Retry Model for Direct GET CCC Commands.
The incoming SIR-IBI matches with the slave address initated by the Master.
</description>
	<bitRange>[30:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_DYNAMIC_ADDR</name>
	<description>Device Dynamic Address with parity. The MSB, bit[23], should be programmed with parity of dynamic address.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_STATIC_ADDR</name>
	<description>Device Static Address.</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE1_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device1</description>
	<addressOffset>0x00000200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE1_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device1</description>
	<addressOffset>0x00000204</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE1_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device1</description>
	<addressOffset>0x00000208</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE1_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device1</description>
	<addressOffset>0x0000020c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE2_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device2</description>
	<addressOffset>0x00000210</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE2_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device2</description>
	<addressOffset>0x00000214</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE2_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device2</description>
	<addressOffset>0x00000218</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE2_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device2</description>
	<addressOffset>0x0000021c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE3_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device3</description>
	<addressOffset>0x00000220</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE3_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device3</description>
	<addressOffset>0x00000224</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE3_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device3</description>
	<addressOffset>0x00000228</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE3_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device3</description>
	<addressOffset>0x0000022c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE4_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device4</description>
	<addressOffset>0x00000230</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE4_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device4</description>
	<addressOffset>0x00000234</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE4_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device4</description>
	<addressOffset>0x00000238</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE4_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device4</description>
	<addressOffset>0x0000023c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE5_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device5</description>
	<addressOffset>0x00000240</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE5_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device5</description>
	<addressOffset>0x00000244</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE5_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device5</description>
	<addressOffset>0x00000248</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE5_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device5</description>
	<addressOffset>0x0000024c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE6_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device6</description>
	<addressOffset>0x00000250</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE6_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device6</description>
	<addressOffset>0x00000254</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE6_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device6</description>
	<addressOffset>0x00000258</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE6_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device6</description>
	<addressOffset>0x0000025c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE7_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device7</description>
	<addressOffset>0x00000260</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE7_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device7</description>
	<addressOffset>0x00000264</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE7_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device7</description>
	<addressOffset>0x00000268</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE7_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device7</description>
	<addressOffset>0x0000026c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE8_LOC1_REG</name>
	<description> Device Characteristic Table Location-1 of Device8</description>
	<addressOffset>0x00000270</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LSB_PROVISIONAL_ID</name>
	<description>The LSB 32-bit value of Provisional-ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE8_LOC2_REG</name>
	<description>Device Characteristic Table Location-2 of Device8</description>
	<addressOffset>0x00000274</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MSB_PROVISIONAL_ID</name>
	<description>The MSB 16-bit value of Provisional-ID</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE8_LOC3_REG</name>
	<description>Device Characteristic Table Location-3 of Device8</description>
	<addressOffset>0x00000278</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BCR</name>
	<description>Bus Characteristic Value</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DCR</name>
	<description>Device Characteristic Value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE8_LOC4_REG</name>
	<description>Device Characteristic Table Location-4 of Device8</description>
	<addressOffset>0x0000027c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEV_DYNAMIC_ADDR_LOC4</name>
	<description>Device Dynamic Address assigned.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_DEV_CHAR_TABLE_POINTER_REG</name>
	<description>Pointer for Device Characteristics Table </description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00020200</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PRESENT_DEV_CHAR_TABLE_INDX</name>
	<description>Current index of Device Characteristics Table.

This field returns the current location of Device Characteristics Table index. Initially, this index points to 0.

Once the complete characteristics information of a Slave device is written into Device Characteristics Table during ENTDAA, this index increments by 1. The first winning device information is stored in Device Characteristics Table index 0, the second winning device information in index 1, and so on.

If required, this index can be used to override the location, where characteristic information of Slave devices on the I3C bus are written during ENTDAA. Hence, this field is useful only if the device is Current Master. During DEFSLV CCC, the index always starts from 0.

In Non-current Master, this field is always read-only.</description>
	<bitRange>[21:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEV_CHAR_TABLE_DEPTH</name>
	<description>Depth of Device Characteristics Table</description>
	<bitRange>[18:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>P_DEV_CHAR_TABLE_START_ADDR</name>
	<description>Start Address of Device Characteristics Table.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_HW_CAPABILITY_REG</name>
	<description>Hardware Capability register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00034101</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SLV_IBI_CAP</name>
	<description>Reflects the IC_SLV_IBI Configurable Parameter.

Specifies slave's capability to initiate slave interrupt requests.
</description>
	<bitRange>[19:19]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_HJ_CAP</name>
	<description>Reflects the IC_SLV_HJ Configurable Parameter.

Specifies slave's capability to initiate Hot-join request.
</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_EN</name>
	<description>Reflects the IC_HAS_DMA Configurable Parameter.

Specifies whether controller is configured to have DMA handshaking interface.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HDR_TX_CLOCK_PERIOD</name>
	<description>Reflects the IC_HDR_TX_CLK_PERIOD Configurable Parameter.</description>
	<bitRange>[16:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLOCK_PERIOD</name>
	<description>Reflects the IC_CLK_PERIOD Configurable Parameter</description>
	<bitRange>[10:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HDR_TS_EN</name>
	<description>Reflects the IC_SPEED_HDR_TS Configurable Parameter.

Specifies the Controllers capability to perform HDR-TS transfers.

0 : HDR-TS not supported
1 : HDR-TS supported</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HDR_DDR_EN</name>
	<description>Reflects the IC_SPEED_HDR_DDR Configurable Parameter.

Specifies the Controllers capability to perform HDR-DDR transfers.

0 : HDR-DDR not supported
1 : HDR-DDR supported</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DEVICE_ROLE_CONFIG</name>
	<description>Reflects the IC_DEVICE_ROLE Configurable Parameter.

Specifies the configured role of DWC_mipi_i3c controller

1 : Master Only
2 : Programmable Master-Slave
3 : Secondary Master
4 : Slave Only</description>
	<bitRange>[2:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_IBI_QUEUE_CTRL_REG</name>
	<description>IBI Queue Control Register </description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>NOTIFY_SIR_REJECTED</name>
	<description>Notify Rejected Slave Interrupt Request Control.

This bit is used to suppress reporting to the application about SIR request rejected.

0: Suppress passing the IBI Status to the IBI FIFO (hence not notifying the application) when a Slave Interrupt Request is NACKed and auto-disabled based on the IBI_SIR_REQ_REJECT Register.
1: Writes IBI Status to the IBI FIFO (hence notifying the application) when a Slave Interrupt Request is NACKed and auto-disabled based on the IBI_SIR_REQ_REJECT Register.

Values:

0x0 (DISABLED): Notify SIR Rejected Disable
0x1 (ENABLED): Notify SIR Rejected Enable</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NOTIFY_HJ_REJECTED</name>
	<description>Notify Rejected Hot-Join Control.

This bit is used to suppress reporting to the application about Hot-Join request rejected (NACK and Auto Disable).

0: Suppress passing the IBI Status to the IBI FIFO (hence not notifying the application) when a HJ Request is NACKed and auto-disabled based on the DEVICE_CTRL.HOT_JOIN_CTRL.
1: Writes IBI Status to the IBI FIFO (hence notifying the application) when a HJ Request is NACKed and auto-disabled based on the DEVICE_CTRL.HOT_JOIN_CTRL.

Values:

0x0 (DISABLED): Notify Hot-Join Rejected Disable
0x1 (ENABLED): Notify Hot-Join Rejected Enable
</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_IBI_QUEUE_STATUS_DATA_REG</name>
	<description>In-Band Interrupt Queue Status and Data Register </description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IBI_STS</name>
	<description>IBI Received Status.

Defines the master response for IBI received.

4'b0xxx: Responded with ACK
4'b1xxx: Responded with NACK
Others : RESERVED</description>
	<bitRange>[31:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IBI_ID</name>
	<description>IBI Identifier.

The byte received after START which includes the address and the R/W bit.

Device address and R/W bit in case of Slave Interrupt or Master Request.
Hot-Join ID and R/W bit in case of Hot-Join IBI.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DATA_LENGTH</name>
	<description>In-Band Interrupt data length.

This field represents the length of data received along with the IBI, in bytes.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_IBI_SIR_REQ_REJECT_REG</name>
	<description> IBI SIR Request Rejection Control Register </description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SIR_REQ_REJECT</name>
	<description>In-band Slave Interrupt Request Reject.

The application of the DWC_mipi_i3c can decide whether to send ACK or NACK for a Slave request received from any I3C device.

A device specific response control bit is provided to select the response option. Master will ACK/NACK the Master Request based on programming of control bit, corresponding to the interrupting device.

0 - ACK the SIR Request
1 - NACK and send directed auto disable CCC
</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_INTR_FORCE_REG</name>
	<description>Interrupt Force Enable Register </description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRANSFER_ERR_FORCE_EN</name>
	<description>Transfer Error Force Enable</description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TRANSFER_ABORT_FORCE_EN</name>
	<description>Transfer Abort Force Enable.

This field is used only in master mode of operation.
</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESP_READY_FORCE_EN</name>
	<description>Response Queue Ready Force Enable</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CMD_QUEUE_READY_FORCE_EN</name>
	<description>Command Queue Ready Force Enable</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>IBI_THLD_FORCE_EN</name>
	<description>IBI Buffer Threshold Force Enable.

This field is used only in master mode of operation.
</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RX_THLD_FORCE_EN</name>
	<description>Receive Buffer Threshold Force Enable
</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TX_THLD_FORCE_EN</name>
	<description>Transmit Buffer Threshold Force Enable.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>I3C_INTR_SIGNAL_EN_REG</name>
	<description>Interrupt Signal Enable Register </description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRANSFER_ERR_SIGNAL_EN</name>
	<description>Transfer Error Signal Enable</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRANSFER_ABORT_SIGNAL_EN</name>
	<description>Transfer Abort Signal Enable.

This field is used only in master mode of operation.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_READY_SIGNAL_EN</name>
	<description>Response Queue Ready Signal Enable</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_QUEUE_READY_SIGNAL_EN</name>
	<description>Command Queue Ready Signal Enable</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IBI_THLD_SIGNAL_EN</name>
	<description>IBI Buffer Threshold Signal Enable.

This field is used only in master mode of operation.
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RX_THLD_SIGNAL_EN</name>
	<description>Receive Buffer Threshold Signal Enable
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_THLD_SIGNAL_EN</name>
	<description>Transmit Buffer Threshold Signal Enable.

*Note: For the deassertion of the interrupt, first the *SIGNAL_EN bitfield should be cleared and then the *STATUS_EN one, otherwise is not working. This comment applies for the rest bitfields of this register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_INTR_STATUS_EN_REG</name>
	<description>Interrupt Status Enable Register </description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRANSFER_ERR_STS_EN</name>
	<description>Transfer Error Status Enable</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRANSFER_ABORT_STS_EN</name>
	<description>Transfer Abort Status Enable.

This field is used only in master mode of operation.
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_READY_STS_EN</name>
	<description>Response Queue Ready Status Enable
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_QUEUE_READY_STS_EN</name>
	<description>Command Queue Ready Status Enable
</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IBI_THLD_STS_EN</name>
	<description>IBI Buffer Threshold Status Enable.

This field is used only in master mode of operation.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RX_THLD_STS_EN</name>
	<description>Receive Buffer Threshold Status Enable</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_THLD_STS_EN</name>
	<description>Transmit Buffer Threshold Status Enable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_INTR_STATUS_REG</name>
	<description>Interrupt Status Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TRANSFER_ERR_STS</name>
	<description>Transfer Error Status.

This interrupt is generated if any error occurs during transfer. The error type will be specified in the response packet associated with the command (in ERR_STATUS field of RESPONSE_QUEUE_PORT register). This bit can be cleared by writing 1'b1.
</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRANSFER_ABORT_STS</name>
	<description>Transfer Abort Status.

This field is used only in master mode of operation.

This interrupt is generated if transfer is aborted. This interrupt can be cleared by writing 1'b1.
</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_READY_STS</name>
	<description>Response Queue Ready Status.

This interrupt is generated when number of entries in response queue is greater than or equal to threshold value specified by RESP_BUF_THLD field in QUEUE_THLD_CTRL register. This interrupt will be cleared automatically when number of entries in response buffer is less than threshold value specified.
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_QUEUE_READY_STS</name>
	<description>Command Queue Ready.

This interrupt is generated when number of empty locations in command queue is greater than or equal to threshold value specified by CMD_EMPTY_BUF_THLD field in QUEUE_THLD_CTRL register. This interrupt will be cleared automatically when number of empty locations in command buffer is less than threshold value specified.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IBI_THLD_STS</name>
	<description>IBI Buffer Threshold Status.

This field is only used in master mode of operation This interrupt is generated when number of entries in IBI buffer is greater than or equal to threshold value specified by IBI_BUF_THLD field in QUEUE_THLD_CTRL register. This interrupt will be cleared automatically when number of entries in IBI buffer is less than threshold value specified.
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_THLD_STS</name>
	<description>Receive Buffer Threshold Status.

This interrupt is generated when number of entries in receive buffer is greater than or equal to threshold value specified by RX_BUF_THLD field in DATA_BUFFER_THLD_CTRL register. This interrupt will be cleared automatically when number of entries in receive buffer is less than threshold value specified.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_THLD_STS</name>
	<description>Transmit Buffer Threshold Status.

This interrupt is generated when number of empty locations in transmit buffer is greater than or equal to threshold value specified by TX_EMPTY_BUF_THLD field in DATA_BUFFER_THLD_CTRL register. This interrupt will be cleared automatically when number of empty locations in transmit buffer is less than threshold value specified.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_PRESENT_STATE_REG</name>
	<description>Present State Register </description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x10000003</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MASTER_IDLE</name>
	<description>This field reflects whether the Master Controller is in Idle state or not. This bit will set when all the Queues(Command , Response, IBI) and Buffers(Transmit and Receive) are empty along with the Master State machine is in Idle state.

Values:

0x0 (MST_NOT_IDLE): Master Controller is not in IDLE State
0x1 (MST_IDLE): Master Controller is in IDLE State.
</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_TID</name>
	<description>This field reflects the Transaction-ID of the current executing command.</description>
	<bitRange>[27:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CM_TFR_ST_STS</name>
	<description>Current Master Transfer State Status.

Indicates the state of current transfer currently executing by the DWC_mipi_i3c controller. This is valid in Master mode only.

6'h0: IDLE (Controller is Idle state, waiting for commands from application or Slave initated In-band Interrupt)
6'h1: START Generation State.
6'h2: RESTART Generation State.
6'h3: STOP Generation State.
6'h4: START Hold Generation for the Slave Initiated START State.
6'h5: Broadcast Write Address Header(7'h7E,W) Generation State.
6'h6: Broadcast Read Address Header(7'h7E,R) Generation State.
6'h7: Dynamic Address Assignment State.
6'h8: Slave Address Generation State.
6'hB: CCC Byte Generation State.
6'hC: HDR Command Generation State.
6'hD: Write Data Transfer State.
6'hE: Read Data Transfer State.
6'hF: In-Band Interrupt(SIR) Read Data State.
6'h10: In-Band Interrupt Auto-Disable State
6'h11: HDR-DDR CRC Data Generation/Receive State.
6'h12: Clock Extension State.
6'h13: Halt State.
</description>
	<bitRange>[21:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CM_TFR_STS</name>
	<description>Transfer Type Status.

Indicates the type of transfer currently executing by the DWC_mipi_i3c controller.

In Master mode of operation :

6'h0: IDLE (Controller is in Idle state, waiting for commands from application or Slave initated In-band Interrupt)
6'h1: Broadcast CCC Write Transfer.
6'h2: Directed CCC Write Transfer.
6'h3: Directed CCC Read Transfer.
6'h4: ENTDAA Address Assignment Transfer.
6'h5: SETDASA Address Assignment Transfer.
6'h6: Private I3C SDR Write Transfer.
6'h7: Private I3C SDR Read Transfer.
6'h8: Private I2C SDR Write Transfer.
6'h9: Private I2C SDR Read Transfer.
6'hA: Private HDR Ternary Symbol(TS) Write Transfer.
6'hB: Private HDR Ternary Symbol(TS) Read Transfer.
6'hC: Private HDR Double-Data Rate(DDR) Write Transfer.
6'hD: Private HDR Double-Data Rate(DDR) Read Transfer.
6'hE: Servicing In-Band Interrupt Transfer.
6'hF: Halt state (Controller is in Halt State, waiting for the application to resume through DEVICE_CTRL Register)
</description>
	<bitRange>[13:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CURRENT_MASTER</name>
	<description>This Bit is used to check whether the Master is Current Master or not. The Current Master is the Master that owns the SCL line.

If this bit is set to 0, the Master is not Current Master and requires to request and the ownership before initiating any transfer on the line.

If this bit is set to 1, the Master is the Current Master and can initate the transfers on the line.

0: Master is not Current Master
1: Master is Current Master</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDA_LINE_SIGNAL_LEVEL</name>
	<description>This bit is used to check the SDA line level to recover from errors and for debugging. This bit reflects the value of synchronized sda_in_a signal. This is valid in Master mode only.
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SCL_LINE_SIGNAL_LEVEL</name>
	<description>This bit is used to check the SCL line level to recover from errors and for debugging. This bit reflects the value of synchronized scl_in_a signal. This is valid in Master mode only</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_QUEUE_SIZE_CAPABILITY_REG</name>
	<description>DWC_mipi_i3c Queue Size Capability Register </description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00021244</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IBI_BUF_SIZE</name>
	<description>IBI Queue Size

This field reflects the configured IBI Queue size (in DWORDS) in Encoded Values.

Values:

- 0x0 : 2 DWORDS

- 0x1 : 4 DWORDS

- 0x2 : 8 DWORDS

- 0x3 : 16 DWORDS
</description>
	<bitRange>[19:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESP_BUF_SIZE</name>
	<description>Response Queue Size

This field reflects the configured Response Queue size (in DWORDS) in Encoded Values.

Values:

- 0x0 : 2 DWORDS

- 0x1 : 4 DWORDS

- 0x2 : 8 DWORDS

- 0x3 : 16 DWORDS</description>
	<bitRange>[15:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_BUF_SIZE</name>
	<description>Command Queue Size

This field reflects the configured Command Queue size (in DWORDS) in Encoded Values.

Values:

- 0x0 : 2 DWORDS

- 0x1 : 4 DWORDS

- 0x2 : 8 DWORDS

- 0x3 : 16 DWORDS
</description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_BUF_SIZE</name>
	<description>Receive Data Buffer Size

This field reflects the configured Receive Buffer size (in DWORDS) in Encoded Values.

Values:

- 0x0 : 2 DWORDS

- 0x1 : 4 DWORDS

- 0x2 : 8 DWORDS

- 0x3 : 16 DWORDS

- 0x4 : 32 DWORDS

- 0x5 : 64 DWORDS</description>
	<bitRange>[7:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_BUF_SIZE</name>
	<description>Transmit Data Buffer Size

This field reflects the configured Transmit Buffer size (in DWORDS) in Encoded Values.

Values:

- 0x0 : 2 DWORDS

- 0x1 : 4 DWORDS

- 0x2 : 8 DWORDS

- 0x3 : 16 DWORDS

- 0x4 : 32 DWORDS

- 0x5 : 64 DWORDS
</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_QUEUE_STATUS_LEVEL_REG</name>
	<description>Queue Status Level Register </description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IBI_STS_CNT</name>
	<description>IBI Buffer Status Count.

Contains the number of IBI status entries in the IBI Buffer.

This field is used in master mode of operation.</description>
	<bitRange>[28:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IBI_BUF_BLR</name>
	<description>IBI Buffer Level Value.

Contains the number of valid entries in the IBI Buffer.

This field is used in master mode of operation.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESP_BUF_BLR</name>
	<description>Response Buffer Level Value.

Contains the number of valid data entries in the response Buffer.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CMD_QUEUE_EMPTY_LOC</name>
	<description>Command Queue Empty Locations.

Contains the number of empty locations in the command Buffer.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_QUEUE_THLD_CTRL_REG</name>
	<description>Queue Threshold Control Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x01000101</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IBI_STATUS_THLD</name>
	<description>In-Band Interrupt Status Threshold Value.

Every In Band Interrupt received (with or without data) by I3C controller generates an IBI status. This field controls the number of IBI status entries (or greater) in the IBI queue that trigger the IBI_THLD_STAT interrupt.

The valid range is 0 to 7. The software shall program only valid values. A value of 0 sets the threshold for 1 entry, and a value of N sets the threshold for N+1 entries.</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_BUF_THLD</name>
	<description>Response Buffer Threshold Value.

Controls the number of entries (or greater) in the Response Queue that trigger the RESP_READY_STAT_INTR interrupt.

The valid range is 0 to 3. The software shall program only valid values. A value of 0 sets the threshold for 1 entry, and a value of N sets the threshold for N+1 entries.
</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_EMPTY_BUF_THLD</name>
	<description>Command Buffer Empty Threshold Value. Controls the number of empty locations (or greater) in the Command Queue that trigger CMD_QUEUE_READY_STAT interrupt.

The valid range is 0 to 7. The software shall program only valid values. Value of N ranging from 1 to 7 sets the threshold to N empty locations and a value of 0 sets the threshold to indicate that the queue is completely empty.
</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_RESET_CTRL_REG</name>
	<description>Reset Control Register </description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IBI_QUEUE_RST</name>
	<description>IBI Queue Software Reset.

This bit is only used in master mode of operation.

Write 1'b1 to this bit to exercise IBI Queue reset This bit will be cleared automatically once the IBI Queue reset is completed.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RX_FIFO_RST</name>
	<description>Receive Buffer Software Reset.

Write 1'b1 to this bit to exercise Receive Buffer reset. This bit will be cleared automatically once the Receive buffer reset is completed.
</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TX_FIFO_RST</name>
	<description>Transmit Buffer Software Reset.

Write 1'b1 to this bit to exercise Transmit Buffer reset. This bit will be cleared automatically once the Transmit Buffer reset is completed.
</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESP_QUEUE_RST</name>
	<description>Response Queue Software Reset.

Write 1'b1 to this bit to exercise Response Queue reset. This bit will be cleared automatically once the Response Queue reset is completed.
</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_QUEUE_RST</name>
	<description>Command Queue Software Reset.

Write 1'b1 to this bit to exercise Command Queue reset. This bit will the cleared automatically once the Command Queue reset is completed.
</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SOFT_RST</name>
	<description>Core Software Reset.

Write 1'b1 to this bit to exercise software reset. This will reset all Buffers - Receive, Transmit, Command and Response This bit will be cleared automatically once the core reset is completed.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_RESPONSE_QUEUE_PORT_REG</name>
	<description>RESPONSE_QUEUE_PORT</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RESPONSE</name>
	<description>32 bit Response
</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_RX_TX_DATA_PORT_REG</name>
	<description>Receive and Transmit Data Port Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RX_TX_DATA_PORT</name>
	<description>Receive and Transmit Data Port. (Merged in Doxbox)

The Receive data port is mapped to the Rx-Data Buffer.

The Receive data is always packed in 4-byte aligned data words and stored in the Rx-Data Buffer. If the command length is not aligned to the 4-bytes, then the additional data bytes have to be ignored.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SCL_EXT_LCNT_TIMING_REG</name>
	<description>SCL Extended Low Count Timing Register </description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x20202020</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I3C_EXT_LCNT_4</name>
	<description>I3C Extended Low Count Register 4

SDR4 uses this register field for data transfer.</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_EXT_LCNT_3</name>
	<description>I3C Extended Low Count Register 3

SDR3 uses this register field for data transfer.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_EXT_LCNT_2</name>
	<description>I3C Extended Low Count Register 2

SDR2 uses this register field for data transfer.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_EXT_LCNT_1</name>
	<description>I3C Extended Low Count Register 1

SDR1 uses this register field for data transfer.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SCL_EXT_TERMN_LCNT_TIME_REG</name>
	<description> SCL Termination Bit Low count Timing Register </description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I3C_EXT_TERMN_LCNT</name>
	<description>I3C Read Termination Bit Low count.

Extended I3C Read Termination Bit low count for I3C Read transfers. Effective Termination-Bit Low Period is derived based on the SDR speed as shown below

SDR0 speed: I3C_PP_LCNT + I3C_EXT_TERMN_LCNT
SDR1 speed: I3C_EXT_LCNT_1 + I3C_EXT_TERMN_LCNT
SDR2 speed: I3C_EXT_LCNT_2 + I3C_EXT_TERMN_LCNT
SDR3 speed: I3C_EXT_LCNT_3 + I3C_EXT_TERMN_LCNT
SDR4 speed: I3C_EXT_LCNT_4 + I3C_EXT_TERMN_LCNT</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SCL_I2C_FMP_TIMING_REG</name>
	<description>SCL I2C Fast Mode Plus Timing Register </description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00100010</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_FMP_HCNT</name>
	<description>I2C Fast Mode Plus High Count

The SCL open-drain high count timing for I2C fast mode transfers.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_FMP_LCNT</name>
	<description>I2C Fast Mode Plus Low Count

The SCL open-drain low count timing for I2C fast mode transfers.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SCL_I2C_FM_TIMING_REG</name>
	<description>SCL I2C Fast Mode Timing Register </description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00100010</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_FM_HCNT</name>
	<description>I2C Fast Mode High Count

The SCL open-drain high count timing for I2C fast mode transfers.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_FM_LCNT</name>
	<description>I2C Fast Mode Low Count

The SCL open-drain low count timing for I2C fast mode transfers.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SCL_I3C_OD_TIMING_REG</name>
	<description>SCL I3C Open Drain Timing Register </description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000a0010</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I3C_OD_HCNT</name>
	<description>I3C Open Drain High Count.

SCL open-drain High count (I3C) for I3C transfers targeted to I3C devices.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_OD_LCNT</name>
	<description>I3C Open Drain Low Count.

SCL Open-drain low count for I3C transfers targeted to I3C devices.
</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SCL_I3C_PP_TIMING_REG</name>
	<description>SCL I3C Push Pull Timing Register</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000a000a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I3C_PP_HCNT</name>
	<description>I3C Push Pull High Count.

SCL push-pull High count for I3C transfers targeted to I3C devices.
</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I3C_PP_LCNT</name>
	<description>I3C Push Pull Low Count.

SCL Push-pull low count for I3C transfers targeted to I3C devices.
</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SDA_HOLD_DLY_TIMING_REG</name>
	<description> SDA Hold Delay Timing Register</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00010000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SDA_TX_HOLD</name>
	<description>This field controls the hold time (in term of the core clock period) of the transmit data (SDA) with respect to the SCL edge in FM FM+ SDR and DDR speed mode of operations. This field is not applicable for the ternary speed modes. The valid values are 1 to 7. Others are Reserved.</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I3C_SLV_EVENT_STATUS_REG</name>
	<description>Slave Event Status Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MWL_UPDATED</name>
	<description>MWL Updated Status.

This bit indicates a SETMWL CCC is received by the slave. The updated MWL value can be read from SLV_MAX_LEN register. This status can be cleared by writing 1'b1 to this field after reading the updated MWL.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRL_UPDATED</name>
	<description>MRL Updated Status.

This bit indicates a SETMRL CCC is received by the slave. The updated MRL value can be read from SLV_MAX_LEN register. This status can be cleared by writing 1'b1 to this field after reading the updated MRL.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ACTIVITY_STATE</name>
	<description>Activity State Status.

ENTAS0 - 00

ENTAS1 - 01

ENTAS2 - 10

ENTAS3 - 11

This bit reflects the Activity State of slave set by the Master.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_VENDOR_SPECIFIC_REG_PTR_REG</name>
	<description>Pointer for Vendor specific Registers </description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000b0</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>P_VENDOR_REG_START_ADDR</name>
	<description>Start Address of Vendor specific registers.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_VER_ID_REG</name>
	<description>DWC_mipi_i3c Version ID Register </description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3130302a</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I3C_VER_ID</name>
	<description>Current release type

This field indicates the Synopsys DesignWare Cores DWC_mipi_i3c current release type that is read by an application.

For example, release type &quot;ga&quot; is represented in ASCII as 0x6761 and &quot;ea&quot; is represented as 0x6561. Lower 16 bits read from this register can be ignored by the application if release type is &quot;ga&quot;. If release type is &quot;ea&quot; the lower 16 bits represents the &quot;ea&quot; release version.

An application reading this register along with the I3C_VER_ID register, gathers details of the current release.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I3C_VER_TYPE_REG</name>
	<description> DWC_mipi_i3c Version Type Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x6c633033</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I3C_VER_TYPE</name>
	<description>Current release type

This field indicates the Synopsys DesignWare Cores DWC_mipi_i3c current release type that is read by an application.

For example, release type &quot;ga&quot; is represented in ASCII as 0x6761 and &quot;ea&quot; is represented as 0x6561. Lower 16 bits read from this register can be ignored by the application if release type is &quot;ga&quot;. If release type is &quot;ea&quot; the lower 16 bits represents the &quot;ea&quot; release version.

An application reading this register along with the I3C_VER_ID register, gathers details of the current release.
</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>LCDC</name>
	<version>1.0</version>
	<description>LCDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30030000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>2048</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>LCDC_BACKPORCHXY_REG</name>
	<description>Back Porch X and Y</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BPORCH_X</name>
	<description>Back porch X (lines)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BPORCH_Y</name>
	<description>Back porch Y (pixel clocks)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_BGCOLOR_REG</name>
	<description>Background Color</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BG_RED</name>
	<description>Red color used as background.</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BG_GREEN</name>
	<description>Green color used as background.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BG_BLUE</name>
	<description>Blue color used as background.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BG_ALPHA</name>
	<description>Alpha color used as background.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_BLANKINGXY_REG</name>
	<description>Blanking X and Y</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLANKING_X</name>
	<description>Blanking period X (VSYNC lines)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLANKING_Y</name>
	<description>Blanking period Y (HSYNC pulse length)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_CLKCTRL_CG_REG</name>
	<description>Controls the CLock Gaters and the routing of format and pixel clock</description>
	<addressOffset>0x000001a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>LCDC_SWAP_PIX_FORMAT_CLK</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_INV_CLK_POLARITY</name>
	
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_CLK_DIV_EN</name>
	
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_CLKCTRL_REG</name>
	<description>Clock Divider</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000401</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SEC_CLK_DIV</name>
	<description>Secondary clock divider that generates the format pipeline clock. Source clock of this divider is the main clock of LCD controller. The period of the generated clock is defined as : (LCDC_SEC_CLK_DIV + 1) x period_of_main_clock.</description>
	<bitRange>[31:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_HOLD</name>
	<description>Hold time before DMA activated.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_DIV</name>
	<description>Clock divider that generates the pixel pipeline clock. Source clock of this divider is the format pipeline clock (see also LCDC_SEC_CLK_DIV). The period of the generated clock is defines as : LCDC_CLK_DIV x period_of_format_clk. A zero value gives division by one.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_COLMOD</name>
	<description>Color mode status register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x2070f858</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BP_DBIB</name>
	<description>Indicates that back pressure support for the DBI Type B interface is enabled</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COLMODES</name>
	<description>16 bit: Indicates that the LUT8 color format is enabled
15 bit: Indicates that the RGBA5551 16-bit color format is enabled
14 bit: Indicates that the RGBA8888 32-bit color format is enabled
13 bit: Indicates that the RGB332 8-bit color format is enabled
12 bit: Indicates that the RGB565 16-bit color format is enabled
11 bit: Indicates that the ARGB8888 32-bit color format is enabled
10 bit: Indicates that the L8 color format is enabled
9 bit: Indicates that the L1 color format is enabled
8 bit: Indicates that the L4 color format is enabled
7 bit: Indicates that the YUYV color format is enabled
6 bit: Indicates that the RGB888 24-bit color format is enabled
5 bit: Indicates that the YUY2 color format is enabled
4 bit: Indicates that the ABGR8888 32-bit color format is enabled
3 bit: Indicates that the BGRA8888 32-bit color format is enabled
2 bit: Indicates that the V_YUV420 color format is enabled
1 bit: Indicates that the TLYUV420 color format is enabled
0 bit: Indicates that the TSc4/TSc6 propietary color format is enabled</description>
	<bitRange>[16:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LCDC_CONF_REG</name>
	<description>Supported config</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00003359</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CONF</name>
	
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LCDC_CRC_REG</name>
	<description>CRC check</description>
	<addressOffset>0x00000184</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CRC</name>
	<description>CRC check.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LCDC_DBIB_CFG_REG</name>
	<description>MIPI Config Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DBIB_INTERFACE_EN</name>
	<description>When set to 1, the DBI Type-B interface is activated</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_CSX_CFG_EN</name>
	<description>When set to 1, the value of the CSX signal of the DBI Type-B interface can be configured from
the DBIB_CFG[29] register bit</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_CSX_CFG</name>
	<description>Sets the value of DBIB_CSX signal:
CSX is set to one if DBIB_CFG[29] has the value of one
CSX is set to zero if DBIB_CFG[29] has the value of zero</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_TE_DISABLE</name>
	<description>When set to 1, the DBIB_TE signal is disabled</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DC_AS_SPI_SD1</name>
	<description>When set to 1, enables the usage of SPI_DC wire as SPI_SD1</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_FORCE_IDLE</name>
	<description>When set to 1, force DBI Type-B interface to idle state. Swap on the fly data for the interface</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_RESX_OUT_EN</name>
	<description>Drives DBIB_RESX output signal of DBI Type-B interface</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SUB_PIXEL_REVERSE</name>
	<description>Reverse sub pixel order</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI3_EN</name>
	<description>When set to 1, SPI 3-wire interface is enabled</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI4_EN</name>
	<description>When set to 1, SPI 4-wire interface is enabled</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_BACK_PRESSURE_EN</name>
	<description>When set to 1, Enables back-pressure for DBI Type-B interface</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_PHASE</name>
	<description>Sets SPI Clock Phase</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_POLARITY</name>
	<description>Sets SPI Clock Polarity</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPID_JDI</name>
	
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_DATA_AS_HEADER</name>
	<description>When set to 1, command data are used as header of each line</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BIT_ORDER_ADDR_INVERT</name>
	<description>When set to 1, inverts the bit-order of the horizontal line address (used along with DBIB_CFG[17]
register bit)</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_2BYTE_ADDR</name>
	<description>When set to 1, two-byte address is sent with each horizontal line (SPI)</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PIX_CLK_AT_DBIB_CLK</name>
	<description>When set to 1, expose pixel generation clock on the DBIB_CLK</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EXT_CTRL_EN</name>
	<description>When set to 1, enables the external control</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HORIZONTAL_BLANK_EN</name>
	<description>When set to 1, enables the horizontal blanking</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DUAL_SPI_SUBPIXEL_EXTRACT_EN</name>
	<description>When set to 1, Enables DualSPI sub-pixel transaction</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QUAD_SPI_EN</name>
	<description>When set to 1, Enables QuadSPI</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DUAL_SPI_EN</name>
	<description>When set to 1, Enables DualSPI</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_INTERFACE_WIDTH</name>
	<description>Set DBI Type-B interface width (8, 9 or 16 bits) and the serial interface:
0x0: 8-bit interface
0x1: 9-bit interface
0x2: 16-bit interface
0x3: SPI
0x4: Dual SPI
0x5: Quad SPI</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_DATA_ORDER</name>
	<description>Set the data order of the 8-bit data word:
0x0: option 0
0x1: option 1
0x2: option 2
0x3: option 3
0x4: option 4
0x5: Reserved
0x6: Reserved
0x7: Reserved</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_COLOR_FMT</name>
	<description>Defines the output format and depends of the type of the output interface. For the SPI3/SPI4 are supported the following formats:
0x0 : Reserved
0x1 : RGB111
0x2 : RGB332
0x3 : RGB444
0x4 : Reserved
0x5 : RGB565
0x6 : RGB666
0x7 : RGB888</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_DBIB_CMD_REG</name>
	<description>MIPI DBIB Command Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PART_UPDATE</name>
	<description>When set to 0, indicates that the command data are the Base address for partial update. Applied
on SPI/JDI-SPI type</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_CMD_SEND</name>
	<description>Send command to the DBI interface</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMD_WIDTH</name>
	<description>Determine the command width. Applicable only on the QuadSPI
0x00: 1 Byte
0x01: 2 Bytes
0x02: 3 Bytes
0x03: Reserved</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_CMD_STORE</name>
	<description>This bit has meaning only when LCDC_DBIB_CFG_REG[LCDC_DBIB_SPI_JDI] = 1. When is enabled, stores the LCDC_DBIB_CMD_VAL to the register that keeps the Y position. </description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RD_MODE_EN</name>
	<description>When sets to 1, read mode is enabled</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FMTCTRL_EXPOSE_SETTING</name>
	<description>When sets to 1, FMTCTRL[15:8] is exposed on DBIB_CT pins and FMTCTRL[31] on DBIB_GE
else FMTCTRL[15:8] is exposed on DBIB_CT pins and FMTCTRL[30] on DBIB_GE</description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ST_INT_CMD_TYPE</name>
	<description>When sets to 1, store internally a command type which is transmitted at the beggining of each
scanline</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_CMD_VAL</name>
	<description>Data to send to the DBI interface</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_DBIB_RDAT</name>
	<description>Data read by DBI Type-B/SPI interface</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DBIB_RDAT</name>
	<description>On Write:
31-30 bits: Specify the number of read cycles
0x0: 8 cycles
0x1: 16 cycles
0x2: 24 cycles
0x3: Used along with FMTCTRL[20:16] register bits
29-0 bits: Reserved

On Read:
31-0 bits: Read data from DBI Type-B/SPI interfaces</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_FMTCTRL_2_REG</name>
	<description>DBI and JDI format control</description>
	<addressOffset>0x000001a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FMTCTRL</name>
	<description>Bits Description
When DBI-Type B Interface is selected:
Bits Description
31-16 bits: Reserved
15-0 bits: Specify the blanking period length for the X dimension
When JDI-Parallel Interface is selected:
Bits Description
31-20 bits: Reserved
19-10 bits: JDI ENB width
9-0 bits: JDI ENB offset</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_FMTCTRL_REG</name>
	<description>DBI and JDI format control</description>
	<addressOffset>0x000001a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FMTCTRL</name>
	<description>When DBI-Type B Interface is selected:
Bits Description
31 bit : Candidate for DBIB_GE, associated with [15:8] bits (DSI interface specific)
30 bit : Candidate for DBIB_GE, associated with [7:0] bits (DSI interface specific)
29-21 bits: Reserved
20-16 bits: Specify the number of read cycles for SPI/DBI Type-B. Used along with DBIB_CFG[31:30]
register bits
0x0: 1 cycles
0x1: 2 cycles
0x2: 3 cycles
.
.
0x30: 31 cycles
0x31: 32 cycles
15-8 bits : Candidate DBIB_CT (DSI interface specific)
7-0 bits : Candidate DBIB_CT (DSI interface specific)
When JDI-Parallel Interface is selected:
Bits Description
31 bit : Mute DPI outputs
30 bit : Mask DPIREADY input
29 bit : Reserved
28-26 bits : JDI HST width
25-23 bits : JDI HST offset
22-13 bits : JDI VST width
12-3 bits : JDI VST offset
2-0 bits : Reserved</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_FRONTPORCHXY_REG</name>
	<description>Front Porch X and Y</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FPORCH_X</name>
	<description>Front porch X (lines)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FPORCH_Y</name>
	<description>Front porch Y (pixel clocks)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_GPIO_REG</name>
	<description>General Purpose IO (8-bits)</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DPI_CM_ASSERT</name>
	<description>Assert DPI-2 Color Mode signal</description>
	<bitRange>[16:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DPI_SD_ASSERT</name>
	<description>Assert DPI-2 Shutdown signal</description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SCAL_ADVANCE</name>
	<description>scalar advance</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LCDC_OTHER</name>
	<description>TBD
</description>
	<bitRange>[12:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPIO_SPI_SI_ON_SD_PAD</name>
	<description>Enable to have the SPI SI on the SPI SD pad</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPIO_OUTPUT_MODE</name>
	<description>Select the mode that should be mapped on the GPIO pins
0x0 = JDI
0x1 = DPI
0x2 = DBI
0x3 = SPI</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GPIO_OUTPUT_EN</name>
	<description>Enable the GPIO pins for LCDC control. The GPIO_OUTPUT_MODE is used to define what LCDC pins will be mapped towards the GPIO pins.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TE_INV</name>
	<description>Applies an inversion on the TE (tearing effect) signal.
0 : the inversion is not applied on the TE signal
1 : the inversion is applied on TE signal</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_DIV_2DIV3</name>
	<description>Divide clock by 2/3 clock-gating. This is required when the DSI-DPHY is used with 2 lanes active.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_IDREG_REG</name>
	<description>Identification Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>NEMADC_ID</name>
	<description>Identification register</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>LCDC_INTERRUPT_REG</name>
	<description>Interrupt Register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>IRQ_TRIGGER_SEL</name>
	<description>IRQ trigger control
0: Level triggering
1: Edge triggering
In the case of the level triggering, the request remains active in the LCDC until to be cleared. The request can be cleared by performing a write access in the LCDC_INTERRUPT_REG. This is not required in the case of the edge triggering.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_OUT</name>
	
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FE_IRQ_EN</name>
	
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TE_IRQ_EN</name>
	
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MMU_ERROR_IRQ_EN</name>
	
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HSYNC_IRQ_EN</name>
	<description>HSYNC interrupt enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VSYNC_IRQ_EN</name>
	<description>VSYNC or TE interrupt enabled. See also the configuration bit LCDC_DBIB_CFG_REG[LCDC_DBIB_TE_DIS] for the TE signal.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_BASEADDR_REG</name>
	<description>Layer0 Base Addr</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L0_BASE_ADDR</name>
	<description>Base Address of the frame buffer</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_MODE_REG</name>
	<description>Layer0 Mode</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L0_EN</name>
	<description>Enable layer.
0 : disable
1 : enable</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_FORCE_ALPHA</name>
	<description>When set to 1, force alpha with global alpha</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_DIS_BIL_FILTERING</name>
	<description>When set to 0, bilinear filtering is enabled. Scaler should be enabled</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_PREMUL_IMG_ALPHA</name>
	<description>When set to 1, premultiply image alpha is enabled</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_ASSERT_HCLK_DMA</name>
	<description>When set to 1, HLOCK signal on AHB DMAs is asserted</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_GAMMA_LUT_EN</name>
	<description>When set to 1, Gamma Look Up Table is enabled</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_ALPHA</name>
	<description>Alpha layer global value (0x00-0xFF range)</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_DST_BLEND</name>
	<description>Destinary Blending Function
0000: BLEND ZERO
0001: BLEND ONE
0010: BLEND ALPHA SRC
0011: BLEND ALPHA GBL
0100: BLEND ALPHA SRCGBL
0101: BLEND INV SRC
0110: BLEND INV GBL
0111: BLEND INV SRCGBL
1010: BLEND ALPHA DST
1101: BLEND INV DST
</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_SRC_BLEND</name>
	<description>Source Blending Function
0000: BLEND ZERO
0001: BLEND ONE
0010: BLEND ALPHA SRC
0011: BLEND ALPHA GBL
0100: BLEND ALPHA SRCGBL
0101: BLEND INV SRC
0110: BLEND INV GBL
0111: BLEND INV SRCGBL
1010: BLEND ALPHA DST
1101: BLEND INV DST
</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_COLOR_MODE</name>
	<description>Color Mode:
00001: 16-bit RGBX5551 color format,
00010: 32-bit RGBX8888 color format,
00100: 8-bit RGB332 color format,
00101: 16-bit RGB565 color format,
00110: 32-bit XRGB8888,
00111: L8 Grayscale/Palette format,
01000: L1 Grayscale/Palette format,
01001: L4 Grayscale/Palette format,
01101: ABGR8888,
01110: BGRA8888</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_RESXY_REG</name>
	<description>Layer0 Res XY</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L0_RES_X</name>
	<description>Resolution X (Resolution of layer in pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_RES_Y</name>
	<description>Resolution Y (Resolution of layer in pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_SIZEXY_REG</name>
	<description>Layer0 Size XY</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L0_SIZE_X</name>
	<description>Size X (Size of layer in pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_SIZE_Y</name>
	<description>Size Y (Size of layer in pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_STARTXY_REG</name>
	<description>Layer0 Start XY</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L0_START_X</name>
	<description>Start X (offset pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_START_Y</name>
	<description>Start Y (offset pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER0_STRIDE_REG</name>
	<description>Layer0 Stride</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L0_FIFO_THR</name>
	<description>Layer dma fifo threshold burst start
00: half fifo (default)
01: 2 burst size
10: 4 burst size
11: 8 burst size</description>
	<bitRange>[20:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_BURST_LEN</name>
	<description>Layer burst length
000: 16-beats (default)
001: 2-beats
010: 4-beats
011: 8-beats
100: 16-beats</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L0_STRIDE</name>
	<description>Layer Stride (distance from line to line in bytes)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER1_BASEADDR_REG</name>
	<description>Layer1 Base Addr</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1_BASE_ADDR</name>
	<description>Base Address of the frame buffer</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER1_MODE_REG</name>
	<description>Layer1 Mode</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1_EN</name>
	<description>Enable layer.
0 : disable
1 : enable</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_FORCE_ALPHA</name>
	<description>When set to 1, force alpha with global alpha</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_DIS_BIL_FILTERING</name>
	<description>When set to 0, bilinear filtering is enabled. Scaler should be enabled</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_PREMUL_IMG_ALPHA</name>
	<description>When set to 1, premultiply image alpha is enabled</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_ASSERT_HCLK_DMA</name>
	<description>When set to 1, HLOCK signal on AHB DMAs is asserted</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_GAMMA_LUT_EN</name>
	<description>When set to 1, Gamma Look Up Table is enabled</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_ALPHA</name>
	<description>Alpha layer global value (0x00-0xFF range)</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_DST_BLEND</name>
	<description>Destinary Blending Function
0000: BLEND ZERO
0001: BLEND ONE
0010: BLEND ALPHA SRC
0011: BLEND ALPHA GBL
0100: BLEND ALPHA SRCGBL
0101: BLEND INV SRC
0110: BLEND INV GBL
0111: BLEND INV SRCGBL
1010: BLEND ALPHA DST
1101: BLEND INV DST
</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_SRC_BLEND</name>
	<description>Source Blending Function
0000: BLEND ZERO
0001: BLEND ONE
0010: BLEND ALPHA SRC
0011: BLEND ALPHA GBL
0100: BLEND ALPHA SRCGBL
0101: BLEND INV SRC
0110: BLEND INV GBL
0111: BLEND INV SRCGBL
1010: BLEND ALPHA DST
1101: BLEND INV DST
</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_COLOR_MODE</name>
	<description>Color Mode:
00001: 16-bit RGBX5551 color format,
00010: 32-bit RGBX8888 color format,
00100: 8-bit RGB332 color format,
00101: 16-bit RGB565 color format,
00110: 32-bit XRGB8888,
00111: L8 Grayscale/Palette format,
01000: L1 Grayscale/Palette format,
01001: L4 Grayscale/Palette format,
01101: ABGR8888,
01110: BGRA8888</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER1_RESXY_REG</name>
	<description>Layer1 Res XY</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1_RES_X</name>
	<description>Resolution X (Resolution of layer in pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_RES_Y</name>
	<description>Resolution Y (Resolution of layer in pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER1_SIZEXY_REG</name>
	<description>Layer1 Size XY</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1_SIZE_X</name>
	<description>Size X (Size of layer in pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_SIZE_Y</name>
	<description>Size Y (Size of layer in pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER1_STARTXY_REG</name>
	<description>Layer0 Start XY</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1_START_X</name>
	<description>Start X (offset pixels)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_START_Y</name>
	<description>Start Y (offset pixels)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_LAYER1_STRIDE_REG</name>
	<description>Layer1 Stride</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>L1_FIFO_THR</name>
	<description>Layer dma fifo threshold burst start
00: half fifo (default)
01: 2 burst size
10: 4 burst size
11: 8 burst size</description>
	<bitRange>[20:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_BURST_LEN</name>
	<description>Layer burst length
000: 16-beats (default)
001: 2-beats
010: 4-beats
011: 8-beats
100: 16-beats</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>L1_STRIDE</name>
	<description>Layer Stride (distance from line to line in bytes)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_MODE_REG</name>
	<description>Display Mode</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MODE_EN</name>
	<description>Mode register.
0 : disable
1 : enable</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VSYNC_POL</name>
	<description>VSYNC polarity.
0: positive
1: negative</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HSYNC_POL</name>
	<description>HSYNC polarity.
0: positive
1: negative</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DE_POL</name>
	<description>DE polarity.
0: positive
1: negative</description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DITH_MODE</name>
	<description>0x00: Dithering is disabled
0x01: Dithering 18-bits mode
0x02: Dithering 16-bits mode
0x03: Dithering 15-bits mode</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VSYNC_SCPL</name>
	<description>Set VSYNC for a single cycle per line.
0: disable
1: enable</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PIXCLKOUT_POL</name>
	<description>Pixel clock out polarity.
0: positive
1: negative</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GLOBAL_GAMMA_EN</name>
	<description>When set to 1, global gamma correction is enabled</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_BLANK</name>
	<description>Forces output to blank.
0: disable
1: enable</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SFRAME_UPD</name>
	<description>Single frame update.
0: disable
1: enable</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DPI2_CONFIG</name>
	<description>Defines MIPI DPI-2 Configuration
0x00: RGB888 24-bits
0x01: RGB666 18-bits Configuration 1
0x02: RGB666 18-bits Configuration 2
0x03: RGB565 16-bits Configuration 1
0x04: RGB565 16-bits Configuration 2
0x05: RGB565 16-bits Configuration 3
0x06: Reserved
0x07: Reserved</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PIXCLKOUT_SEL</name>
	<description>Selects the pixel out clock for the display.
0: based on the pixel pipeline clock
1: based on the format pipeline clock
See also the LCDC_CLKCTRL_REG.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_MODE</name>
	<description>Selection of the output mode
0000: Parallel RGB
1000: JDI MIP
All the other values are reserved.</description>
	<bitRange>[8:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DBIB_OFF</name>
	<description>When set to 0, DBI Type-B interface is enabled</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORM_OFF</name>
	<description>Formating off
0: disabled
1: enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DSCAN</name>
	<description>Double horizontal scan
0: disabled
1: enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMODE</name>
	<description>Test mode
0: disabled
1: enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_PALETTE_255</name>
	<description>Global palette/gamma correction</description>
	<addressOffset>0x000007fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PALLETE_R</name>
	<description>Gamma ramp red bits</description>
	<bitRange>[23:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PALLETE_G</name>
	<description>Gamma ramp green bits</description>
	<bitRange>[15:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PALLETE_B</name>
	<description>Gamma ramp blue bits</description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>LCDC_PALETTE_BASE</name>
	<description>Global palette/gamma correction</description>
	<addressOffset>0x00000400</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PALLETE_R</name>
	<description>Gamma ramp red bits</description>
	<bitRange>[23:16]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PALLETE_G</name>
	<description>Gamma ramp green bits</description>
	<bitRange>[15:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PALLETE_B</name>
	<description>Gamma ramp blue bits</description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>LCDC_RESXY_REG</name>
	<description>Resolution X,Y</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RES_X</name>
	<description>Resolution X in pixels.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RES_Y</name>
	<description>Resolution Y in pixels.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_STARTXY_REG</name>
	<description>Specifies the start position of the very first frame</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>START_X</name>
	<description>Specify framess X dimension</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>START_Y</name>
	<description>Specify framess Y dimension</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>LCDC_STATUS_REG</name>
	<description>Status Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DBIB_CMD_FIFO_FULL</name>
	<description>Indicates if the command FIFO is full</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBI_SPI_CS</name>
	<description>Indicates DBI/SPI CS status</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FRAME_END</name>
	<description>Frame end (active high)</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBIB_OUT_TRANS_PENDING</name>
	<description>Pending output transaction in DBI Type-B interface</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBIB_CMD_PENDING</name>
	<description>Transferring of command in progress.
0: idle
1: in progress</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBIB_DATA_PENDING</name>
	<description>Pending RGB data in DBI Type-B interface</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBIB_TE</name>
	<description>The DBIB tearing effect signal</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STICKY_UNDERFLOW</name>
	<description>Sticky underflow(clear with write in the LCDC_INTERRUPT_REG)
0: There is no underflow
1: Underflow has been detected.Remains high until to be cleared by performing a write access on the register LCDC_INTERRUPT_REG.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UNDERFLOW</name>
	<description>Underflow on the current transfer.
0: There is no underflow
1: Underflow has been detected. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LAST_ROW</name>
	<description>Last row (Last row is currently displayed)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STAT_CSYNC</name>
	<description>CSYNC signal level</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STAT_VSYNC</name>
	<description>VSYNC signal level</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STAT_HSYNC</name>
	<description>HSYNC signal level</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FRAMEGEN_BUSY</name>
	<description>The frame generator is busy (active high).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STAT_ACTIVE</name>
	<description>Active (When not in vertical blanking)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MEMCTRL</name>
	<version>1.0</version>
	<description>MEMCTRL registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>136</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BUSY_RESET_REG</name>
	<description>BSR Reset Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_SDADC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SRC2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_I3C</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_I2C3</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_I2C2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SPI3</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SPI2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART3</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BUSY_RESET_REG2</name>
	<description>BSR2 Reset Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_TIMER6</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER5</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER4</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER3</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BUSY_SET_REG</name>
	<description>BSR Set Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_SDADC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[31:30]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[29:28]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SRC2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[27:26]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[25:24]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[23:22]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[21:20]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_I3C</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[19:18]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_I2C3</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[17:16]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_I2C2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[15:14]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[13:12]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SPI3</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SPI2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART3</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>writeOnce</access>
	</field></fields>
</register><register>
	<name>BUSY_SET_REG2</name>
	<description>BSR2 Set Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_TIMER6</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER5</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER4</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER3</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>writeOnce</access>
	</field></fields>
</register><register>
	<name>BUSY_STAT_REG</name>
	<description>BSR Status Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_SDADC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[31:30]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[29:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SRC2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[27:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[21:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_I3C</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[19:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_I2C3</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_I2C2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SPI3</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SPI2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART3</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BUSY_STAT_REG2</name>
	<description>BSR2 Status Register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BUSY_TIMER6</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER5</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER4</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER3</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CMAC_STATUS_REG</name>
	<description>Memory Arbiter Status Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>CMI_CLEAR_READY</name>
	<description>Writing a '1' clears CMI_NOT_READY bit.</description>
	<bitRange>[13:13]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CMI_NOT_READY</name>
	<description>0: Normal operation
1: CMI access performed which couldn't be handled right away (interface doesn't allow wait cycles)</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_RFMON_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an CPUC AHB access has been buffered.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_SYS2CMAC_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an CPUS_AHB access has been buffered.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_RFMON_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB_CPUC_WR_BUFF_CNT.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_SYS2CMAC_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB_CPUS_WR_BUFF_CNT.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_RFMON_WRITE_BUFF</name>
	<description>0: No CPUC AHB write access is buffered.
1: Currently a single CPUC AHB write access is buffered in the arbiter.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_SYS2CMAC_WRITE_BUFF</name>
	<description>0: No CPUS AHB write access is buffered.
1: Currently a single CPUS AHB write access is buffered in the arbiter.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CMI_CODE_BASE_REG</name>
	<description>CMAC code Base Address Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>CMI_CODE_BASE_ADDR</name>
	<description>Base address for CMAC code with steps of 1 kB.
0x001: 1 kB base address
0x010: 16 kB base address
0x100: 256 kB base address</description>
	<bitRange>[19:10]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CMI_DATA_BASE_REG</name>
	<description>CMAC data Base Address Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>CMI_DATA_BASE_ADDR</name>
	<description>Base address for CMAC data with steps of 4 bytes. Note that the CMAC address scheme is used.
0x00001: 4 byte base address
0x00010: 64 byte base address
0x00100: 1 kB base address
0x01000: 16 kB base address
0x10000: 256 kB base address</description>
	<bitRange>[19:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CMI_END_REG</name>
	<description>CMAC end Address Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000fffff</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>CMI_END_ADDR</name>
	<description>End address for CMAC code and data accesses with steps of 1 kB. Note that the CMAC address scheme is used.
0x000: accesses up to 1kB are allowed
0x001: accesses up to 2kB are allowed
0x01F: accesses up to 32kB are allowed
0x1FF: accesses up to 512kB are allowed</description>
	<bitRange>[19:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CMI_SHARED_BASE_REG</name>
	<description>CMAC shared data Base Address Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>CMI_SHARED_BASE_ADDR</name>
	<description>Base address for CMAC shared data with steps of 1 kB. Note that the CMAC address scheme is used and should only be used to point to RAM 9 or 10..
0x001: 1 kB base address
0x010: 16 kB base address
0x100: 256 kB base address</description>
	<bitRange>[19:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_PRIO_ARB1_4_REG</name>
	<description>Priority Control Register for arbiter 1, 2, 3 and 4</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ARB4_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 4
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB4_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 4.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB3_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 3
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB3_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 3.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB3_AHB_CPUC_PRIO</name>
	<description>Priority for the CPUC AHB interface of arbiter 3.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB2_SNC_PRIO</name>
	<description>Priority for the SNC interface of arbiter 2.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB2_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 2.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB2_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 2.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB2_AHB_CPUC_PRIO</name>
	<description>Priority for the CPUC AHB interface of arbiter 2.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB1_SNC_PRIO</name>
	<description>Priority for the SNC interface of arbiter 1.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB1_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 1.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB1_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 1.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB1_AHB_CPUC_PRIO</name>
	<description>Priority for the CPUC AHB interface of arbiter 1.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_PRIO_ARB5_8_REG</name>
	<description>Priority Control Register for arbiter 5, 6, 7 and 8</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ARB8_SNC_PRIO</name>
	<description>Priority for the SNC interface of arbiter 8.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB8_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 8.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB8_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 8.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB7_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 7.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB7_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 7.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB6_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 6.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB6_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 6.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB5_AHB_DMA_PRIO</name>
	<description>Priority for the DMA AHB interface of arbiter 5.
00: low priority (default)
01: mid priority
1x: high priority</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ARB5_AHB_CPUS_PRIO</name>
	<description>Priority for the CPUS AHB interface of arbiter 5.
00: low priority (default)
01: mid priority
10: high priority
11: top priority</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STALL_REG</name>
	<description>Maximum Stall cycles Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SNC_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the SNC interface. If exceeded, the interface will get high priority. Valid for a single access so the next access (of a burst) might end up in the que for the same number of wait cycles.
0: don't use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_DMA_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the DMA AHB interface. If exceeded, the interface will get high priority. Valid for a single access so the next access (of a burst) might end up in the que for the same number of wait cycles.
0: don't use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_CPUS_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the CPUS AHB interface. If exceeded, the interface will get high priority. Valid for a single access so the next access (of a burst) might end up in the que for the same number of wait cycles.
0: don't use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_CPUC_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the CPUC AHB interface. If exceeded, the interface will get high priority. Valid for a single access so the next access (of a burst) might end up in the que for the same number of wait cycles.
0: don't use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STATUS2_REG</name>
	<description>RAM cells Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>RAM13_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM13 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM12_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM12 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM11_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM11 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM10_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM10 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM9_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM9 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM8_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM8 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM7_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM7 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM6_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM6 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM5_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM5 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM4_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM4 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM3_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM3 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM2 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM1 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM0_OFF_BUT_ACCESS</name>
	<description>Reading a '1' indicates RAM0 was off but still access was performed.
Writing a '1' will clear the status back to '0'.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STATUS_REG</name>
	<description>Memory Arbiter Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>AHB_SNC_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an SNC AHB access has been buffered.</description>
	<bitRange>[23:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_DMA_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an DMA AHB access has been buffered.</description>
	<bitRange>[19:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_CPUC_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an CPUC AHB access has been buffered.</description>
	<bitRange>[15:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_CPUS_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an CPUS_AHB access has been buffered.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_SNC_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB_SNC_WR_BUFF_CNT.</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_DMA_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB_DMA_WR_BUFF_CNT.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_CPUC_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB_CPUC_WR_BUFF_CNT.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_CPUS_CLR_WR_BUFF</name>
	<description>Writing a '1' clears AHB_CPUS_WR_BUFF_CNT.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_SNC_WRITE_BUFF</name>
	<description>0: No SNC AHB write access is buffered.
1: Currently a single SNC AHB write access is buffered in the arbiter.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_DMA_WRITE_BUFF</name>
	<description>0: No DMA AHB write access is buffered.
1: Currently a single DMA AHB write access is buffered in the arbiter.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_CPUC_WRITE_BUFF</name>
	<description>0: No CPUC AHB write access is buffered.
1: Currently a single CPUC AHB write access is buffered in the arbiter.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_CPUS_WRITE_BUFF</name>
	<description>0: No CPUS AHB write access is buffered.
1: Currently a single CPUS AHB write access is buffered in the arbiter.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>OQSPIF</name>
	<version>1.0</version>
	<description>OQSPIF registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x36000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>308</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>OQSPIF_BURSTBRK_REG</name>
	<description>Read break sequence in Auto mode</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_BRK_EN</name>
	<description>Controls the application of a special command (read burst break sequence) that is used in order to force the device to abandon the continuous read mode.
0: The special command is not applied
1: The special command is applied

This special command is applied by the controller to the external device under the following conditions:
- the controller is in Auto mode
- the OSPIC_INST_MD = 1
- the previous command that has been applied in the external device was read
- the controller want to apply to the external device a command different than the read.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_SEC_HF_DS</name>
	<description>Disable output during the transmission of the second half (OSPIC_BRK_WRD[3:0]). Setting this bit is only useful if OSPIC_BRK_EN =1 and OSPIC_BRK_SZ &gt;= 1. It is not applicable when the sequence is transferred in Octal mode (OSPIC_BRK_TX_MD=3).
0: The controller drives the OSPI bus during the transmission of the OSPIC_BRK_WRD[3:0].
1: The controller leaves the OSPI bus in Hi-Z during the transmission of the OSPIC_BRK_WORD[3:0].</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_BRK_TX_MD</name>
	<description>The mode of the OSPI Bus during the transmission of the burst break sequence.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_BRK_SZ</name>
	<description>The size of Burst Break Sequence
0: One byte (Send OSPIC_BRK_WRD[15:8])
1: Two bytes (Send OSPIC_BRK_WRD[15:0])
2-15: Three up to 16 bytes will be transferred. All the bytes that will be transferred will have the value of the OSPIC_BRK_WRD[15:8], except of the last byte that will be the OSPIC_BRK_WRD[7:0].</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_BRK_WRD</name>
	<description>This is the value of a special command (read burst break sequence) that is applied by the controller to the external memory device, in order to force the memory device to abandon the continuous read mode.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_BURSTCMDA_REG</name>
	<description>The way of reading in Auto mode (command register A)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_DMY_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Dummy bytes phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_EXT_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Extra Byte phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_ADR_TX_MD</name>
	<description>It describes the mode of the SPI bus during the address phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_INST_TX_MD</name>
	<description>It describes the mode of the SPI bus during the instruction phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_EXT_BYTE</name>
	<description>The value of an extra byte which will be transferred after address (only if OSPIC_EXT_BYTE_EN= 1). Usually this is the Mode Bits in Dual/Quad/Octal SPI I/O instructions.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_INST_WB</name>
	<description>Instruction Value for Wrapping Burst. This value is the selected instruction when OSPIC_WRAP_MD is equal to 1 and the access is a wrapping burst of length and size described by the bit fields OSPIC_WRAP_LEN and OSPIC_WRAP_SIZE respectively.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_INST</name>
	<description>Instruction Value for Incremental Burst or Single read access. This value is the selected instruction at the cases of incremental burst or single read access. Also this value is used when a wrapping burst is not supported (OSPIC_WRAP_MD)</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_BURSTCMDB_REG</name>
	<description>The way of reading in Auto mode (command register B)</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CS_HIGH_MIN</name>
	<description>Between the transmissions of two different instructions to the flash memory, the SPI bus stays in idle state (OSPI_CS high) for at least this number of OSPI_SCK clock cycles. See the OSPIC_ERS_CS_HI register for some exceptions.</description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_WRAP_SIZE</name>
	<description>It describes the selected data size of a wrapping burst (OSPIC_WRAP_MD).
0x0: byte access (8-bits)
0x1: half word access (16 bits)
0x2: word access (32-bits)
0x3: Reserved</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_WRAP_LEN</name>
	<description>It describes the selected length of a wrapping burst (OSPIC_WRAP_MD).
0x0: 4 beat wrapping burst
0x1: 8 beat wrapping burst
0x2: 16 beat wrapping burst
0x3: Reserved</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_WRAP_MD</name>
	<description>Wrap mode
0: The OSPIC_INST is the selected instruction at any access.
1: The OSPIC_INST_WB is the selected instruction at any wrapping burst access of length and size described by the registers OSPIC_WRAP_LEN and OSPIC_WRAP_SIZE respectively. In all other cases the OSPIC_INST is the selected instruction. Use this feature only when the serial FLASH memory supports a special instruction for wrapping burst access.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_INST_MD</name>
	<description>Instruction mode
0: Transmit instruction at any burst access.
1: Transmit instruction only in the first access after the selection of Auto Mode.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_DMY_EN</name>
	<description>Dummy bytes enable
0: Don't send the dummy bytes
1: Send the dummy bytes. The number of the dummy bytes is defined by the OSPIC_DMY_NUM.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_DMY_NUM</name>
	<description>Number of dummy bytes (minus 1). Can be set 1 up to 32 dummy bytes (values 0 up to 31). The dummy bytes are appied only when OSPIC_DMY_EN=1.</description>
	<bitRange>[8:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_EXT_HF_DS</name>
	<description>Extra half disable output
0: if OSPIC_EXT_BYTE_EN=1, is transmitted the complete OSPIC_EXT_BYTE
1: if OSPIC_EXT_BYTE_EN=1, the output is disabled (hi-z) during the transmission of bits [3:0] of OSPIC_EXT_BYTE.
This setting has no meaning if the extra byte is transferred in Octal mode. In this case keep this bit to zero value.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_EXT_BYTE_EN</name>
	<description>Extra byte enable
0: Don't send the OSPIC_EXT_BYTE
1: Send the OSPIC_EXT_BYTE</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_DAT_RX_MD</name>
	<description>It describes the mode of the SPI bus during the data phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CHCKERASE_REG</name>
	<description>Check erase progress in Auto mode</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CHCKERASE</name>
	<description>Writing any value to this register during erasing, forces the controller to read the flash memory status register. Depending on the value of the Busy bit, it updates the OSPIC_ERASE_EN.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTRLBUS_REG</name>
	<description>SPI Bus control register for the Manual mode</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_DIS_CS</name>
	<description>Write 1 to disable the chip select (active low) when the controller is in Manual mode.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>OSPIC_EN_CS</name>
	<description>Write 1 to enable the chip select (active low) when the controller is in Manual mode. </description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>OSPIC_SET_OCTAL</name>
	<description>Write 1 to set the bus mode in Octal mode when the controller is in Manual mode.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>OSPIC_SET_QUAD</name>
	<description>Write 1 to set the bus mode in Quad mode when the controller is in Manual mode.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>OSPIC_SET_DUAL</name>
	<description>Write 1 to set the bus mode in Dual mode when the controller is in Manual mode.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>OSPIC_SET_SINGLE</name>
	<description>Write 1 to set the bus mode in Single SPI mode when the controller is in Manual mode.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTRLMODE_REG</name>
	<description>Mode Control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_IO_UH_DAT</name>
	<description>The value of OSPI_IO4-7 pads if OSPI_IO_UH_OEN is 1</description>
	<bitRange>[31:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_IO_UH_OEN</name>
	<description>Forces the output enable for the upper half of the OSPI bus (OSPI_IO4-7). Set this bit to 1 only in SPI, Dual or Quad SPI mode to control the upper half of the OSPI bus. When the Octal SPI is enabled in the flash device, set this bit to zero.
0: The OSPI_IO4-7 pad direction is decided by the controller.
1: The OSPI_IO4-7 pad are outputs. The output values are defined by the corresponding OSPIC_IO_UH_DAT bits.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_INC_LIM_EN</name>
	<description>This bit has meaning only for the read in auto mode and only when the read access in the AHB bus is an incremental bust of unspecified length.
0: The length of the burst is considered as unspecified. The access in the flash device will be implemented as is defined by the OSPIC BUF_LIM_EN bit.
1: The length of the burst is considered as equal to 8-bytes. The access in the flash device will be implemented by the controller as one or more different bursts, until to be served the access in the AHB bus. Each burst in the flash device will have maximum length of 8 bytes.
The setting OSPIC_INC_LIM_EN=1 is useful if we know that the masters that make use of the incremental burst of unspecified length, require no more than 8 bytes.</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RD_ERR_EN</name>
	<description>Controls the generation of AHB bus error response when a read is performed in the address space where the flash device is mapped and the Auto mode is not enabled.
0: The controller ignores the access. There is no error response due to the read access.
1: The controller responds with an AHB error response.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_MAN_DIRCHG_MD</name>
	<description>Selection of the direction change method in manual mode.
0 : the bus direction goes to input after each access
1 : the bus direction goes to input only after a dummy access</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_DMY_MD</name>
	<description>Defines the clock cycle where the bus will turn in Hi-z during the transmission of dummy bytes. This is applicable in both Manual and Auto mode.
0 : the bus will become Hi-Z on the last clock
1 : the bus will become Hi-Z on the last two clocks</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_CMD_X2_EN</name>
	<description>Defines the number of bytes that consist the instruction code in the command sequences that produced by the OSPIC during Auto mode.
0 : The instruction code is one byte only.
1 : The instruction code is two bytes. The second byte of the instruction code is the inverse of the first byte.

The command sequence that is produced by the OSPIC_BURSTBRK_REG is not affected by this setting.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_USE_32BA</name>
	<description>Controls the length of the address that the external memory device uses.
0: The external memory device uses 24 bits address.
1: The external memory device uses 32 bits address.
The controller uses this bit in order to decide the number of the address bytes that has to transfer to the external device during Auto mode.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_BUF_LIM_EN</name>
	<description>This bit has meaning only for the read in auto mode. Defines the behavior of the controller when the internal buffer is full and there are more data to be retrieved for the current burst.
0: The access in the flash device is not terminated when the internal buffer has no empty space. In this case the OSPI_SCK clock is blocked until to free space in the internal buffer.
1: The access in the flash device is terminated when the internal buffer has no empty space. A new access in the flash device will be initiated when will be requested addresses that are not present in the internal buffer.
In both cases the access in the flash device is terminated when there is no any read request.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_PCLK_MD</name>
	<description>Read pipe clock delay relative to the falling edge of OSPI_SCK.
Refer to OSPI Timing for timing parameters and recommended values: 0 to 7</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RPIPE_EN</name>
	<description>Controls the use of the data read pipe.
0: The read pipe is disabled; the sampling clock is defined according to the OSPIC_RXD_NEG setting.
1: The read pipe is enabled. The delay of the sampling clock is defined according to the OSPICI_PCLK_MD setting. (Recommended)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RXD_NEG</name>
	<description>Defines the clock edge that is used for the capturing of the received data, when the read pipe is not active (OSPIC_RPIPE_EN = 0).

0: Sampling of the received data with the positive edge of the OSPI_SCK
1: Sampling of the received data with the negative edge of the OSPI_SCK

The internal OSPI_SCK clock that is used by the controller for the capturing of the received data has a skew in respect of the OSPI_SCK that is received by the external memory device. In order to be improved the timing requirements of the read path, the controller supports a read pipe register with programmable clock delay. See also the OSPIC_RPIPE_EN register.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_HRDY_MD</name>
	<description>This configuration bit is useful when the frequency of the OSPI clock is much lower than the clock of the AMBA bus, in order to not locks the AMBA bus for a long time.

0: Adds wait states via hready signal when an access is performed on the OSPIC_CTRLBUS_REG, OSPIC_WRITEDATA, OSPIC_READDATA and OSPIC_DUMMYDATA registers. It is not needed to check the OSPIC_BUSY of the OSPIC_STATUS_REG.
1: The controller don't adds wait states via the hready signal, when is performed access on the OSPIC_CTRLBUS_REG, OSPIC_WRITEDATA, OSPIC_READDATA and OSPIC_DUMMYDATA registers. The OSPIC_BUSY bit of the OSPIC_STATUS_REG must be checked in order to be detected the completion of the requested access.

It is applicable only when the controller is in Manual mode. In the case of the Auto mode, the controller always adds wait states via the hready signal.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_IO3_DAT</name>
	<description>The value of OSPI_IO3 pad if OSPI_IO3_OEN is 1</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_IO2_DAT</name>
	<description>The value of OSPI_IO2 pad if OSPI_IO2_OEN is 1</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_IO3_OEN</name>
	<description>Forces the output enable of the OSPI_IO3. Set this bit to 1 only in SPI or Dual SPI mode to control the /HOLD signal. When the Quad or Octal SPI is enabled in the flash device, set this bit to zero.
0: The OSPI_IO3 pad direction is decided by the controller.
1: The OSPI_IO3 pad is output. The output value is defined by the OSPIC_IO3_DAT.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_IO2_OEN</name>
	<description>Forces the output enable of the OSPI_IO2. Set this bit to 1 only in SPI or Dual SPI mode to control the /WP signal. When the Quad or Octal SPI is enabled in the flash device, set this bit to zero.
0: The OSPI_IO2 pad direction is decided by the controller.
1: The OSPI_IO2 pad is output. The output value is defined by the OSPIC_IO2_DAT.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_CLK_MD</name>
	<description>Mode of the generated OSPI_SCK clock
0: Use Mode 0 for the OSPI_CLK. The OSPI_SCK is low when OSPI_CS is high.
1: Use Mode 3 for the OSPI_CLK. The OSPI_SCK is high when OSPI_CS is high.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_AUTO_MD</name>
	<description>Mode of operation
0: The Manual Mode is selected.
1: The Auto Mode is selected.
During an erasing the OSPIC_AUTO_MD goes in read only mode (see OSPIC_ERASE_EN)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_CTRL_REG</name>
	<description>Control register for the decryption engine of the OSPIC</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>OSPIC_CTR_EN</name>
	<description>Controls the AES-CTR decryption feature of the OSPIC, which enables the decryption (on-the-fly) of the data that are retrieved from the flash memory device.
0: The AES-CTR decryption is disabled.
1: The controller will decrypt the content of the flash memory device that is placed in the address space that is defined by the OSPIC_CTR_SADDR_REG and OSPIC_CTR_EADDR_REG registers. The data that are placed outside the previous space are not decrypted by the OSPIC. The decryption is performed by using the AES-CTR algorithm. The AES key is defined by the OSPIC_CTR_KEY_x_y_REG registers and the nonce value by the OSPIC_CTR_NONCE_x_y_REG registers.
This configuration bit has meaning only while the controller is in Auto mode. The on-the-fly decryption is not provided in Manual mode.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_EADDR_REG</name>
	<description>End address of the encrypted content in the OSPI flash</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000003ff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_EADDR</name>
	<description>Defines the bits [31:10] of the end address in the flash memory, where an encrypted image is placed. The bits [9:0] are considered always as 0x3ff. This has meaning only when the decryption is active. See also the register OSPIC_CTR_CTRL_REG[OSPIC_CTR_EN].</description>
	<bitRange>[31:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_0_3_REG</name>
	<description>Key bytes 0 to 3 for the AES-CTR algorithm</description>
	<addressOffset>0x00000114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_0_3</name>
	<description>Defines the key that is used by the AES-CTR algorithm, when the on-the-fly decryption is enabled ( OSPIC_CTR_CTRL_REG[OSPIC_CTR_EN] = 1 ). The size of the decryption key is 256bits or 32 bytes :

K0 K1 K2 K3...K30 K31.

The mapping of the bytes to the corresponding OSPIC_CTR_KEY_X_Y_REG registers is the following :

{K0, K1, K2, K3} = OSPIC_CTR_KEY_0_3_REG[31:0]
{K4, K5, K6, K7} = OSPIC_CTR_KEY_4_7_REG[31:0]
{K8, K9, K10, K11} = OSPIC_CTR_KEY_8_11_REG[31:0]
{K12, K13, K14, K15} = OSPIC_CTR_KEY_12_15_REG[31:0]
{K16, K17, K18, K19} = OSPIC_CTR_KEY_16_19_REG[31:0]
{K20, K21, K22, K23} = OSPIC_CTR_KEY_20_23_REG[31:0]
{K24, K25, K26, K27} = OSPIC_CTR_KEY_24_27_REG[31:0]
{K28, K29, K30, K31} = OSPIC_CTR_KEY_28_31_REG[31:0]

All these registers make sense only when OSPIC_CTR_CTRL_REG[OSPIC_CTR_EN] = 1. Do not perform access to an encrypted address range while the updating process of the decryption key is in progress.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_12_15_REG</name>
	<description>Key bytes 12 to 15 for the AES-CTR algorithm</description>
	<addressOffset>0x00000120</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_12_15</name>
	<description>See the description in the OSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_16_19_REG</name>
	<description>Key bytes 16 to 19 for the AES-CTR algorithm</description>
	<addressOffset>0x00000124</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_16_19</name>
	<description>See the description in the OSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_20_23_REG</name>
	<description>Key bytes 20 to 23 for the AES-CTR algorithm</description>
	<addressOffset>0x00000128</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_20_23</name>
	<description>See the description in the OSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_24_27_REG</name>
	<description>Key bytes 24 to 27 for the AES-CTR algorithm</description>
	<addressOffset>0x0000012c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_24_27</name>
	<description>See the description in the OSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_28_31_REG</name>
	<description>Key bytes 28 to 31 for the AES-CTR algorithm</description>
	<addressOffset>0x00000130</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_28_31</name>
	<description>See the description in the OSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_4_7_REG</name>
	<description>Key bytes 4 to 7 for the AES-CTR algorithm</description>
	<addressOffset>0x00000118</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_4_7</name>
	<description>See the description in the OSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_KEY_8_11_REG</name>
	<description>Key bytes 8 to 11 for the AES-CTR algorithm</description>
	<addressOffset>0x0000011c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_KEY_8_11</name>
	<description>See the description in the OSPIC_CTR_KEY_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_NONCE_0_3_REG</name>
	<description>Nonce bytes 0 to 3 for the AES-CTR algorithm</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_NONCE_0_3</name>
	<description>Defines the 8 bytes of the nonce value (N0 - N7) that is used by the AES-CTR algorithm in order to be constructed the counter block (CTRB). The total size of the counter block is 128 bits or 16 bytes :

CTRB0 CTRB1 CTRB2 CTRB3...CTRB14 CTRB15.

The first 8 bytes (CTRB0 - CTRB7) of the counter block consisted by the nonce value.
The next 8 bytes of the counter block (CTRB8-CTRB15), are produced automatically by the hardware based on the address offset inside the encrypted image, from where are retrieved the requested data.
The mapping of the nonce bytes to the corresponding OSPIC_NONCE_X_Y_REG registers is the following :

{CTRB0, CTRB1, CTRB2, CTRB3} = {N0, N1, N2, N3} = OSPIC_NONCE_0_3_REG[31:0]
{CTRB4, CTRB5, CTRB6, CTRB7} = {N4, N5, N6, N7} = OSPIC_NONCE_4_7_REG[31:0]

All these registers make sense only when OSPIC_CTR_CTRL_REG[OSPIC_CTR_EN] = 1. Do not perform access to an encrypted address range while the updating process of the nonce value is in progress.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_NONCE_4_7_REG</name>
	<description>Nonce bytes 4 to 7 for the AES-CTR algorithm</description>
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_NONCE_4_7</name>
	<description>See the description in the OSPIC_NONCE_0_3.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_CTR_SADDR_REG</name>
	<description>Start address of the encrypted content in the OSPI flash</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_CTR_SADDR</name>
	<description>Defines the bits [31:10] of the start address in the flash memory, where an encrypted image is placed. The bits [9:0] are considered always as zero. This has meaning only when the decryption is active. See also the register OSPIC_CTR_CTRL_REG[OSPIC_CTR_EN].</description>
	<bitRange>[31:10]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_DUMMYDATA_REG</name>
	<description>Send dummy clocks to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_DUMMYDATA</name>
	<description>Writing to this register generates a number of clock pulses to the SPI bus. During the last clock of this activity in the SPI bus, the OSPI_IOx data pads are in hi-z state (see also the OSPIC_DMY_MD). The data size of the access to this register can be 32-bits / 16-bits/ 8-bits. The number of generated pulses is equal to: (size of AHB bus access) / (size of SPI bus). The size of SPI bus is equal to 1, 2, 4 or 8 for Single, Dual, Quad or Octal SPI mode respectively.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_ERASECMDA_REG</name>
	<description>The way of erasing in Auto mode (command register A)</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_RES_INST</name>
	<description>The code value of the erase resume instruction</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_SUS_INST</name>
	<description>The code value of the erase suspend instruction.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_WEN_INST</name>
	<description>The code value of the write enable instruction.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_ERS_INST</name>
	<description>The code value of the erase instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_ERASECMDB_REG</name>
	<description>The way of erasing in Auto mode (command register B)</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_RESSUS_DLY</name>
	<description>Defines a timer that counts the minimum allowed delay between an erase suspend command and the previous erase resume command (or the initial erase command).
0: Don't wait. The controller starts immediately to suspend the erase procedure.
1..255: The controller waits for at least this number of 222kHz clock cycles before the suspension of erasing. Time starts counting after the end of the previous erase resume command (or the initial erase command)</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_ERSRES_HLD</name>
	<description>The controller must stay without flash memory reading requests for this number of AMBA hclk clock cycles, before to perform the command of erase or erase resume
15 - 0</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_ERS_CS_HI</name>
	<description>After the execution of instructions: write enable, erase, erase suspend and erase resume, the OSPI_CS remains high for at least this number of OSPI bus clock cycles.</description>
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_EAD_TX_MD</name>
	<description>The mode of the OSPI Bus during the address phase of the erase instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RES_TX_MD</name>
	<description>The mode of the OSPI Bus during the transmission of the resume instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_SUS_TX_MD</name>
	<description>The mode of the OSPI Bus during the transmission of the suspend instruction.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_WEN_TX_MD</name>
	<description>The mode of the OSPI Bus during the transmission of the write enable instruction.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_ERS_TX_MD</name>
	<description>The mode of the OSPI Bus during the instruction phase of the erase instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_ERASECMDC_REG</name>
	<description>The way of erasing in Auto mode (command register C)</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>OSPIC_SUSSTS_DLY</name>
	<description>Defines a timer that counts the minimum allowed delay between an erase suspend command and the next read status command.
0: Don't wait. The controller starts immediately to read the status of the flash device.
1..63: The controller waits for at least this number of 222kHz clock cycles before to read the status of the flash device. Time starts counting when the erase resume command is applied.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_ERASECTRL_REG</name>
	<description>OSPI Erase control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_ERS_RES_DIS</name>
	<description>This configuration bit has meaning when an erase has been suspended. Normally the erase will be resumed when the flash will stay idle (without read accesses) for a predefined number of clock cycles (see OSPIC_ERASECMDB_REG [OSPIC_ERSRES_HLD]). By setting this bit the execution of the erase resume process can be postponed.
0: A suspended erase will be resumed based on the setting in the OSPIC_ERSRES_HLD.
1: The erase will not be resumed even after the expiration of the OSPIC_ERSRES_HLD. The erase can be resumed again only when the OSPIC_ERS_RES_DIS=0. </description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_ERS_STATE</name>
	<description>It shows the progress of sector/block erasing (read only).
0x0: No Erase.
0x1: Pending erase request
0x2: Erase procedure is running
0x3: Suspended Erase procedure
0x4: Finishing the Erase procedure
0x5..0x7: Reserved</description>
	<bitRange>[27:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OSPIC_ERASE_EN</name>
	<description>During Manual mode (OSPIC_AUTO_MD = 0). This bit is in read only mode.
During Auto mode (OSPIC_AUTO_MD = 1). To request the erasing of the block/sector (OSPIC_ERS_ADDR, 12'b0) write 1 to this bit. This bit is cleared automatically with the end of the erasing. Until the end of erasing the OSPIC_ERASE_EN remains in read only mode. During the same time interval the controller remains in Auto Mode (OSPIC_AUTO_MD goes in read only mode).</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_ERS_ADDR</name>
	<description>Defines the address of the block/sector that is requested to be erased.
If OSPIC_USE_32BA = 0 (24 bits addressing), bits OSPIC_ERASECTRL_REG[23-12] determine the block/ sector address bits [23-12]. The OSPIC_ERASECTRL_REG[11-4] are ignored by the controller.
If OSPIC_USE_32BA = 1 (32 bits addressing) bits OSPIC_ERASECTRL_REG[23-4] determine the block / sectors address bits [31:12]</description>
	<bitRange>[23:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_GP_REG</name>
	<description>OSPI General Purpose control register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>OSPIC_PADS_SLEW</name>
	<description>QSPI pads slew rate control. Indicative values under certain conditions:
0: Rise=1.7 V/ns, Fall=1.9 V/ns (weak)
1: Rise=2.0 V/ns, Fall=2.3 V/ns
2: Rise=2.3 V/ns, Fall=2.6 V/ns
3: Rise=2.4 V/ns, Fall=2.7 V/ns (strong)
Conditions: FLASH pin capacitance 6 pF, Vcc=1.8V, T=25C and Idrive=16mA.</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_PADS_DRV</name>
	<description>QSPI pads drive current
0: 4 mA
1: 8 mA
2: 12 mA
3: 16 mA</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_READDATA_REG</name>
	<description>Read data from SPI Bus for the Manual mode</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_READDATA</name>
	<description>A read access at this register generates a data transfer from the external memory device to the OSPIC controller. The data is transferred using the selected mode of the SPI bus (Single SPI, Dual SPI, Quad SPI or Octal SPI). The data size of the access to this register can be 32-bits / 16-bits / 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_RECVDATA_REG</name>
	<description>Received data for the Manual mode</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_RECVDATA</name>
	<description>This register contains the received data when the OSPIC_READDATA_REG register is used in Manual mode, in order to be retrieved data from the external memory device and OSPIC_HRDY_MD=1 &amp;&amp; OSPIC_BUSY=0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_STATUSCMD_REG</name>
	<description>The way of reading the status of external device in Auto mode</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_RSTAT_DMY_ZERO</name>
	<description>Defines the value of that is transferred on the OSPI bus during the phase of the dummy bytes.
0: The controller keeps the data in the bus unchanged, until to change the bus direction in input mode.
1: Forces the dummy bytes to get the zero value (only for the cycles that are not in input mode). Only the IO pins that are related with the transfer mode of the dummy bytes (OSPIC_RSTAT_DMY_TX_MD) will get the zero value. </description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RSTAT_DMY_TX_MD</name>
	<description>It describes the mode of the OSPI bus during the dummy bytes phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RSTAT_DMY_NUM</name>
	<description>Number of dummy bytes (minus 1). Can be set 1 up to 16 dummy bytes (values 0 up to 15). The dummy bytes are applied only when OSPIC_RSTAT_DMY_EN=1.</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RSTAT_DMY_EN</name>
	<description>Enables the transmission of dummy bytes, immediately after the instruction code of the read status command.
0: Don't send the dummy bytes
1: Send the dummy bytes. The number of the dummy bytes is defined by the OSPIC_RSTAT_DMY_NUM.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_STSDLY_SEL</name>
	<description>Defines the timer which is used to count the delay that it has to wait before to read the FLASH Status Register, after an erase or an erase resume command.
0: The delay is controlled by the OSPIC_RESSTS_DLY which counts on the OSPI_CLK clock.
1: The delay is controlled by the OSPIC_RESSUS_DLY which counts on the 222 kHz clock.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RESSTS_DLY</name>
	<description>Defines a timer that counts the minimum required delay between the reading of the status register and of the previous erase or erase resume instruction.
0: Don't wait. The controller starts to reading the Flash memory status register immediately.
1..63: The controller waits for at least this number of OSPI_CLK cycles and afterwards it starts to reading the Flash memory status register. The timer starts to count after the end of the previous erase or erase resume command.

The actual timer that will be used by the controller before the reading of the Flash memory status register is defined by the OSPIC_STSDLY_SEL.</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_BUSY_VAL</name>
	<description>Defines the value of the Busy bit which means that the flash is busy.
0: The flash is busy when the Busy bit is equal to 0.
1: The flash is busy when the Busy bit is equal to 1.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_BUSY_POS</name>
	<description>It describes who from the bits of status represents the Busy bit (7 - 0).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RSTAT_RX_MD</name>
	<description>The mode of the OSPI Bus during the receive status phase of the read status instruction
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RSTAT_TX_MD</name>
	<description>The mode of the OSPI Bus during the instruction phase of the read status instruction.
0x0: Single
0x1: Dual
0x2: Quad
0x3: Octal</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OSPIC_RSTAT_INST</name>
	<description>The code value of the read status instruction.
It is transmitted during the instruction phase of the read status instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OQSPIF_STATUS_REG</name>
	<description>The status register of the OSPI controller</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_BUSY</name>
	<description>The status of the SPI Bus.

0: The SPI Bus is idle
1: The SPI Bus is active. Read data, write data or dummy data activity is in progress.

Has meaning only in Manual mode and only when OSPIC_HRDY_MD = 1.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>OQSPIF_WRITEDATA_REG</name>
	<description>Write data to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OSPIC_WRITEDATA</name>
	<description>Writing to this register is generating a data transfer from the controller to the external memory device. The data written in this register, is then transferred to the memory using the selected mode of the SPI bus (Single SPI, Dual SPI, Quad SPI or Octal SPI). The data size of the access to this register can be 32-bits / 16-bits/ 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral></peripherals>
</device>
