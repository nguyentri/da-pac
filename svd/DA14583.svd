<?xml version="1.0" encoding="ascii"?>
<!-- File naming: Dialog_DA14581a0m2_x_nl1_4.svd -->
<!--
  Copyright (C) 2018 Dialog Semiconductor.
  This computer program includes Confidential, Proprietary Information  
  of Dialog Semiconductor. All Rights Reserved.

  Purpose: System Viewer Description (SVD) Example (Schema Version 1.1)
           This is a description of a none-existent and incomplete device
		   for demonstration purposes only.

  Generated by cmsis-svd (version 0.2), d.d. September 03, 2018 - 16:09:04
 -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <vendor>Dialog</vendor>                   				    <!-- device vendor name -->
  <vendorID>ARM</vendorID>                                        <!-- device vendor short name -->
  <name>DA14583</name>                                          <!-- name of part-->
  <series>DA1458x</series>                                         <!-- device series the device belongs to -->
  <description>Ultra-Low power Bleutooth 4.2 SoC with Flash memory codec from Dialog Semiconductor</description>
  <version>1.2</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  
  <licenseText><!-- this license text will appear in header file. \n forces line breaks -->
    Copyright (C) 2018 Dialog Semiconductor.\n
    This computer program includes Confidential, Proprietary Information  \n
    of Dialog Semiconductor. All Rights Reserved. \n
    \n
    Dialog GmbH (DLG) is supplying this software for use with Cortex-M\n
    processor based microcontroller, but can be equally used for other\n
    suitable  processor architectures. This file can be freely distributed.\n
    Modifications to this file shall be clearly marked.\n
    \n
    THIS SOFTWARE IS PROVIDED  AS IS .  NO WARRANTIES, WHETHER EXPRESS, IMPLIED\n
    OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.\n
    ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR\n
    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.

</licenseText>
  <cpu><!-- details about the cpu embedded in the device (SVD version 1.2,  see https://www.keil.com/pack/doc/CMSIS/SVD/html/group__cpu_section__gr.html) -->
    <name>CM0</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
		
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
																																									 and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->
	
  <peripherals>
	<peripheral>  
  <name>NVIC</name>
  <version>1.0</version>
  <description>Cortex M0 NVIC registers</description>
  <groupName>NVIC_GROUP</groupName>
  <baseAddress>0xE000E100</baseAddress>
  <size>0</size>
  <addressBlock>
		<offset>0</offset>
		<size>0x321</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>ISER</name>
	  <description>Interrupt set-enable register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
  		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_RF_DIAG_IRQn</name>
		  <description>BLE baseband or Radio diagnostic (Interrupt set-enable bit))</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt set-enable bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO0_IRQn</name>
          <description>GPIO0 interrupt through debounce (Interrupt set-enable bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO1_IRQn</name>
		  <description>GPIO1 interrupt through debounce (Interrupt set-enable bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO2_IRQn</name>
		  <description>GPIO2 interrupt through debounce (Interrupt set-enable bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO3_IRQn</name>
		  <description>IGPIO3 interrupt through debounce (Interrupt set-enable bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO4_IRQn</name>
		  <description>GPIO4 interrupt through debounce (Interrupt set-enable bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM_IRQn</name>
		  <description>Software timer Interrupt (set-enable bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_QUADEC_IRQn</name>
		  <description>Combined Wake up Capture Timer, GPIO and QuadDecoder interrupt (set-enable bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM Interrupt (set-enable bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>Sample rate converter input Interrupt (set-enable bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>Sample rate converter output Interrupt (set-enable bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA Interrupt (set-enable bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
      </fields>
	</register>
	<register>
	  <name>ICER</name>
	  <description>Interrupt clear-enable register</description>
	  <addressOffset>0x00000080</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
  		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_RF_DIAG_IRQn</name>
		  <description>BLE baseband or Radio diagnostic (Interrupt clear-enable bit))</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt clear-enable bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO0_IRQn</name>
          <description>GPIO0 interrupt through debounce (Interrupt clear-enable bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO1_IRQn</name>
		  <description>GPIO1 interrupt through debounce (Interrupt clear-enable bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO2_IRQn</name>
		  <description>GPIO2 interrupt through debounce (Interrupt clear-enable bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO3_IRQn</name>
		  <description>IGPIO3 interrupt through debounce (Interrupt clear-enable bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO4_IRQn</name>
		  <description>GPIO4 interrupt through debounce (Interrupt clear-enable bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM_IRQn</name>
		  <description>Software timer Interrupt (clear-enable bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_QUADEC_IRQn</name>
		  <description>Combined Wake up Capture Timer, GPIO and QuadDecoder interrupt (clear-enable bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM Interrupt (clear-enable bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>Sample rate converter input Interrupt (clear-enable bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>Sample rate converter output Interrupt (clear-enable bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA Interrupt (clear-enable bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ISPR</name>
	  <description>Interrupt set-pending register</description>
	  <addressOffset>0x00000100</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
  		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_RF_DIAG_IRQn</name>
		  <description>BLE baseband or Radio diagnostic (Interrupt set-pending bit))</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt set-pending bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO0_IRQn</name>
          <description>GPIO0 interrupt through debounce (Interrupt set-pending bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO1_IRQn</name>
		  <description>GPIO1 interrupt through debounce (Interrupt set-pending bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO2_IRQn</name>
		  <description>GPIO2 interrupt through debounce (Interrupt set-pending bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO3_IRQn</name>
		  <description>IGPIO3 interrupt through debounce (Interrupt set-pending bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO4_IRQn</name>
		  <description>GPIO4 interrupt through debounce (Interrupt set-pending bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM_IRQn</name>
		  <description>Software timer Interrupt (set-pending bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_QUADEC_IRQn</name>
		  <description>Combined Wake up Capture Timer, GPIO and QuadDecoder interrupt (set-pending bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM Interrupt (set-pending bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>Sample rate converter input Interrupt (set-pending bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>Sample rate converter output Interrupt (set-pending bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA Interrupt (set-pending bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICPR</name>
	  <description>Interrupt clear-pending register</description>
	  <addressOffset>0x00000180</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
  		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[5:5]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[6:6]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[7:7]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_RF_DIAG_IRQn</name>
		  <description>BLE baseband or Radio diagnostic (Interrupt clear-pending bit))</description>
		  <bitRange>[8:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt clear-pending bit)</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO0_IRQn</name>
          <description>GPIO0 interrupt through debounce (Interrupt clear-pending bit)</description>
		  <bitRange>[10:10]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO1_IRQn</name>
		  <description>GPIO1 interrupt through debounce (Interrupt clear-pending bit)</description>
		  <bitRange>[11:11]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO2_IRQn</name>
		  <description>GPIO2 interrupt through debounce (Interrupt clear-pending bit)</description>
		  <bitRange>[12:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO3_IRQn</name>
		  <description>IGPIO3 interrupt through debounce (Interrupt clear-pending bit)</description>
		  <bitRange>[13:13]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO4_IRQn</name>
		  <description>GPIO4 interrupt through debounce (Interrupt clear-pending bit)</description>
		  <bitRange>[14:14]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM_IRQn</name>
		  <description>Software timer Interrupt (clear-pending bit)</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>WKUP_QUADEC_IRQn</name>
		  <description>Combined Wake up Capture Timer, GPIO and QuadDecoder interrupt (clear-pending bit)</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM Interrupt (clear-pending bit)</description>
		  <bitRange>[17:17]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>Sample rate converter input Interrupt (clear-pending bit)</description>
		  <bitRange>[18:18]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>Sample rate converter output Interrupt (clear-pending bit)</description>
		  <bitRange>[19:19]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA Interrupt (clear-pending bit)</description>
		  <bitRange>[20:20]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR0</name>
	  <description>Interrupt priority register 0</description>
	  <addressOffset>0x00000300</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn_prio</name>
		  <description>BLE_WAKEUP_LP_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>BLE_GEN_IRQn_prio</name>
		  <description>BLE_GEN_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART_IRQn_prio</name>
		  <description>UART_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>UART2_IRQn_prio</name>
		  <description>UART2_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR1</name>
	  <description>Interrupt priority register 1</description>
	  <addressOffset>0x00000304</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>I2C_IRQn_prio</name>
		  <description>I2C_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI_IRQn_prio</name>
		  <description>SPI_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn_prio</name>
		  <description>ADC_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn_prio</name>
		  <description>KEYBRD_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR2</name>
	  <description>Interrupt priority register 2</description>
	  <addressOffset>0x00000308</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_RF_DIAG_IRQn_prio</name>
		  <description>BLE_RF_DIAG_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>RF_CAL_IRQn_prio</name>
		  <description>RF_CAL_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO0_IRQn_prio</name>
		  <description>GPIO0_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO1_IRQn_prio</name>
		  <description>GPIO1_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR3</name>
	  <description>Interrupt priority register 3</description>
	  <addressOffset>0x0000030C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SPI_IRQn_prio</name>
		  <description>SPI_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SPI2_IRQn_prio</name>
		  <description>SPI2_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ADC_IRQn_prio</name>
		  <description>ADC_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>KEYBRD_IRQn_prio</name>
		  <description>KEYBRD_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR4</name>
	  <description>Interrupt priority register 4</description>
	  <addressOffset>0x00000310</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>GPIO2_IRQn_prio</name>
		  <description>GPIO2_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO3_IRQn_prio</name>
		  <description>GPIO3_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>GPIO4_IRQn_prio</name>
		  <description>GPIO4_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SWTIM_IRQn_prio</name>
		  <description>SWTIM_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR5</name>
	  <description>Interrupt priority register 5</description>
	  <addressOffset>0x00000314</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>WKUP_QUADEC_IRQn_prio</name>
		  <description>WKUP_QUADEC_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PCM_IRQn_prio</name>
		  <description>PCM_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[15:8]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_IN_IRQn_prio</name>
		  <description>SRC_IN_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SRC_OUT_IRQn_prio</name>
		  <description>SRC_OUT_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR6</name>
	  <description>Interrupt priority register 6</description>
	  <addressOffset>0x00000318</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>DMA_IRQn_prio</name>
		  <description>DMA_IRQn[7:0] bits (Interrupt priority)</description>
		  <bitRange>[7:0]</bitRange>
		  <access>read-write</access>
		</field>
      </fields>
	</register>
    </registers>
</peripheral>
<peripheral>
  <name>SCB</name>
  <version>1.0</version>
  <description>Cortex M0 SCB registers</description>
  <groupName>SCB_GROUP</groupName>
  <baseAddress>0xE000ED00</baseAddress>
  <size>0</size>
  <addressBlock>
		<offset>0</offset>
		<size>0x29</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>CPUID</name>
	  <description>CPUID base register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x410CC200</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>REVISION</name>
		  <description>REVISION[3:0] bits (Revision number)</description>
		  <bitRange>[3:0]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>PARTNO</name>
		  <description>PARTNO[11:0] bits (Part number of the processor core)</description>
		  <bitRange>[15:4]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>CONSTANT</name>
		  <description>CONSTANT[3:0] bits (Reads as 0xF)</description>
		  <bitRange>[19:16]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>VARIANT</name>
		  <description>VARIANT[3:0] bits (Variant number)</description>
		  <bitRange>[23:20]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>IMPLEMENTER</name>
		  <description>IMPLEMENTER[7:0] bits (Implementer code)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-only</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICSR</name>
	  <description>Interrupt control and state register</description>
	  <addressOffset>0x00000004</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>VECTACTIVE</name>
		  <description>VECTACTIVE[5:0] bits (Active vector)</description>
		  <bitRange>[5:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>VECTPENDING</name>
		  <description>VECTPENDING[5:0] bits (Pending vector)</description>
		  <bitRange>[17:12]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>ISRPENDING</name>
		  <description>Interrupt pending flag, excluding NMI and Faults</description>
		  <bitRange>[22:22]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSTCLR</name>
		  <description>SysTick exception clear-pending bit</description>
		  <bitRange>[25:25]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSTSET</name>
		  <description>SysTick exception set-pending bit</description>
		  <bitRange>[26:26]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSVCLR</name>
		  <description>PendSV clear-pending bit</description>
		  <bitRange>[27:27]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PENDSVSET</name>
		  <description>PendSV set-pending bit</description>
		  <bitRange>[28:28]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>NMIPENDSET</name>
		  <description>NMI set-pending bit</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>AIRCR</name>
	  <description>Application interrupt and reset control register</description>
	  <addressOffset>0x0000000C</addressOffset>
	  <size>32</size>
	  <access>read-only</access>
	  <resetValue>0xFA050000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>VECTRESET</name>
		  <description>Reserved for Debug use</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>VECTCLRACTIVE</name>
		  <description>Reserved for Debug use</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>SYSRESETREQ</name>
		  <description>System reset request</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>ENDIANESS</name>
		  <description>Data endianness bit</description>
		  <bitRange>[15:15]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>VECTKEY</name>
		  <description>VECTKEY[15:0] bits (Register key)</description>
		  <bitRange>[31:16]</bitRange>
		  <access>read-only</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SCR</name>
	  <description>System control register</description>
	  <addressOffset>0x00000010</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SLEEPONEXIT</name>
		  <description>Configures sleep-on-exit when returning from Handler mode to Thread mode</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SLEEPDEEP</name>
		  <description>Controls whether the processor uses sleep or deep sleep</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>SEVEONPEND</name>
		  <description>Send event on pending bit</description>
		  <bitRange>[4:4]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>CCR</name>
	  <description>Configuration and control register</description>
	  <addressOffset>0x00000014</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000204</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>UNALIGN_TRP</name>
		  <description>Enables unaligned access traps</description>
		  <bitRange>[3:3]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>STKALIGN</name>
		  <description>Configures stack alignment on exception entry</description>
		  <bitRange>[9:9]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SHPR2</name>
	  <description>System handler priority register 2</description>
	  <addressOffset>0x0000001C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>PRI_11</name>
		  <description>PRI_11[7:0] bits (Priority of system handler 11, SVCall)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SHPR3</name>
	  <description>System handler priority register 3</description>
	  <addressOffset>0x00000020</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>PRI_14</name>
		  <description>PRI_14[7:0] bits (Priority of system handler 14, PendSV)</description>
		  <bitRange>[23:16]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>PRI_15</name>
		  <description>PRI_15[7:0] bits (Priority of system handler 15, SysTick exception)</description>
		  <bitRange>[31:24]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
  <name>SysTick</name>
  <version>1.0</version>
  <description>Cortex M0 SysTick registers</description>
  <groupName>SYSTICK</groupName>
  <baseAddress>0xE000E010</baseAddress>
  <size>0</size>
  <addressBlock>
		<offset>0</offset>
		<size>0x11</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>CTRL</name>
	  <description>SysTick Control and Status register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000004</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>ENABLE</name>
		  <description>SysTick Counter enable</description>
		  <bitRange>[0:0]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>TICKINT</name>
		  <description>SysTick exception request enable</description>
		  <bitRange>[1:1]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>CLKSOURCE</name>
		  <description>Clock source selection</description>
		  <bitRange>[2:2]</bitRange>
		  <access>read-write</access>
		</field>
		<field>
		  <name>COUNTFLAG</name>
		  <description>Timer counted to 0 since last time this was read</description>
		  <bitRange>[16:16]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>LOAD</name>
	  <description>SysTick Reload value register</description>
	  <addressOffset>0x00000004</addressOffset>
	  <size>32</size>
	  <access>read-write<!--==(HARDCODED)==--></access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>RELOAD</name>
		  <description>RELOAD[23:0] bits (Reload value)</description>
		  <bitRange>[23:0]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>VAL</name>
	  <description>SysTick Current value register</description>
	  <addressOffset>0x00000008</addressOffset>
	  <size>32</size>
	  <access>read-write<!--==(HARDCODED)==--></access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>CURRENT</name>
		  <description>CURRENT[23:0] bits (Current counter value)</description>
		  <bitRange>[23:0]</bitRange>
		  <access>read-write</access>
		</field>
	  </fields>
	</register>
	<register>
	  <name>CALIB</name>
	  <description>SysTick Calibration value register</description>
	  <addressOffset>0x0000000C</addressOffset>
	  <size>32</size>
	  <access>read-only<!--==(HARDCODED)==--></access>
	  <resetValue>0x00002328</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>TENMS</name>
		  <description>TENMS[23:0] bits (Calibration value)</description>
		  <bitRange>[23:0]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>SKEW</name>
		  <description>Indicates whether the TENMS value is exact</description>
		  <bitRange>[30:30]</bitRange>
		  <access>read-only</access>
		</field>
		<field>
		  <name>NOREF</name>
		  <description>Indicates that a separate reference clock is provided</description>
		  <bitRange>[31:31]</bitRange>
		  <access>read-only</access>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
	<name>adc580_bif_nl01</name>
	<version>1.0</version>
	<description>adc580_bif_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GP_ADC_CLEAR_INT_REG</name>
	<description>General Purpose ADC Clear Interrupt Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL2_REG</name>
	<description>General Purpose ADC Second Control Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_I20U</name>
	<description>Adds 20uA constant load current at the ADC LDO to minimize ripple on the reference voltage of the ADC. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_IDYN</name>
	<description>Enables dynamic load current at the ADC LDO to minimize ripple on the reference voltage of the ADC. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_ATTN3X</name>
	<description>0 = Input voltages up to 1.2V allowed.
1 = Input voltages up to 3.6V allowed by enabling 3x attenuator. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_DELAY_EN</name>
	<description>Enables delay function for several signals. This is not auto-cleared. Toggle this bit before every sampling to enable succesive conversions.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_LDO_ZERO</name>
	<description>Forces LDO-output to 0V. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_LDO_EN</name>
	<description>Turns on LDO. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CHOP</name>
	<description>Takes two samples with opposite GP_ADC_SIGN to cancel the internal offset voltage of the ADC; Highly recommended for DC-measurements.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MUTE</name>
	<description>Takes sample at mid-scale (to dertermine the internal offset and/or noise of the ADC with regards to VDD_REF which is also sampled by the ADC). </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SE</name>
	<description>0 = Differential mode
1 = Single ended mode</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SIGN</name>
	<description>0 = Default
1 = Conversion with opposite sign at input and output to cancel out the internal offset of the ADC and low-frequency </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL</name>
	<description>ADC input selection which must be set before the GP_ADC_START bit is enabled.
If GP_ADC_SE = 1 (single ended mode):
0000 = P0[0]
0001 = P0[1]
0010 = P0[2]
0011 = P0[3]
0100 = AVS
0101 = VDD_REF
0110 = VDD_RTT (=VDD_REF)
0111 = VBAT3V
1000 = VDCDC
1001 = VBAT1V
All other combinations are reserved.
If GP_ADC_SE = 0 (differential mode):
0000 = P0[0] vs P0[1]
All other combinations are P0[2] vs P0[3].</description>
	<bitRange>[9:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MINT</name>
	<description>0 = Disable (mask) GP_ADC_INT.
1 = Enable GP_ADC_INT to ICU.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_INT</name>
	<description>1 = AD conversion ready and has generated an interrupt. Must be cleared by writing any value to GP_ADC_CLEAR_INT_REG.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GP_ADC_CLK_SEL</name>
	<description>0 = Internal high-speed ADC clock used.
1 = Digital clock used. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_TEST</name>
	<description>Reserved, keep 0.</description>
	<bitRange>[2:2]</bitRange>
	
	</field><field>
	<name>GP_ADC_START</name>
	<description>0 = ADC conversion ready.
1 = If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN</name>
	<description>0 = ADC is disabled and in reset.
1 = ADC is enabled and sampling of input is started. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_DELAY2_REG</name>
	<description>General Purpose ADC Second Delay Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00008880</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DEL_ADC_START</name>
	<description>Defines the delay for the GP_ADC_START bit. Reset value is 17 &#181;s which is the recommended value to wait before starting the GP ADC. This is the third and last step of bringing up the GP ADC</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEL_ADC_EN</name>
	<description>Defines the delay for the GP_ADC_EN bit. Reset value is 16 &#181;s which is the recommended value to wait after enabling the LDO. This is the second step in bringing up the GP ADC.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_DELAY_REG</name>
	<description>General Purpose ADC Delay Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DEL_LDO_EN</name>
	<description>Defines the delay before the LDO enable (GP_ADC_LDO_EN). Reset value is 0 &#181;s since the LDO enable should be the first thing to be programmed in the sequence of bringing the GP ADC up.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFN_REG</name>
	<description>General Purpose ADC Negative Offset Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFN</name>
	<description>Offset adjust of 'negative' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=1&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFP_REG</name>
	<description>General Purpose ADC Positive Offset Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFP</name>
	<description>Offset adjust of 'positive' array of ADC-network (effective if &quot;GP_ADC_SE=0&quot;, or &quot;GP_ADC_SE=1 AND GP_ADC_SIGN=0&quot;)</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_VAL</name>
	<description>Returns the 10 bits linear value of the last AD conversion.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>anamisc580_nl01</name>
	<version>1.0</version>
	<description>anamisc580_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CLK_REF_CNT_REG</name>
	<description>Count value for oscillator calibration</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REF_CNT_VAL</name>
	<description>Indicates the calibration time, with a decrement counter to 1. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_SEL_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REF_CAL_START</name>
	<description>Writing a '1' starts a calibration. This bit is cleared when calibration is finished, and CLK_REF_VAL is ready. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CLK_SEL</name>
	<description>Select clock input for calibration:
0x0 : RC32K oscillator
0x1 : RC16M oscillator
0x2 : XTAL32K oscillator
0x3 : RCX oscillator</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_H_REG</name>
	<description>XTAL16M reference cycles, upper 16 bits</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the upper 16 bits of XTAL16 clock cycles during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_L_REG</name>
	<description>XTAL16M reference cycles, lower 16 bits</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the lower 16 bits of XTAL16 clock cycles during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ble580_gr01</name>
	<version>1.0</version>
	<description>ble580_gr01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>520</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>BLE_ACTSCANSTAT_REG</name>
	<description>Active scan register</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BACKOFF</name>
	<description>Active scan mode back-off counter initialization value. </description>
	<bitRange>[24:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UPPERLIMIT</name>
	<description>Active scan mode upper limit counter value. </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ADVCHMAP_REG</name>
	<description>Advertising Channel Map</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ADVCHMAP</name>
	<description>Advertising Channel Map, defined as per the advertising connection settings. Contains advertising channels index 37 to 39. If ADVCHMAP[i] equals:
0: Do not use data channel i+37.
1: Use data channel i+37. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ADVTIM_REG</name>
	<description>Advertising Packet Interval</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ADVINT</name>
	<description>Advertising Packet Interval defines the time interval in between two ADV_xxx packet sent.
Value is in usec.
Value to program depends of the used Advertising Packet type and the device filtering policy. Please refer to Table 3-10 for details about ADVINT programming range. </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESCNTL_REG</name>
	<description>Start AES register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AES_START</name>
	<description>Writing a 1 starts AES-128 ciphering process.
This bit is reset once the process is finished (i.e BLE_CRYPT_IRQ interrupt occurs, even masked) </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY127_96_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY127_96</name>
	<description>AES encryption 128-bit key. Bit 127 down to 96 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY31_0_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY31_0</name>
	<description>AES encryption 128-bit key. Bit 31 down to 0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY63_32_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY63_32</name>
	<description>AES encryption 128-bit key. Bit 63 down to 32 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESKEY95_64_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESKEY95_64</name>
	<description>AES encryption 128-bit key. Bit 95 down to 64 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_AESPTR_REG</name>
	<description>Pointer to the block to encrypt/decrypt</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>AESPTR</name>
	<description>Pointer to the memory zone where the block to encrypt/decrypt is stored. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BASETIMECNTCORR_REG</name>
	<description>Base Time Counter</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BASETIMECNTCORR</name>
	<description>Base Time Counter correction value. </description>
	<bitRange>[26:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BASETIMECNT_REG</name>
	<description>Base time reference counter</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BASETIMECNT</name>
	<description>Value of the 625us base time reference counter. Updated each time BLE_SAMPLECLK_REG[SAMP] is written. Used by the SW in order to synchronize with the HW. </description>
	<bitRange>[26:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_BDADDRL_REG</name>
	<description>BLE device address LSB register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BDADDRL</name>
	<description>Bluetooth Low Energy Device Address. LSB part. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_BDADDRU_REG</name>
	<description>BLE device address MSB register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PRIV_NPUB</name>
	<description>Bluetooth Low Energy Device Address privacy indicator
0: Public Bluetooth Device Address
1: Private Bluetooth Device Address </description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BDADDRU</name>
	<description>Bluetooth Low Energy Device Address. MSB part. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_CNTL2_REG</name>
	<description>BLE Control Register 2</description>
	<addressOffset>0x00000200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>BLE_RSSI_SEL</name>
	<description>0: Select Peak-hold RSSI value (default).
1: Select current Average RSSI value. </description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPLPSTAT</name>
	<description>The status of the BLE_WAKEUP_LP_IRQ. The Interrupt Service Routine of BLE_WAKEUP_LP_IRQ should return only when the WAKEUPLPSTAT is cleared.
Note that BLE_WAKEUP_LP_IRQ is automatically acknowledged after the power up of the Radio Subsystem, plus one Low Power Clock period. </description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SW_RPL_SPI</name>
	<description>Keep to 0. </description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BB_ONLY</name>
	<description>Keep to 0. </description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_ONLY</name>
	<description>Keep to 0. </description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_CLK_SEL</name>
	<description>BLE Clock Select.
Specifies the BLE master clock absolute frequency in MHz.
Typical values are 16 and 8.
Value depends on the selected XTAL frequency and the value of CLK_RADIO_REG[BLE_DIV] bitfield. For example, if XTAL oscillates at 16MHz and CLK_RADIO_REG[BLE_DIV] = 1 (divide by 2), then BLE master clock frequency is 8MHz and BLE_CLK_SEL should be set to value 8.
The selected BLE master clock frequency (affected by BLE_DIV and BLE_CLK_SEL) must be modified and set only during the initialization time, i.e. before setting BLE_RWBTLECNTL_REG[RWBLE_EN] to 1.
Refer also to BLE_RWBTLECONF_REG[CLK_SEL].</description>
	<bitRange>[14:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_PWRDN_ALLOW</name>
	<description>This active high signal indicates when it is allowed for the BLE core (embedded in the Radio sub-System power domain) to be powered down.
After the assertion of the BLE_DEEPSLCNTL_REG[DEEP_SLEEP_ON] a hardware sequence based on the Low Power clock will cause the assertion of RADIO_PWRDN_ALLOW. The RADIO_PWRDN_ALLOW will be cleared to &quot;0&quot; when the BLE core exits from the sleep state, i.e. when the BLE_SLP_IRQ will be asserted.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MON_LP_CLK</name>
	<description>The SW can only write a &quot;0&quot; to this bit.
Whenever a positive edge of the low power clock used by the BLE Timers is detected, then the HW will automatically set this bit to &quot;1&quot;. This functionality will not work if BLE Timer is in reset state (refer to CLK_RADIO_REG[BLE_LP_RESET]).
This bit can be used for SW synchronization, to debug the low power clock, etc.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_CLK_STAT</name>
	<description>0: BLE uses low power clock
1: BLE uses master clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAGPORT_REVERSE</name>
	<description>BLE/RADIO Diagnostic Port Reverse order.
When this bit is &quot;1&quot;, the mapping of the diagnostic bus DIAGPORT[7:0] (controlled by DIAGPORT_SEL) to GPIOs (controlled by Pxy_MODE_REG[PID]) is reversed. The mapping is:
If &quot;0&quot; then DIAGPORT[7] is mapped to P0[7], etc.
DIAGPORT[4] is mapped to P0[4],
DIAGPORT[3] is mapped to P0[3] and P1[3], etc. and
DIAGPORT[0] is mapped to P0[0] and P1[0].

If &quot;1&quot; then DIAGPORT[7] is mapped to P0[0] and P1[0], etc.
DIAGPORT[4] is mapped to P0[3] and P1[3],
DIAGPORT[3] is mapped to P0[4], etc. and
DIAGPORT[0] is mapped to P0[7].</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGPORT_SEL</name>
	<description>BLE/RADIO Diagnostic Port Selection.
Controls the multiplexing of the internal diagnostic signals towards the 8-bit diagnostic bus DIAGPORT[7:0]. The DIAGPORT[7:0] bit order may or may not be reversed by using the DIAGPORT_REVERSE bitfield and then it will be directed to the GPIOs P0[7:0] and P1[3:0]. (Note that the P1[3:0] diagnostic signals are the same with P0[3:0] signals.)
The DIAGPORT[7:0] value, depending on the DIAGPORT_SEL value, is:
00: {BLE_DIAG2[7:5], BLE_DIAG1[4:3], BLE_DIAG0[2:0]}
01: {BLE_DIAG2[7:5], BLE_DIAG1[4:3], BLE_DIAG0[2]
, wakeup_lp_irq, deep_sleep_stat_32k}
10: RADIO_DIAG0[7:0]
11: RADIO_DIAG1[7:0]</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMACCERRMSK</name>
	<description>Exchange Memory Access Error Mask:
When cleared to &quot;0&quot; the EM_ACC_ERR will not cause an BLE_ERROR_IRQ interrupt.
When set to &quot;1&quot; an BLE_ERROR_IRQ will be generated as long as EM_ACC_ERR is &quot;1&quot;. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EMACCERRACK</name>
	<description>Exchange Memory Access Error Acknowledge.
When the SW writes a &quot;1&quot; to this bit then the EMACCERRSTAT bit will be cleared.
When the SW writes &quot;0&quot; it will have no affect.
The read value is always &quot;0&quot;. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EMACCERRSTAT</name>
	<description>Exchange Memory Access Error Status:
The bit is read-only and can be cleared only by writing a &quot;1&quot; at EMACCERRACK bitfield.
This bit will be set to &quot;1&quot; by the hardware when the controller will access an EM page that is not mapped according to the EM_MAPPING value.
When this bit is &quot;1&quot; then the BLE_ERROR_IRQ will be asserted as long as EMACCERRMSK is &quot;1&quot;. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_CURRENTRXDESCPTR_REG</name>
	<description>Rx Descriptor Pointer for the Receive Buffer Chained List</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CURRENTRXDESCPTR</name>
	<description>Rx Descriptor Pointer that determines the starting point of the Receive Buffer Chained List. </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEBUGADDMAX_REG</name>
	<description>Upper limit for the memory zone</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ADDMAX</name>
	<description>Upper limit for the memory zone. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEBUGADDMIN_REG</name>
	<description>Lower limit for the memory zone</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ADDMIN</name>
	<description>Lower limit for the memory zone. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLCNTL_REG</name>
	<description>Deep-Sleep control register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>EXTWKUPDSB</name>
	<description>External Wake-Up disable
0: BLE Core can be woken by external wake-up
1: BLE Core cannot be woken up by external wake-up </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_STAT</name>
	<description>Indicator of current Deep Sleep clock mux status:
0: BLE Core is not yet in Deep Sleep Mode
1: BLE Core is in Deep Sleep Mode (only Low Power Clock is running) </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SOFT_WAKEUP_REQ</name>
	<description>Wake Up Request from BLE Software. Applies when system is in Deep Sleep Mode. It wakes up the BLE Core when written with a 1. Always read as 0. No action happens if it is written with 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_CORR_EN</name>
	<description>625us base time reference integer and fractional part correction. Applies when system has been woken-up from Deep Sleep Mode. It enables Fine Counter and Base Time counter when written with a 1. Always read as 0. No action happens if it is written with 0. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_ON</name>
	<description>0: BLE Core in normal active mode
1: Request BLE Core to switch in deep sleep mode.
This bit is reset on DEEP_SLEEP_STAT falling edge. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEEP_SLEEP_IRQ_EN</name>
	<description>Always set to &quot;3&quot; when DEEP_SLEEP_ON is set to &quot;1&quot;.
It controls the generation of BLE_WAKEUP_LP_IRQ. </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLSTAT_REG</name>
	<description>Duration of the last deep sleep phase register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEEPSLDUR</name>
	<description>Actual duration of the last deep sleep phase measured in Low Power Clock cycles. DEEPSLDUR is set to zero at the beginning of the deep sleep phase, and is incremented at each Low Power Clock cycle until the end of the deep sleep phase. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_DEEPSLWKUP_REG</name>
	<description>Time (measured in Low Power clock cycles) in Deep Sleep Mode before waking-up the device</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DEEPSLTIME</name>
	<description>Determines the time in Low Power Clock cycles to spend in Deep Sleep Mode before waking-up the device. This ensures a maximum of 37 hours and 16mn sleep mode capabilities at 32kHz. This ensures a maximum of 36 hours and 16mn sleep mode capabilities at 32.768kHz. If DEEPSLTIME is set to zero, the Deep Sleep Time duration is considered as infinite, and only wake up requests can restore active behaviour
BLE Software must ensure DEEPSLTIME value to be greater than 2 in order to cope with control resynchronization requirements </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGCNTL_REG</name>
	<description>Diagnostics Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG3_EN</name>
	<description>0: Disable diagnostic port 3 output. All outputs are set to 0.
1: Enable diagnostic port 3 output. </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG3</name>
	<description>Only relevant when DIAG3_EN = 1.
Selection of the outputs that must be driven to the diagnostic port 3. </description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2_EN</name>
	<description>0: Disable diagnostic port 2 output. All outputs are set to 0.
1: Enable diagnostic port 2 output. </description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG2</name>
	<description>Only relevant when DIAG2_EN = 1.
Selection of the outputs that must be driven to the diagnostic port 2. </description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1_EN</name>
	<description>0: Disable diagnostic port 1 output. All outputs are set to 0.
1: Enable diagnostic port 1 output. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG1</name>
	<description>Only relevant when DIAG1_EN = 1.
Selection of the outputs that must be driven to the diagnostic port 1.</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0.
1: Enable diagnostic port 0 output. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAG0</name>
	<description>Only relevant when DIAG0_EN = 1.
Selection of the outputs that must be driven to the diagnostic port 0. </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_DIAGSTAT_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAG3STAT</name>
	<description>Directly connected to ble_dbg3[7:0] output. Debug use only. </description>
	<bitRange>[31:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG2STAT</name>
	<description>Directly connected to ble_dbg2[7:0] output. Debug use only. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG1STAT</name>
	<description>Directly connected to ble_dbg1[7:0] output. Debug use only. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAG0STAT</name>
	<description>Directly connected to ble_dbg0[7:0] output. Debug use only. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_ENBPRESET_REG</name>
	<description>Time in low power oscillator cycles register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TWEXT</name>
	<description>Minimum and recommended value is &quot;TWIRQ_RESET + 1&quot;.
In the case of wake-up due to an external wake-up request, TWEXT specifies the time delay in low power oscillator cycles to deassert BLE_WAKEUP_LP_IRQ.
Refer also to GP_CONTROL_REG[BLE_WAKEUP_REQ].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<bitRange>[31:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TWIRQ_SET</name>
	<description>Minimum value is &quot;TWIRQ_RESET + 1&quot;.
Time in low power oscillator cycles to set BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<bitRange>[20:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TWIRQ_RESET</name>
	<description>Recommended value is 1.
Time in low power oscillator cycles to reset BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...32 ms] for 32kHz; [0...31.25 ms] for 32.768kHz. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_ERRORTYPESTAT_REG</name>
	<description>Error Type Status registers</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>CSFORMAT_ERROR</name>
	<description>Indicates whether CS-FORMAT has been programmed with an invalid value: this is a major software programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSTXPTR_ERROR</name>
	<description>Indicates whether CS-TXPTR is null, this is a major software programming failure.
0: No error
1: Error occurred </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RADIO_EMACC_ERROR</name>
	<description>Radio Controller Exchange Memory access error, happens when Exchange Memory access are not served in time and data are corrupted.
0: No error
1: Error occurred </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LLCHMAP_ERROR</name>
	<description>Link Layer Channel Map error, happens when actual number of CS-LLCHMAP bit set to one is different from CS-NBCHGOOD at the beginning of Frequency Hopping process
0: No error
1: Error occurred </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IFS_UNDERRUN</name>
	<description>Inter Frame Space Under run, occurs if IFS time is not enough to update and read Control Structure/Descriptors, and/or White List parsing is not finished and/or Decryption time is too long to be finished on time
0: No error
1: Error occurred </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXCRYPT_ERROR</name>
	<description>Real Time Decryption Error, happens when decryption is not finished before IFS time
0: No error
1: Error occurred </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WHITELIST_ERROR</name>
	<description>White List Timeout Error, occurs if White List parsing is not finished on time
0: No error
1: Error occurred </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>APFM_ERROR</name>
	<description>Anticipated Pre-Fetch Mechanism error, happens when 3 consecutive Exchange Table entry have been programmed,
0: no error
1: Error occured </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXDESC_ERROR</name>
	<description>Tx Descriptor Error, happens when fetched Tx Descriptor has TXDONE bit not set
0: No error
1: Error occurred </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PKTCNTL_EMACC_ERROR</name>
	<description>Packet Controller Exchange Memory access error, happens when Exchange Memory access are not served in time and Tx/Rx data are corrupted
0: No error
1: Error occurred </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TXCRYPT_ERROR</name>
	<description>Real Time Encryption Error, happens when encryption is not finished before Tx Payload has to be sent
0: No error
1: Error occurred </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_FINECNTCORR_REG</name>
	<description>Phase correction value register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FINECNTCORR</name>
	<description>Phase correction value for the 625usec reference counter (i.e Fine Counter) in us. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_FINETIMECNT_REG</name>
	<description>Fine time reference counter</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FINECNT</name>
	<description>Value of the current usec fine time reference counter. Updated each usec. Used by the SW in order to synchronize with the HW, and obtain a more precise sleep duration </description>
	<bitRange>[9:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_FINETIMTGT_REG</name>
	<description>Fine Timer Target value</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>FINETARGET</name>
	<description>Fine Timer Target value on which a BLE_FINETGTIM_IRQ must be generated. This timer has a precision of 625us: interrupt is generated only when FINETARGET = BASETIMECNT </description>
	<bitRange>[26:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_GROSSTIMTGT_REG</name>
	<description>Gross Timer Target value</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>GROSSTARGET</name>
	<description>Gross Timer Target value on which a BLE_GROSSTGTIM_IRQ must be generated. This timer has a precision of 10ms: interrupt is generated only when GROSSTARGET[15:0] = BASETIMECNT[19:4] and BASETIMECNT[3:0] = 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_INTACK_REG</name>
	<description>Interrupt acknowledge register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RADIOCNTLINTACK</name>
	<description>Radio Controller interrupt acknowledgement bit
Software writing 1 acknowledges the Error interrupt. This bit resets RADIOCNTLINTSTAT and RADIOCNTLINTRAWSTAT flags. </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>FINETGTIMINTACK</name>
	<description>Fine Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Error interrupt. This bit resets FINETGTIMINTSTAT and FINETGTIMINTRAWSTAT flags. </description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>GROSSTGTIMINTACK</name>
	<description>Gross Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Error interrupt. This bit resets GROSSTGTIMINTSTAT and GROSSTGTIMINTRAWSTAT flags. </description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>ERRORINTACK</name>
	<description>Error interrupt acknowledgement bit
Software writing 1 acknowledges the Error interrupt. This bit resets ERRORINTSTAT and ERRORINTRAWSTAT flags. </description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CRYPTINTACK</name>
	<description>Encryption/Decryption interrupt acknowledgement bit Software writing 1 acknowledges the Encryption / Decryption interrupt. This bit resets CRYPTINTSTAT and CRYPTINTRAWSTAT flags. </description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>EVENTINTACK</name>
	<description>End of Event interrupt acknowledgment bit
Software writing 1 acknowledges the End of Advertising / Scanning / Connection interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SLPINTACK</name>
	<description>End of Deep Sleep interrupt acknowledgment bit
Software writing 1 acknowledges the End of Sleep Mode interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RXINTACK</name>
	<description>Packet Reception interrupt acknowledgment bit
Software writing 1 acknowledges the Rx interrupt. This bit resets RXINTSTAT and RXINTRAWSTAT flags. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CSCNTINTACK</name>
	<description>625us base time reference interrupt acknowledgment bit
Software writing 1 acknowledges the CLKN interrupt. This bit resets CLKINTSTAT and CLKINTRAWSTAT flags. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>BLE_INTCNTL_REG</name>
	<description>Interrupt controller register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00ff801f</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>INTCSCNTL</name>
	<description>Selection of the CS counter that generates an interrupt. For example, if INTCNTL[3] is set, an interrupt is sent each time CS counter equals 3. </description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CSCNTDEVMSK</name>
	<description>CSCNT interrupt mask during event. This bit allows to enable CSCNT interrupt generation during events (i.e advertising, scanning, initiating, and connection)
0: CSCNT Interrupt not generated during events.
1: CSCNT Interrupt generated during events. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIOCNTLINTMSK</name>
	<description>Radio Controller interrupt mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINETGTIMINTMSK</name>
	<description>Fine Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GROSSTGTIMINTMSK</name>
	<description>Gross Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERRORINTMSK</name>
	<description>Error Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTINTMSK</name>
	<description>Encryption / Decryption Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EVENTINTMSK</name>
	<description>End of event Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SLPINTMSK</name>
	<description>Sleep Mode Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXINTMSK</name>
	<description>Rx Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CSCNTINTMSK</name>
	<description>625usec Base Time Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_INTRAWSTAT_REG</name>
	<description>Interrupt raw status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RADIOCNTLINTRAWSTAT</name>
	<description>Radio Controller interrupt raw status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FINETGTIMINTRAWSTAT</name>
	<description>Fine Target Timer Error interrupt raw status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GROSSTGTIMINTRAWSTAT</name>
	<description>Gross Target Timer interrupt raw status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ERRORINTRAWSTAT</name>
	<description>Error interrupt raw status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTINTRAWSTAT</name>
	<description>Encryption/Decryption interrupt raw status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTINTRAWSTAT</name>
	<description>End of Event interrupt raw status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLPINTRAWSTAT</name>
	<description>Sleep interrupt raw status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXINTRAWSTAT</name>
	<description>Packet Reception interrupt raw status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSCNTINTRAWSTAT</name>
	<description>625us base time reference interrupt raw status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_INTSTAT_REG</name>
	<description>Interrupt status register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RADIOCNTLINTSTAT</name>
	<description>Radio Controller interrupt status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>FINETGTIMINTSTAT</name>
	<description>Masked Fine Target Timer Error interrupt status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GROSSTGTIMINTSTAT</name>
	<description>Masked Gross Target Timer interrupt status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ERRORINTSTAT</name>
	<description>Masked Error interrupt status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTINTSTAT</name>
	<description>Masked Encryption/Decryption interrupt status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>EVENTINTSTAT</name>
	<description>Masked End of Event interrupt status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLPINTSTAT</name>
	<description>Masked Sleep interrupt status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RXINTSTAT</name>
	<description>Masked Packet Reception interrupt status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CSCNTINTSTAT</name>
	<description>Masked 625us base time reference interrupt status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RADIOCNTL0_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00002102</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DPCORR_EN</name>
	<description>Enable the use of delayed DC compensated data path in Radio Correlator block
1: Enable
0: Disable
Must be set to &quot;0&quot;. </description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RADIOCNTL1_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>XRFSEL</name>
	<description>Extended radio selection field, Must be set to '00011'. </description>
	<bitRange>[20:16]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RADIOPWRUPDN_REG</name>
	<description>RX/TX power up/down phase register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d203d2</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RTRIP_DELAY</name>
	<description>Defines round trip delay value. This value correspond to the addition of data latency in Tx and data latency in Rx. Value is in us. </description>
	<bitRange>[30:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXPWRUP</name>
	<description>This register holds the length in us of the Rx power up phase for the current radio device. Default value is 210 us (reset value). Operating range depends of the selected radio. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPWRDN</name>
	<description>This register extends the length in us of the Tx power down phase for the current radio device. Default value is 3us (reset value). Operating range depends of the selected radio. </description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPWRUP</name>
	<description>This register holds the length in us of the Tx power up phase for the current radio device. Default value is 210 us (reset value). Operating range depends of the selected radio. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RFTESTCNTL_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>INFINITERX</name>
	<description>Applicable for all frame format
0: Normal mode of operation
1: Infinite Rx window </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INFINITETX</name>
	<description>Applicable for all frame format
0: Normal mode of operation.
1: Infinite Tx packet / Normal start of a packet but endless payload
In case of infinite Tx payload, and when PRBS source is not selected, then RFTESTCNTL-TXLENGTH field provides the length of the pattern to repeat in the payload. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXLENGTHSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Normal mode of operation: TXDESC-TXADVLEN controls the Tx packet payload size
1: Uses RFTESTCNTL-TXLENGTH packet length (can support up to 512 bytes transmit) </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRBSTYPE</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload are PRBS9 type
1: Tx Packet Payload are PRBS15 type
PRBS9 is defined as p(x)=1+x5+x9. The LFSR used for the PRBS9 generator must be initialized with 0x1FF value.
PRBS15 is defined as p(x)=1+x+x2+x12+x13+x14. The LFSR used for the PRBS15 generator must be initialized with 0x7FFF value. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXPLDSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload source is the Control Structure
1: Tx Packet Payload are PRBS generator </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXLENGTH</name>
	<description>Applicable only in Tx/Rx RF Test mode
Tx packet length in number of byte </description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RF_DIAGIRQ_REG</name>
	<description>BLE/RF Diagnostic IRQ Control Register</description>
	<addressOffset>0x00000204</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>DIAGIRQ_STAT_3</name>
	<description>Same as DIAGIRQ_STAT_0.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAGIRQ_EDGE_3</name>
	<description>Same as DIAGIRQ_EDGE_0.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_BSEL_3</name>
	<description>Same as DIAGIRQ_BSEL_0.</description>
	<bitRange>[29:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_WSEL_3</name>
	<description>Same as DIAGIRQ_WSEL_0.</description>
	<bitRange>[26:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_MASK_3</name>
	<description>Same as DIAGIRQ_MASK_0.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_STAT_2</name>
	<description>Same as DIAGIRQ_STAT_0.</description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAGIRQ_EDGE_2</name>
	<description>Same as DIAGIRQ_EDGE_0.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_BSEL_2</name>
	<description>Same as DIAGIRQ_BSEL_0.</description>
	<bitRange>[21:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_WSEL_2</name>
	<description>Same as DIAGIRQ_WSEL_0.</description>
	<bitRange>[18:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_MASK_2</name>
	<description>Same as DIAGIRQ_MASK_0.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_STAT_1</name>
	<description>Same as DIAGIRQ_STAT_0.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAGIRQ_EDGE_1</name>
	<description>Same as DIAGIRQ_EDGE_0.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_BSEL_1</name>
	<description>Same as DIAGIRQ_BSEL_0.</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_WSEL_1</name>
	<description>Same as DIAGIRQ_WSEL_0.</description>
	<bitRange>[10:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_MASK_1</name>
	<description>Same as DIAGIRQ_MASK_0.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_STAT_0</name>
	<description>Diagnostic IRQ Status 0
This bit is read only. It is automatically cleared to &quot;0&quot; on each read of the BLE_RF_DIAGIRQ_REG register. It is automatically asserted to &quot;1&quot; on each detection of the selected edge, of the selected bit, of the selected word.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DIAGIRQ_EDGE_0</name>
	<description>Diagnostic IRQ Edge 0
Selects the edge of the selected bit (refer to DIAGIRQ_BSEL_0) that will trigger the assertion of DIAGIRQ_STAT_0.
If '0' then the positive edge is selected, when &quot;1&quot; the negative edge is selected.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_BSEL_0</name>
	<description>Diagnostic IRQ Bit Select 0
Selects the bit of the 8-bit bus (as selected by the DIAGIRQ_WSEL_0) that will be used for the IRQ generation.</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_WSEL_0</name>
	<description>Diagnostic IRQ Word Select 0
Selects the 8-bit diagnostic bus that will be used for the IRQ generation.
00: Selects the BLE_DIAG0
01: Selects the BLE_DIAG1
10: Selects the RADIO_DIAG0
11: Selects the RADIO_DIAG1</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DIAGIRQ_MASK_0</name>
	<description>Diagnostic IRQ Mask 0
When set to &quot;1&quot; a BLE_RF_DIAG_IRQ will be generated on each rise of the DIAGIRQ_STAT_0 bit.
When cleared to &quot;0&quot; no IRQ will be generated.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RWBTLECNTL_REG</name>
	<description>BLE Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>MASTER_SOFT_RST</name>
	<description>Reset the complete system except registers and timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MASTER_TGSOFT_RST</name>
	<description>Reset the timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REG_SOFT_RST</name>
	<description>Reset the complete register block, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFTEST_ABORT</name>
	<description>Abort the current RF Testing defined as per CS-FORMAT when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.
Note that when RFTEST_ABORT is requested.
1) In case of infinite Tx, the Packet Controller FSM stops at the end of the current byte in process, and processes accordingly the packet CRC.
2) In case of Infinite Rx, the Packet Controller FSM either stops as the end of the current Packet reception (if Access address has been detected), or simply stop the processing switching off the RF. </description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADVERT_ABORT</name>
	<description>Abort the current Advertising event when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SCAN_ABORT</name>
	<description>Abort the current scan window when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MD_DSB</name>
	<description>0: Normal operation of MD bits management
1: Allow a single Tx/Rx exchange whatever the MD bits are </description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SN_DSB</name>
	<description>0: Normal operation of Sequence number
1: Sequence Number Management disabled:
value forced by SW from Tx Descriptor
value ignored in Rx, meaning that no SN error reported. </description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NESN_DSB</name>
	<description>0: Normal operation of Sequence number
1: Sequence Number Management disabled:
value forced by SW from Tx Descriptor
value ignored in Rx, meaning that no SN error reported. </description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPT_DSB</name>
	<description>0: Normal operation. Encryption / Decryption enabled.
1: Encryption / Decryption disabled.
Note that if CS-CRYPT_EN is set, then MIC is generated, and only data encryption is disabled, meaning data sent are plain data. </description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WHIT_DSB</name>
	<description>0: Normal operation. Whitening enabled.
1: Whitening disabled. </description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRC_DSB</name>
	<description>0: Normal operation. CRC removed from data stream.
1: CRC stripping disabled on Rx packets, CRC replaced by 0x000 in Tx </description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HOP_REMAP_DSB</name>
	<description>0: Normal operation. Frequency Hopping Remapping algorithm enabled.
1: Frequency Hopping Remapping algorithm disabled </description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TXWINOFFSEL</name>
	<description>Applicable only if device is in Initiator mode
0: Window Offset field in CONNECT_REQ comes from Tx Data Buffer
1: Window Offset field in CONNECT_REQ comes from Event Controller processing and is replaced in real time by Packet Controller </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXDESCPTRSEL</name>
	<description>0: Selects Rx Descriptor Pointer value from Control Structure
1: Selects Rx Descriptor Pointer value from CURRENTRXDESCPTR register </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ADVERRFILT_EN</name>
	<description>Advertising Channels Error Filtering Enable control
0: BLE Core reports all errors to BLE Software
1: BLE Core reports only correctly received packet, without error to BLE Software </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WLSYNC_EN</name>
	<description>0: WLAN synchronization pulse generation disabled
1: WLAN synchronization pulse generation enabled </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RWBLE_EN</name>
	<description>0: Disable BLE Core Exchange Table pre-fetch mechanism.
1: Enable BLE Core Exchange table pre-fetch mechanism. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RXWINSZDEF</name>
	<description>Default Rx Window size in us. Used when device
a) is master connected
b) performs its second receipt.
0 is not a valid value. Recommended value is 10. </description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYNCERR</name>
	<description>Indicates the maximum number of errors allowed to recognize the synchronization word. </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_RWBTLECONF_REG</name>
	<description>Configuration register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0e080017</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>ADD_WIDTH</name>
	<description>Value of the BLE_ADDRESS_WIDTH parameter converted into binary. </description>
	<bitRange>[29:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFIF</name>
	<description>Supported radio interfaces.
0001000: on-chip radio
others: reserved </description>
	<bitRange>[22:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_SEL</name>
	<description>Operating Frequency (in MHz).
This field is a copy of the BLE_CNTL2_REG[BLE_CLK_SEL] value. </description>
	<bitRange>[13:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMMODE</name>
	<description>0: BLE Core is used as a standalone BLE device
1: BLE Core is used in a Dual Mode device </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>INTMODE</name>
	<description>0: Interrupts are edge level generated, i.e pulse.
1: Interrupts are trigger level generated, i.e stays active at 1 till acknowledgement </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WLAN</name>
	<description>0: WLAN Coexistence mechanism not present
1: WLAN Coexistence mechanism present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USEDBG</name>
	<description>0: Diagnostic port not instantiated
1: Diagnostic port instantiated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USECRYPT</name>
	<description>0: Encryption block not present
1: Encryption block present </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSWIDTH</name>
	<description>Processor bus width:
0: 16 bits
1: 32 bits </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_RXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>RXMICVAL</name>
	<description>AES / CCM plain MIC value. Valid on BLE_CRYPT_IRQ interrupt (even masked) </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_SAMPLECLK_REG</name>
	<description>Samples the Base Time Counter</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SAMP</name>
	<description>Writing a 1 samples the Base Time Counter value in BASETIMECNT register. Resets at 0 when action is performed. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_SWPROFILING_REG</name>
	<description>Software Profiling register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>SWPROFVAL</name>
	<description>Software Profiling register: used by BLE Software for profiling purpose: this value is copied on Diagnostic port </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_TIMGENCNTL_REG</name>
	<description>Timing Generator Register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>PREFTECH_TIME</name>
	<description>Defines Exchange Table pre-fetch instant in us </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_TXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TXMICVAL</name>
	<description>AES / CCM plain MIC value. Valid on BLE_CRYPT_IRQ interrupt (even masked) </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_VERSION_REG</name>
	<description>Version register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>TYP</name>
	<description>BLE Core Type - 0x6 means BT4.0 (i.e correspond LL version assigned number) </description>
	<bitRange>[31:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>REL</name>
	<description>BLE Core version - Major release number.(Correspond to FS v1.11) </description>
	<bitRange>[23:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UPG</name>
	<description>BLE Core upgrade - Upgrade number. (Correspond to FS v1.11) </description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUILD</name>
	<description>BLE Core Build - Build number </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BLE_WLNBDEV_REG</name>
	<description>Devices in white list</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>NBPRIVDEV</name>
	<description>Number of private devices in the white list. </description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NBPUBDEV</name>
	<description>Number of public devices in the white list. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_WLPRIVADDPTR_REG</name>
	<description>Start address of private devices list</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WLPRIVADDPTR</name>
	<description>Start address pointer of the private devices white list. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BLE_WLPUBADDPTR_REG</name>
	<description>Start address of public devices list</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>WLPUBADDPTR</name>
	<description>Start address pointer of the public devices white list. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHIP_VERSION</name>
	<version>1.0</version>
	<description>CHIP_VERSION registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>5</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>CHIP_ID1_REG</name>
	<description>Chip identification register 1.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000035</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID1</name>
	<description>First character of device type &quot;580&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID2_REG</name>
	<description>Chip identification register 2.</description>
	<addressOffset>0x00000001</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000038</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID2</name>
	<description>Second character of device type &quot;580&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID3_REG</name>
	<description>Chip identification register 3.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID3</name>
	<description>Third character of device type &quot;580&quot; in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_REVISION_REG</name>
	<description>Chip revision register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>REVISION_ID</name>
	<description>Chip version, corresponds with type number in ASCII.
0x41 = 'A', 0x42 = 'B' </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_SWC_REG</name>
	<description>Software compatibility register.</description>
	<addressOffset>0x00000003</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_SWC</name>
	<description>SoftWare Compatibility code.
Integer (default = 0) which is incremented if a silicon change has impact on the CPU Firmware.
Can be used by software developers to write silicon revision dependent code. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>crg580_dcdc_nl01</name>
	<version>1.0</version>
	<description>crg580_dcdc_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000080</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>6</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DCDC_CTRL2_REG</name>
	<description>DCDC second control register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00008c20</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DCDC_VOLT_LEV</name>
	<description>Nominal output voltage of the DCDC-converter.
VDCDC = 1.2V + N*25mV </description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VBAT3V_LEV</name>
	<description>Nominal VBAT3V output voltage of the boost converter.
000 ... 011 = 1.8V + N*25mV
100 = 2.4V
101 = 2.5V
110 = 2.62V
111 = 2.76V
(Note: MSB is automatically on if the OTP LDO is enabled.) </description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_TON</name>
	<description>This defines the minimum on-time of the comparators. For buck-mode use 0x2, for boost-mode use 0x1</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_CUR_LIM</name>
	<description>Current limit in the switches of the DCDC-converter (approximate values):
N x 10mA </description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_AUTO_CAL</name>
	<description>Control of the automatic calibration of the DCDC-converter. For Buck-mode use 0x1, for Boost-mode use 0x6.
Automatic calibration is disabled by setting 0x0 </description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register>

<register>
	<name>DCDC_CTRL3_REG</name>
	<description>DCDC thirth control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000015</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
    <field>
	<name>DCDC_TIMEOUT</name>
	<description>timeout for the idle state to check voltage</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_IDLE_CLK</name>
	<description>Clock used as trigger for the idle state to check voltage.
(Note: when no 16 MHz oscillator is active, the 32 kHz oscillator will be used as trigger independent of the setting below:) 
00 = 16 MHz
01 = 4 MHz
10 = 1 MHz
11 = 250 kHz </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUCK_ENABLE</name>
	<description>Enables the buck converter when the device becomes active and VBAT1V is connected to GND. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field>
    </fields>
</register>

<register>
	<name>DCDC_CTRL_REG</name>
	<description>DCDC control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DCDC_TUNE</name>
	<description>Tune-bits to compensate for parasitic resistance in the current sense circuit of the DCDC-converter. </description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_DRIVE_OSW</name>
	<description>Drive level of the switch between SWITCH and VDCDC.
00 = 100 percent
01 = 66  percent
10 = 33  percent
11 = off </description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_DRIVE_PSW</name>
	<description>Drive level of the switch between SWITCH and VBAT3V.
00 = 100 percent
01 = 66  percent
10 = 33  percent
11 = off </description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_DRIVE_NSW</name>
	<description>Drive level of the switch between SWITCH and GROUND.
00 = 100 percent
01 = 66  percent
10 = 33  percent
11 = off </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_MODE</name>
	<description>Testmodes, keep 000. </description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_VBAT1V_LEV</name>
	<description>If VBAT1V is below this level, the boost converter will be disabled:
110 = 0.6V
101 = 0.8V
011 = 1.0V
111 = 0V (always OK) </description>
	<bitRange>[3:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>crg580_nl01</name>
	<version>1.0</version>
	<description>crg580_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>44</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>ANA_STATUS_REG</name>
	<description>Status bit of analog (power management) circuits</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000090</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BOOST_SELECTED</name>
	<description>Indicates that DCDC is in boost mode </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BANDGAP_OK</name>
	<description>Indicates that BANDGAP is OK </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOOST_VBAT_OK</name>
	<description>Indicates that VBAT is above threshold while in BOOST converter mode. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_ANA_OK</name>
	<description>Indicates that LDO_ANA is in regulation. This LDO is used for the general-purpose ADC only </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_VDD_OK</name>
	<description>Indicates that LDO_VDD is in regulation </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_OTP_OK</name>
	<description>Indicates that LDO_OTP is in regulation </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VDCDC_OK</name>
	<description>Indicates that VDCDC is above threshold. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT1V_OK</name>
	<description>Indicates that VBAT1V is above threshold. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>VBAT1V_AVAILABLE</name>
	<description>Indicates that VBAT1V is available. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BANDGAP_REG</name>
	<description>Bandgap trimming</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BGR_LOWPOWER</name>
	<description>Test-mode, do not use. \nIt disables the bandgap core (voltages will continue for some time, but will slowely drift away) </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field>
    <field>
	<name>LDO_RET_TRIM</name>
	<description>TRIM register</description>
	<bitRange>[13:10]</bitRange>
	<access>read-write</access>
	</field>
    <field>
	<name>BGR_ITRIM</name>
	<description>Current trimming for bias </description>
	<bitRange>[9:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_TRIM</name>
	<description>Trim register for bandgap </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_16M_REG</name>
	<description>16 MHz RC-oscillator register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000a0</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL16_NOISE_FILT_ENABLE</name>
	<description>Enables noise flter in 16 MHz crystal oscillator </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL16_BIAS_SH_ENABLE</name>
	<description>Enables Ibias sample/hold function in 16 MHz crystal oscillator. This bit should be set when the system wake up and reset before entering deep or extended sleep mode.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL16_CUR_SET</name>
	<description>Bias current for the 16 MHz XTAL oscillator.
0x0: minimum
0x7: maximum</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC16M_TRIM</name>
	<description>Controls the frequency of the RC16M oscillator.
0x0: lowest frequency
0xF: highest frequency </description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC16M_ENABLE</name>
	<description>Enables the 16 MHz RC oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_32K_REG</name>
	<description>32 kHz oscillator register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000079c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL32K_DISABLE_AMPREG</name>
	<description>Setting this bit disables the amplitude regulation of the XTAL32kHz oscillator.
Set this bit to '1' for an external clock applied at XTAL32Kp.
Keep this bit '0' with a crystal between XTAL32Kp and XTAL32Km.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_TRIM</name>
	<description>Controls the frequency of the RC32K oscillator.
0x0: lowest frequency
0x7: default
0xF: highest frequency </description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32K_ENABLE</name>
	<description>Enables the 32 kHz RC oscillator </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_CUR</name>
	<description>Bias current for the 32kHz XTAL oscillator.
0x0: minimum
0x3: default
0xF: maximum
For each application there is an optimal setting for which the startup behaviour is optimal.</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_RBIAS</name>
	<description>Setting for the bias resistor of the 32 kHz XTAL oscillator.
0x0: maximum
0x3: minimum
Prefered setting will be provided by Dialog. </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_ENABLE</name>
	<description>Enables the 32 kHz XTAL oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_AMBA_REG</name>
	<description>HCLK, PCLK, divider and clock gates</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000022</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>OTP_ENABLE</name>
	<description>Clock enable for OTP controller </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCLK_DIV</name>
	<description>APB interface clock (PCLK). Divider is cascaded with HCLK_DIV. PCLK is HCLK divided by:
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HCLK_DIV</name>
	<description>AHB interface and microprocessor clock (HCLK). HCLK is source clock divided by:
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_CTRL_REG</name>
	<description>Clock control register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000080</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RUNNING_AT_XTAL16M</name>
	<description>Indicates that the XTAL16M clock is used as clock, and may not be switched off </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_RC16M</name>
	<description>Indicates that the RC16M clock is used as clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_32K</name>
	<description>Indicates that either the RC32k or XTAL32k is being used as clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL16M_SPIKE_FLT_DISABLE</name>
	<description>Disable spikefilter in digital clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL16M_DISABLE</name>
	<description>Setting this bit instantaneously disables the 16 MHz crystal oscillator. Also, after sleep/wakeup cycle, the oscillator will not be enabled. This bit may not be set to '1'when &quot;RUNNING_AT_XTAL16M is '1' to prevent deadlock. After resetting this bit, wait for XTAL16_SETTLED or XTAL16_TRIM_READY to become '1' before switching to XTAL16 clock source. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CLK_SEL</name>
	<description>Selects the clock source.
0x0: XTAL16M (check the XTAL16_SETTLED and XTAL16_TRIM_READY bits!!)
0x1: RC16M
0x2/0x3: either RC32k or XTAL32k is used </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_FREQ_TRIM_REG</name>
	<description>Xtal frequency trimming register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>COARSE_ADJ</name>
	<description>Xtal frequency course trimming register.
0x0: lowest frequency
0x7: highest frequencyIncrement or decrement the binary value with 1. Wait approximately 200 us to allow the adjustment to settle. </description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FINE_ADJ</name>
	<description>Xtal frequency fine trimming register.
0x00: lowest frequency
0xFF: highest frequency </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_PER_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QUAD_ENABLE</name>
	<description>Enable the Quadrature clock </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enable SPI clock </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DIV</name>
	<description>Division factor for SPI
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART1_ENABLE</name>
	<description>Enable UART1 clock </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enable UART2 clock </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enable I2C clock </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPCT_ENABLE</name>
	<description>Enable Wakeup CaptureTimer clock </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_ENABLE</name>
	<description>Enable TIMER0 and TIMER2 clock </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_DIV</name>
	<description>Division factor for TIMER0 and TIMER2
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8 </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RADIO_REG</name>
	<description>Radio PLL control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>BLE_ENABLE</name>
	<description>Enable the BLE core clocks </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_LP_RESET</name>
	<description>Reset for the BLE LP timer </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_DIV</name>
	<description>Division factor for BLE core blocks
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8
The programmed frequency should not be lower than 8 MHz and not faster than the programmed CPU clock frequency. Refer also to BLE_CNTL2_REG[BLE_CLK_SEL].</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCU_ENABLE</name>
	<description>Enable the RF control Unit clock </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RFCU_DIV</name>
	<description>Division factor for RF Control Unit
0x0: divide by 1
0x1: divide by 2
0x2: divide by 4
0x3: divide by 8
The programmed frequency must be exactly 8 MHz. </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCX20K_REG</name>
	<description>RCX-oscillator control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000178</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>RCX20K_SELECT</name>
	<description>Selects RCX oscillator.
0 : RC32K oscillator
1: RCX oscillator</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX20K_ENABLE</name>
	<description>Enable the RCX oscillator</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX20K_LOWF</name>
	<description>Extra low frequency</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX20K_BIAS</name>
	<description>Bias control</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX20K_NTC</name>
	<description>Temperature control</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX20K_TRIM</name>
	<description>Controls the frequency of the RCX oscillator.
0x0: lowest frequency
0x7: default
0xF: highest frequency</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_CTRL_REG</name>
	<description>Power Management Unit control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000fff7</resetMask>
	<fields><field>
	<name>RETENTION_MODE</name>
	<description>Select the retainability of the 4 retention RAM macros.
'1' is retainable, '0' is power gated.
(3) is RETRAM4
(2) is RETRAM3
(1) is RETRAM2
(0) is RETRAM1</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_BOOST</name>
	<description>Force the DCDC into boost mode at next wakeup.
Setting this bit reduces the deepsleep current.
FORCE_BOOST has highest priority.
When either FORCE_BOOST or FORCE_BUCK have been written, these bits cannot be changed.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FORCE_BUCK</name>
	<description>Force the DCDC into buck mode at next wakeup.
Setting this bit reduces the deepsleep current.
FORCE_BOOST has highest priority.
When either FORCE_BOOST or FORCE_BUCK have been written, these bits cannot be changed.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_COPY_DIV</name>
	<description>Sets the HCLK division during OTP mirroring </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_SLEEP</name>
	<description>Put the digital part of the radio in powerdown </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PERIPH_SLEEP</name>
	<description>Put all peripherals (I2C, UART, SPI, ADC) in powerdown </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_ON_WAKEUP</name>
	<description>Perform a Hardware Reset after waking up. Booter will be started. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_CTRL_REG</name>
	<description>System Control register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x000083ff</resetMask>
	<fields><field>
	<name>SW_RESET</name>
	<description>Writing a '1' to this bit will reset the device, except for:
SYS_CTRL_REG
CLK_FREQ_TRIM_REG
... </description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIMEOUT_DISABLE</name>
	<description>Disables timeout in Power statemachine. By default, the statemachine continues if after 2 ms the blocks are not started up. This can be read back from
ANA_STATUS_REG. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEBUGGER_ENABLE</name>
	<description>Enable the debugger. This bit is set by the booter according to the OTP header. If not set, the SWDIO and SW_CLK can be used as gpio ports. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_RESET_REQ</name>
	<description>Reset request for the OTP controller. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PAD_LATCH_EN</name>
	<description>Latches the control signals of the pads for state retention in powerdown mode.
0: Control signals are retained
1: Latch is transparant, pad can be recontrolled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTP_COPY</name>
	<description>Enables OTP to SysRAM copy action after waking up PD_SYS </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK32_SOURCE</name>
	<description>Sets the clock source of the 32 kHz clock
0 = RC-oscillator
1 = 32 kHz crystal oscillator </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RET_SYSRAM</name>
	<description>Sets the development phase mode.
If this bit is set, the SysRAM cell will not power gated during sleep (extended sleep).
No copy action to SysRAM is done when the system wakes up.
For emulating startup time, the OTP_COPY bit still needs to be set. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_ADR0</name>
	<description>Controls which memory is located at address 0x0000 for execution.
0x0: ROM
0x1: OTP
0x2: SysRAM
0x3: RetRAM</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_STAT_REG</name>
	<description>System status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL16_SETTLED</name>
	<description>Indicates that XTAL16 has had &gt; 2 ms of settle time </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL16_TRIM_READY</name>
	<description>Indicates that XTAL trimming mechanism is ready, i.e. the trimming equals CLK_FREQ_TRIM_REG. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBG_IS_UP</name>
	<description>Indicates that PD_DBG is functional </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBG_IS_DOWN</name>
	<description>Indicates that PD_DBG is in power down </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PER_IS_UP</name>
	<description>Indicates that PD_PER is functional </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PER_IS_DOWN</name>
	<description>Indicates that PD_PER is in power down </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_UP</name>
	<description>Indicates that PD_RAD is functional </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_DOWN</name>
	<description>Indicates that PD_RAD is in power down </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TRIM_CTRL_REG</name>
	<description>Control trimming of the XTAL16M</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000a2</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>TRIM_TIME</name>
	<description>Defines the delay between XTAL16M enable and applying the CLK_FREQ_TRIM_REG in steps of 250 us.
0x0: apply directly
0x1: wait between 0 and 250 us
0x2: wait between 250 us and 500 us
etc.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SETTLE_TIME</name>
	<description>Defines the delay between applying CLK_FREQ_TRIM_REG and XTAL16_SETTLED in steps of 250 us.
0x0: XTAL16_SETTLED is set direcly
0x1: wait between 0 and 250 us
0x2: wait between 250 us and 500 us
etc.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>gpio580_ports_nl01</name>
	<version>1.0</version>
	<description>gpio580_ports_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>150</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>P00_MODE_REG</name>
	<description>P00 Mode Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P01_MODE_REG</name>
	<description>P01 Mode Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P01_PADPWR_CTRL_REG</name>
	<description>Ports 0 and 1 Output Power Control Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_OUT_CTRL</name>
	<description>1 = P1_x port output is powered by the 1 V rail
0 = P1_x port output is powered by the 3 V rail
bit 8 controls the power of P1[0],
bit 13 controls the power of P1[5]</description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>P0_OUT_CTRL</name>
	<description>1 = P0_x port output is powered by the 1 V rail
0 = P0_x port output is powered by the 3 V rail
bit 0 controls the power of P0[0],
bit 7 controls the power of P0[7]</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P02_MODE_REG</name>
	<description>P02 Mode Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P03_MODE_REG</name>
	<description>P03 Mode Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P04_MODE_REG</name>
	<description>P04 Mode Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P05_MODE_REG</name>
	<description>P05 Mode Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P06_MODE_REG</name>
	<description>P06 Mode Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P07_MODE_REG</name>
	<description>P07 Mode Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port
0 = Port function, PUPD as set above
1 = UART1_RX
2 = UART1_TX
3 = UART2_RX
4 = UART2_TX
5 = SPI_DI
6 = SPI_DO
7 = SPI_CLK
8 = SPI_EN
9 = I2C_SCL
10 = I2C_SDA
11 = UART1_IRDA_RX
12 = UART1_IRDA_TX
13 = UART2_IRDA_RX
14 = UART2_IRDA_TX
15 = ADC (only for P0[3:0])
16 = PWM0
17 = PWM1
18 = BLE_DIAG (only for P0[7:0])
19 = UART1_CTSN
20 = UART1_RTSN
21 = UART2_CTSN
22 = UART2_RTSN
23 = PWM2
24 = PWM3
25 = PWM4
Note: when a certain input function (like SPI_DI) is selected on more than 1 port pin, the port with the lowest index has the highest priority and P0 has higher priority than P1. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_DATA_REG</name>
	<description>P0 Data input / output register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_DATA</name>
	<description>Set P0 output register when written; Returns the value of P0 port when read </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_DATA_REG</name>
	<description>P0 Reset port pins register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_RESET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_SET_DATA_REG</name>
	<description>P0 Set port pins register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_SET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P10_MODE_REG</name>
	<description>P10 Mode Register</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care
P14_MODE_REG and P15_MODE_REG reset value is 1 (i.e. pulled up) </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P11_MODE_REG</name>
	<description>P11 Mode Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care
P14_MODE_REG and P15_MODE_REG reset value is 1 (i.e. pulled up) </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P12_MODE_REG</name>
	<description>P12 Mode Register</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care
P14_MODE_REG and P15_MODE_REG reset value is 1 (i.e. pulled up) </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P13_MODE_REG</name>
	<description>P13 Mode Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care
P14_MODE_REG and P15_MODE_REG reset value is 1 (i.e. pulled up) </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P14_MODE_REG</name>
	<description>P14 Mode Register</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care
P14_MODE_REG and P15_MODE_REG reset value is 1 (i.e. pulled up) </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P15_MODE_REG</name>
	<description>P15 Mode Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care
P14_MODE_REG and P15_MODE_REG reset value is 1 (i.e. pulled up) </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_DATA_REG</name>
	<description>P1 Data input / output register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_DATA</name>
	<description>Set P1 output register when written; Returns the value of P1 port when read </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_RESET_DATA_REG</name>
	<description>P1 Reset port pins register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_RESET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_SET_DATA_REG</name>
	<description>P1 Set port pins register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_SET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P20_MODE_REG</name>
	<description>P20 Mode Register</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P21_MODE_REG</name>
	<description>P21 Mode Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P22_MODE_REG</name>
	<description>P22 Mode Register</description>
	<addressOffset>0x0000004a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P23_MODE_REG</name>
	<description>P23 Mode Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P24_MODE_REG</name>
	<description>P24 Mode Register</description>
	<addressOffset>0x0000004e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P25_MODE_REG</name>
	<description>P25 Mode Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P26_MODE_REG</name>
	<description>P26 Mode Register</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P27_MODE_REG</name>
	<description>P27 Mode Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P28_MODE_REG</name>
	<description>P28 Mode Register</description>
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P29_MODE_REG</name>
	<description>P29 Mode Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In analog mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_DATA_REG</name>
	<description>P2 Data input / output register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P2_DATA</name>
	<description>Set P2 output register when written; Returns the value of P2 port when read </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_PADPWR_CTRL_REG</name>
	<description>Port 2 Output Power Control Register</description>
	<addressOffset>0x00000072</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P2_OUT_CTRL</name>
	<description>1 = P2_x port output is powered by the 1 V rail
0 = P2_x port output is powered by the 3 V rail
bit 0 controls the power of P2[0],
bit 9 controls the power of P2[9],</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_RESET_DATA_REG</name>
	<description>P2 Reset port pins register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P2_RESET</name>
	<description>Writing a 1 to P2[y] sets P2[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P2_SET_DATA_REG</name>
	<description>P2 Set port pins register</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P2_SET</name>
	<description>Writing a 1 to P2[y] sets P2[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P30_MODE_REG</name>
	<description>P30 Mode Register</description>
	<addressOffset>0x00000086</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P31_MODE_REG</name>
	<description>P31 Mode Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P32_MODE_REG</name>
	<description>P32 Mode Register</description>
	<addressOffset>0x0000008a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P33_MODE_REG</name>
	<description>P33 Mode Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P34_MODE_REG</name>
	<description>P34 Mode Register</description>
	<addressOffset>0x0000008e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P35_MODE_REG</name>
	<description>P35 Mode Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P36_MODE_REG</name>
	<description>P36 Mode Register</description>
	<addressOffset>0x00000092</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P37_MODE_REG</name>
	<description>P37 Mode Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, Pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0x_MODE_REG[PID] </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P3_DATA_REG</name>
	<description>P3 Data input / output register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P3_DATA</name>
	<description>Set P3 output register when written; Returns the value of P3 port when read </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P3_PADPWR_CTRL_REG</name>
	<description>Port 3 Output Power Control Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P3_OUT_CTRL</name>
	<description>1 = P3_x port output is powered by the 1 V rail
0 = P3_x port output is powered by the 3 V rail
bit 0 controls the power of P3[0],
bit 7 controls the power of P3[7],</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P3_RESET_DATA_REG</name>
	<description>P3 Reset port pins register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P3_RESET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 0. Writing 0 is discarded;
Reading returns 0</description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P3_SET_DATA_REG</name>
	<description>P3 Set port pins register</description>
	<addressOffset>0x00000082</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P3_SET</name>
	<description>Writing a 1 to P3[y] sets P3[y] to 1. Writing 0 is discarded; Reading returns 0</description>
	<bitRange>[7:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>i2c580_nl00</name>
	<version>1.0</version>
	<description>i2c580_nl00 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>162</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>I2C_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000007d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s) </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTRL_ENABLE</name>
	<description>Controls whether the controller is enabled.
0: Disables the controller (TX and RX FIFOs are held in an erased state)
1: Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver
operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1.
When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1). </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000017</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SDA_HOLD</name>
	<description>SDA Hold time</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000048</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000004f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Slave FSM is in IDLE state so the Slave part of the controller is not Active
1: Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Master FSM is in IDLE state so the Master part of the controller is not Active
1: Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0: Receive FIFO is not full
1: Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0: Receive FIFO is empty
1: Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0: Transmit FIFO is not empty
1: Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0: Transmit FIFO is full
1: Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>This bit indicates whether software performs a General Call or
START BYTE command.
0: ignore bit 10 GC_OR_START and use IC_TAR normally
1: perform special I2C command as specified in GC_OR_START
bit </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1: START BYTE </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>1: Slave lost the bus while transmitting data to a remote master.
I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>1: Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>1: Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>1: User tries to initiate a Master operation with the Master mode disabled. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>1: Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>1: Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>1: the controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1). </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>1: the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>1: This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>1: Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>1: Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>1: Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries.. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>kbrd580_nl01</name>
	<version>1.0</version>
	<description>kbrd580_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>24</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>GPIO_DEBOUNCE_REG</name>
	<description>debounce counter value for GPIO inputs</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DEB_ENABLE_KBRD</name>
	<description>enables the debounce counter for the KBRD interface </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE4</name>
	<description>enables the debounce counter for GPIO IRQ4 </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE3</name>
	<description>enables the debounce counter for GPIO IRQ3 </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE2</name>
	<description>enables the debounce counter for GPIO IRQ2 </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE1</name>
	<description>enables the debounce counter for GPIO IRQ1 </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_ENABLE0</name>
	<description>enables the debounce counter for GPIO IRQ0 </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEB_VALUE</name>
	<description>Keyboard debounce time if enabled. Generate KEYB_INT after specified time.
Debounce time: N*1 ms. N =0..63</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_INT_LEVEL_CTRL_REG</name>
	<description>high or low level select for GPIO interrupts</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000dfdf</resetMask>
	<fields><field>
	<name>EDGE_LEVELn4</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ4 </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn3</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ3 </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn2</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ2 </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn1</name>
	<description>see EDGE_LEVELn0, but for GPIO IRQ1 </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDGE_LEVELn0</name>
	<description>0: do not wait for key release after interrupt was reset for GPIO IRQ0, so a new interrupt can be initiated immediately
1: wait for key release after interrupt was reset for IRQ0 </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL4</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ4 </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL3</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ3 </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL2</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ2 </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL1</name>
	<description>see INPUT_LEVEL0, but for GPIO IRQ1 </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INPUT_LEVEL0</name>
	<description>0 = selected input will generate GPIO IRQ0 if that input is high.
1 = selected input will generate GPIO IRQ0 if that input is low. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ0_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KBRD_IRQ0_SEL</name>
	<description>input selection that can generate a GPIO interrupt
0: no input selected
1: P0[0] is selected
2: P0[1] is selected
3: P0[2] is selected
4: P0[3] is selected
5: P0[4] is selected
6: P0[5] is selected
7: P0[6] is selected
8: P0[7] is selected
9: P1[0] is selected
10: P1[1] is selected
11: P1[2] is selected
12: P1[3] is selected
13: P1[4] is selected
14: P1[5] is selected
15: P2[0] is selected
16: P2[1] is selected
17: P2[2] is selected
18: P2[3] is selected
19: P2[4] is selected
20: P2[5] is selected
21: P2[6] is selected
22: P2[7] is selected
23: P2[8] is selected
24: P2[9] is selected
25: P3[0] is selected
26: P3[1] is selected
27: P3[2] is selected
28: P3[3] is selected
29: P3[4] is selected
30: P3[5] is selected
31: P3[6] is selected
32: P3[7] is selected
all others: no input selected </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ1_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ1</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KBRD_IRQ1_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ2_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ2</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KBRD_IRQ2_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ3_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ3</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KBRD_IRQ3_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_IRQ4_IN_SEL_REG</name>
	<description>GPIO interrupt selection for GPIO_IRQ4</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KBRD_IRQ4_SEL</name>
	<description>see KBRD_IRQ0_SEL </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GPIO_RESET_IRQ_REG</name>
	<description>GPIO interrupt reset register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RESET_KBRD_IRQ</name>
	<description>writing a 1 to this bit will reset the KBRD IRQ.
Reading returns 0. </description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO4_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO4 IRQ.
Reading returns 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO3_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO3 IRQ.
Reading returns 0. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO2_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO2 IRQ.
Reading returns 0. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO1_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO1 IRQ.
Reading returns 0. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RESET_GPIO0_IRQ</name>
	<description>writing a 1 to this bit will reset the GPIO0 IRQ.
Reading returns 0. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>KBRD_IRQ_IN_SEL0_REG</name>
	<description>GPIO interrupt selection for KBRD_IRQ for P0</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KBRD_REL</name>
	<description>0 = No interrupt on key release
1 = Interrupt also on key release (also debouncing if enabled) </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_LEVEL</name>
	<description>0 = enabled input will generate KBRD IRQ if that input is high.
1 = enabled input will generate KBRD IRQ if that input is low. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KEY_REPEAT</name>
	<description>While key is pressed, automatically generate repeating
KEYB_INT after specified time unequal to 0.
Repeat time: N*1 ms. N =1..63, N=0 disables the timer. </description>
	<bitRange>[13:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P07_EN</name>
	<description>enable P0[7] for the keyboard interrupt </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P06_EN</name>
	<description>enable P0[6] for the keyboard interrupt </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P05_EN</name>
	<description>enable P0[5] for the keyboard interrupt </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P04_EN</name>
	<description>enable P0[4] for the keyboard interrupt </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P03_EN</name>
	<description>enable P0[3] for the keyboard interrupt </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P02_EN</name>
	<description>enable P0[2] for the keyboard interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P01_EN</name>
	<description>enable P0[1] for the keyboard interrupt </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P00_EN</name>
	<description>enable P0[0] for the keyboard interrupt </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>KBRD_IRQ_IN_SEL1_REG</name>
	<description>GPIO interrupt selection for KBRD_IRQ for P1 and P2</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>KBRD_P15_EN</name>
	<description>enable P1[5] for the keyboard interrupt </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P14_EN</name>
	<description>enable P1[4] for the keyboard interrupt </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P13_EN</name>
	<description>enable P1[3] for the keyboard interrupt </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P12_EN</name>
	<description>enable P1[2] for the keyboard interrupt </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P11_EN</name>
	<description>enable P1[1] for the keyboard interrupt </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P10_EN</name>
	<description>enable P1[0] for the keyboard interrupt </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P29_EN</name>
	<description>enable P2[9] for the keyboard interrupt </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P28_EN</name>
	<description>enable P2[8] for the keyboard interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P27_EN</name>
	<description>enable P2[7] for the keyboard interrupt </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P26_EN</name>
	<description>enable P2[6] for the keyboard interrupt </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P25_EN</name>
	<description>enable P2[5] for the keyboard interrupt </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P24_EN</name>
	<description>enable P2[4] for the keyboard interrupt </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P23_EN</name>
	<description>enable P2[3] for the keyboard interrupt </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P22_EN</name>
	<description>enable P2[2] for the keyboard interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P21_EN</name>
	<description>enable P2[1] for the keyboard interrupt </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P20_EN</name>
	<description>enable P2[0] for the keyboard interrupt </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>KBRD_IRQ_IN_SEL2_REG</name>
	<description>GPIO interrupt selection for KBRD_IRQ for P3</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>KBRD_P37_EN</name>
	<description>enable P3[7] for the keyboard interrupt </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P36_EN</name>
	<description>enable P3[6] for the keyboard interrupt </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P35_EN</name>
	<description>enable P3[5] for the keyboard interrupt </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P34_EN</name>
	<description>enable P3[4] for the keyboard interrupt </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P33_EN</name>
	<description>enable P3[3] for the keyboard interrupt </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P32_EN</name>
	<description>enable P3[2] for the keyboard interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P31_EN</name>
	<description>enable P3[1] for the keyboard interrupt </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>KBRD_P30_EN</name>
	<description>enable P3[0] for the keyboard interrupt </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>otpc580_gr01</name>
	<version>1.0</version>
	<description>otpc580_gr01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40008000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>OTPC_AHBADR_REG</name>
	<description>AHB master start address</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_AHBADR</name>
	<description>Tthe AHB address used by the AHB master interface of the controller (
bits [31:2]). </description>
	<bitRange>[31:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_CELADR_REG</name>
	<description>Macrocell start address</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_CELADR</name>
	<description>Defines a word address inside the macrocell. Used in modes AREAD and APROG and is automatically updated. </description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_FFPRT_REG</name>
	<description>Ports access to fifo logic</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_FFPRT</name>
	<description>Provides access to the fifo through an access port. Write this register with the corresponding data, when the APROG mode is selected and the DMA is disabled. Read from this register the corresponding data, when the AREAD mode is selected and the DMA is disabled.
Check OTPC_STAT_FWORDS register for data/space availability, before accessing the fifo. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_FFRD_REG</name>
	<description>Latest read data from the OTPC_FFPRT_REG</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_FFRD</name>
	<description>Contains the value read from the fifo, after a read of the OTPC_FFPRT_REG register. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>OTPC_MODE_REG</name>
	<description>Mode register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_MODE_PRG_PORT_MUX</name>
	<description>Selects the source that is connected to the prg_port port of the controller.
00 - {16'd0, BANDGAP_REG[15:0]}
01 - {RF_RSSI_COMP_CTRL_REG[15:0], 8'd0, RFIO_CTRL1_REG{7:0]}
10 - {3'd0, RF_LNA_CTRL3_REG[4:0], RF_LNA_CTRL2_REG[11:0], RF_LNA_CTRL1_REG[11:0]}
11 - {28'd0, RF_VCO_CTRL_REG[3:0]}
See OTPC_MODE_PRG_PORT_SEL about the use of the prg_port </description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OPTC_MODE_PRG_FAST</name>
	<description>Defines the timing that will be used for all the programming activities (APROG, MPROG and TWR)
0 - Selects the normal timing
1 - Selects the fast timing </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_PRG_PORT_SEL</name>
	<description>Selects an alternative data source for the programming of the OTP macrocells, when the controller is configured in APROG mode.
0 - The fifo will be used as the data source. The fifo will be filled with a way defined by the register OTPC_MODE_USE_DMA. The number of words that will be programmed is defined by OTPC_NWORDS.
1 - Only one word will programmed. The value of the word is contained in the prg_port port of the controller. The values of the registers OTPC_MODE_USE_DMA, OTPC_NWORDS and the contents of the FIFO will not be used. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_TWO_CC_ACC</name>
	<description>Defines the duration of each read from the OTP macrocells.
0 - Reads 16 bits of data every one clock cycle.
1 - Reads 16 bits of data every two clock cycles. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_FIFO_FLUSH</name>
	<description>Writing 1, removes any content from the FIFO. This bit returns automatically to 0. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_USE_DMA</name>
	<description>Selects the use of the dma, when the controller is configured in one of the modes: AREAD or APROG.
0 - DMAis not used. The data should be transfered from/to controller through OTPC_FFPRT_REG
1 - DMA is used. Data transfers from/to controller are performed automatically. The AHB base address should be configured in OTPC_AHBADR_REG before the selection of the mode.
If programming of the OTPC_MODE_REG is performed through the serial interface,the OTPC_MODE_USE_DMA will be set to 0 automatically.
If the controller is in APROG mode and the OTPC_MODE_PRG_PORT_SEL is enabled, the dma will stay inactive.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_MODE_MODE</name>
	<description>Defines the mode of operation of the OTPC controller. The encoding of the modes is as follows:
000 - STBY mode
001 - MREAD mode
010 - MPROG mode
011 - AREAD mode
100 - APROG mode
101 - Test mode. Reserved
110 - Test mode. Reserved
111 - Test mode. Reserved
To manually move between modes, always return to STBY mode first.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_NWORDS_REG</name>
	<description>Number of words</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_NWORDS</name>
	<description>The number of words (minus one) for reading/programming during the AREAD/APROG mode.
If in APROG mode, and the OTPC_MODE_PRG_PORT_SEL is enabled (=1), this register will not be used and will stay unchanged.
During mirroring, this register reflects the current amount of data that will be copied. It keeps its value until be written by the software with a new value. The number of the words that remaining to be processed by the controller is contained in the field OTPC_STAT_NWORDS.</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_PCTRL_REG</name>
	<description>Bit-programming control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_PCTRL_ENU</name>
	<description>Enables the programming in the upper bank of the OTP.
0 - Programming sequence is not applied in the upper bank.
1 - Programming sequence is applied in the upper bank. </description>
	<bitRange>[27:27]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_BITU</name>
	<description>Defines the value of the selected bit in the upper bank, after the programming sequence. </description>
	<bitRange>[26:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_ENL</name>
	<description>Enables the programming in the lower bank.
0 - The programming sequence is not applied in the lower bank.
1 -The programming sequence is applied in the lower bank. </description>
	<bitRange>[25:25]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_BITL</name>
	<description>Defines the value of the selected bit in the lower bank, after the programming sequence. </description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_BSELU</name>
	<description>Selects between the U1 and U0 byte for the programming sequence in the upper bank.
0 - Program the U0 byte
1 - Program the U1 byte -</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_BADRU</name>
	<description>Selects the bit inside the Ux (x=0,1) byte, which will be programmed in the upper bank. </description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_BSELL</name>
	<description>Selects between the L1 and L0 byte for the programming sequence in the lower bank.
0 - Program the L0 byte
1 - Program the L1 byte </description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_BADRL</name>
	<description>Selects the bit inside the Lx (x=0,1) byte, which will be programmed in the lower bank. </description>
	<bitRange>[18:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OTPC_PCTRL_WADDR</name>
	<description>Defines the address of a 32 bits word {U1,L1,U0,L0} in the macrocells, where one or two bits will be programmed. There are two macrocell banks, with 8 bits each. Each bank contribute with two memory positions for each 32 bits word. The Ux, Lx represent the bytes of the upper and lower bank respectively.</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>OTPC_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000015</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>OTPC_STAT_NWORDS</name>
	<description>Contains the current value of the words to be processed.</description>
	<bitRange>[28:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_TERR_U</name>
	<description>Indicates the upper bank as the source of a test error. This value is valid when OTPC_STAT_TERROR is valid.
0 - There is no test error in the upper bank
1 - A test error has occured in the upper bank </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_TERR_L</name>
	<description>Indicates the lower bank as the source of a test error. The value is valid when OTPC_STAT_TERROR is valid.
0 - There is no test error in the lower bank
1 - A test error has occured in the lower bank </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PERR_U</name>
	<description>Indicates the upper bank as the source of a programming error. The value is valid when OTPC_STAT_PERROR is valid.
0 - There is no programming error in the upper bank
1 - A programming error has occured in the upper bank </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PERR_L</name>
	<description>Indicates the lower bank as the source of a programming error. The value is valid when OTPC_STAT_PERROR is valid.
0 - There is no programming error in the lower bank
1 - A programming error has occured in the lower bank </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_FWORDS</name>
	<description>Indicates the number of words which contained in the fifo of the controller. </description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_ARDY</name>
	<description>Monitors the progress of read or programming operations while in the AREAD or APROG modes.
0 - The controller is busy while reading or programming (AREAD or APROG modes).
1 - The controller is not busy in AREAD or APROG mode. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_TERROR</name>
	<description>Indicates the result of a test sequence. Should be checked after the end of a TBLANK, TDEC and TWR mode (OTPC_STAT_TRDY= 1).
0 - The test sequence ends with no error.
1 - The test sequence has failed. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_TRDY</name>
	<description>Indicates the state of a test mode. Should be used to monitor the progress of the TBLANK, TDEC and TWR modes.
0 - The controller is busy. A test mode is in progress.
1 - There is no active test mode. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PERROR</name>
	<description>Indicates that an error has occurred during the bit-programming process.
0 - No error during the bit-programming process.
1 - The process of bit-programming failed.
When the controller is in MPROG mode, this bit should be checked after the end of the programming process (OTPC_STAT_PRDY= 1).
During APROG mode, the value of this field is normal to change periodically. Upon finishing the operation in the APROG mode (OTPC_STAT_ARDY= 1), this field indicates if the programming has failed or ended succesfully. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OTPC_STAT_PRDY</name>
	<description>Indicates the state of a bit-programming process.
0 - The controller is busy. A bit-programming is in progress
1 - The logic which performs bit-programming is idle.
When the controller is in MPROG mode, this bit should be used to monitor the progress of a programming request.
During APROG mode, the value of this field it is normal to changing periodically. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>quadec580_gr01</name>
	<version>1.0</version>
	<description>quadec580_gr01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>12</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>QDEC_CLOCKDIV_REG</name>
	<description>Clock divider register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>clock_divider</name>
	<description>Contains the number of the input clock cycles minus one, that are required to generate one logic clock cycle. </description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL2_REG</name>
	<description>Quad Decoder control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CHZ_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Z
0: none
1: P0[0] -&gt; CHZ_A, P0[1] -&gt; CHZ_B
2: P0[2] -&gt; CHZ_A, P0[3] -&gt; CHZ_B
3: P0[4] -&gt; CHZ_A, P0[5] -&gt; CHZ_B
4: P0[6] -&gt; CHZ_A, P0[7] -&gt; CHZ_B
5: P1[0] -&gt; CHZ_A, P1[1] -&gt; CHZ_B
6: P1[2] -&gt; CHZ_A, P1[3] -&gt; CHZ_B
7: P2[3] -&gt; CHZ_A, P2[4] -&gt; CHZ_B
8: P2[5] -&gt; CHZ_A, P2[6] -&gt; CHZ_B
9: P2[7] -&gt; CHZ_A, P2[8] -&gt; CHZ_B
10: P2[9] -&gt; CHZ_A, P2[0] -&gt; CHZ_B
11..15: None</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHY_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Y
0: none
1: P0[0] -&gt; CHY_A, P0[1] -&gt; CHY_B
2: P0[2] -&gt; CHY_A, P0[3] -&gt; CHY_B
3: P0[4] -&gt; CHY_A, P0[5] -&gt; CHY_B
4: P0[6] -&gt; CHY_A, P0[7] -&gt; CHY_B
5: P1[0] -&gt; CHY_A, P1[1] -&gt; CHY_B
6: P1[2] -&gt; CHY_A, P1[3] -&gt; CHY_B
7: P2[3] -&gt; CHY_A, P2[4] -&gt; CHY_B
8: P2[5] -&gt; CHY_A, P2[6] -&gt; CHY_B
9: P2[7] -&gt; CHY_A, P2[8] -&gt; CHY_B
10: P2[9] -&gt; CHY_A, P2[0] -&gt; CHY_B
11..15: None</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CHX_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel X
0: none
1: P0[0] -&gt; CHX_A, P0[1] -&gt; CHX_B
2: P0[2] -&gt; CHX_A, P0[3] -&gt; CHX_B
3: P0[4] -&gt; CHX_A, P0[5] -&gt; CHX_B
4: P0[6] -&gt; CHX_A, P0[7] -&gt; CHX_B
5: P1[0] -&gt; CHX_A, P1[1] -&gt; CHX_B
6: P1[2] -&gt; CHX_A, P1[3] -&gt; CHX_B
7: P2[3] -&gt; CHX_A, P2[4] -&gt; CHX_B
8: P2[5] -&gt; CHX_A, P2[6] -&gt; CHX_B
9: P2[7] -&gt; CHX_A, P2[8] -&gt; CHX_B
10: P2[9] -&gt; CHX_A, P2[0] -&gt; CHX_B
11..15: None</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL_REG</name>
	<description>Quad Decoder control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QD_IRQ_THRES</name>
	<description>The number of events on either counter (X or Y) that need to be reached before an interrupt is generated. If 0 is written, then threshold is considered to be 1. </description>
	<bitRange>[9:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QD_IRQ_STATUS</name>
	<description>Interrupt Status. If 1 an interrupt has occured. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>QD_IRQ_CLR</name>
	<description>Writing 1 to this bit clears the interrupt. This bit is autocleared </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QD_IRQ_MASK</name>
	<description>0: interrupt is masked
1: interrupt is enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_XCNT_REG</name>
	<description>Counter value of the X Axis</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>X_counter</name>
	<description>Contains a signed value of the events. Zero when channel is disabled </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_YCNT_REG</name>
	<description>Counter value of the Y Axis</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>Y_counter</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_ZCNT_REG</name>
	<description>Z_counter</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>Z_counter</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>riscutil580_gpreg_nl01</name>
	<version>1.0</version>
	<description>riscutil580_gpreg_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>10</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>DEBUG_REG</name>
	<description>Various debug information register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DEBUGS_FREEZE_EN</name>
	<description>Default '1', freezing of the on-chip timers is enabled when the Cortex-M0 is halted in DEBUG State.
If '0', freezing of the on-chip timers is depending on FREEZE_REG when the Cortex-M0 is halted in DEBUG State except the watchdog timer. The watchdog timer is always frozen when the Cortex-M0 is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_CONTROL_REG</name>
	<description>General purpose system control register.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EM_MAP</name>
	<description>Select the mapping of the Exchange memory pages.
0: EM size 0 kB, SysRAM size 42 kB
1: EM size 2 kB, SysRAM size 48 kB
2: EM size 3 kB, SysRAM size 47 kB
3: EM size 4 kB, SysRAM size 46 kB
4: EM size 5 kB, SysRAM size 45 kB
5: EM size 6 kB, SysRAM size 44 kB
6: EM size 7 kB, SysRAM size 43 kB
7: EM size 8 kB, SysRAM size 42 kB
8: Reserved
9: EM size 4 kB, SysRAM size 40 kB
10: EM size 5 kB, SysRAM size 40 kB
11: EM size 6 kB, SysRAM size 40 kB
12: EM size 7 kB, SysRAM size 40 kB
13: EM size 8 kB, SysRAM size 40 kB
14: EM size 9 kB, SysRAM size 40 kB
15: EM size 10 kB, SysRAM size 40 kB
16: Reserved
17: EM size 6 kB, SysRAM size 38 kB
18: EM size 7 kB, SysRAM size 38 kB
19: EM size 8 kB, SysRAM size 38 kB
20: EM size 9 kB, SysRAM size 38 kB
21: EM size 10 kB, SysRAM size 38 kB
22: EM size 11 kB, SysRAM size 38 kB
23: EM size 12 kB, SysRAM size 38 kB
other: Reserved. </description>
	<bitRange>[5:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BLE_WAKEUP_REQ</name>
	<description>If '1', the BLE wakes up. Must be kept high at least for 1 low power clock period. 
If the BLE is in deep sleep state, then by setting this bit it will cause the wakeup LP IRQ to be asserted with a delay of 3 to 4 low power cycles.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_STATUS_REG</name>
	<description>General purpose system status register.</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CAL_PHASE</name>
	<description>If '1', it designates that the chip is in Calibration Phase i.e. the OTP has been initially programmed but no Calibration has occured. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_FREEZE_REG</name>
	<description>Controls unfreezing of various timers/counters.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer continues, '0' is discarded. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the the BLE master clock continues, '0' is discarded. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer (TIMER0) continues, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer continues, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_FREEZE_REG</name>
	<description>Controls freezing of various timers/counters.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer is frozen, '0' is discarded. WATCHDOG_CTRL_REG[NMI_RST] must be '0' to allow the freeze function. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the BLE master clock is frozen, '0' is discarded. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If '1', the SW Timer (TIMER0) is frozen, '0' is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer is frozen, '0' is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>riscutil580_wdog_nl00</name>
	<version>1.0</version>
	<description>riscutil580_wdog_nl00 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WATCHDOG_CTRL_REG</name>
	<description>Watchdog control register.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>NMI_RST</name>
	<description>0 = Watchdog timer generates NMI at value 0, and WDOG (SYS) reset at &lt;=-16. Timer can be frozen /resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG].
1 = Watchdog timer generates a WDOG (SYS) reset at value 0 and can not be frozen by Software.
Note that this bit can only be set to 1 by SW and only be reset with a WDOG (SYS) reset or SW reset.
The watchdog is always frozen when the Cortex-M0 is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WATCHDOG_REG</name>
	<description>Watchdog timer register.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WDOG_WEN</name>
	<description>0000.000 = Write enable for Watchdog timer
else Write disable. This filter prevents unintentional presetting the watchdog with a SW run-away. </description>
	<bitRange>[15:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WDOG_VAL_NEG</name>
	<description>0 = Watchdog timer value is positive.
1 = Watchdog timer value is negative. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOG_VAL</name>
	<description>Write: Watchdog timer reload value. Note that all bits 15-9 must be 0 to reload this register.
Read: Actual Watchdog timer value. Decremented by 1 every 10.24 msec. Bit 8 indicates a negative counter value. 2, 1, 0, 1FF16, 1FE16 etc. An NMI or WDOG (SYS) reset is generated under the following conditions:
If WATCHDOG_CTRL_REG[NMI_RST] = 0 then
    If WDOG_VAL = 0 -&gt; NMI (Non Maskable Interrupt)
    if WDOG_VAL = 1F016 -&gt; WDOG reset -&gt; reload FF16
If WATCHDOG_CTRL_REG[NMI_RST] = 1 then
    if WDOG_VAL &lt;= 0 -&gt; WDOG reset -&gt; reload FF16 </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>spi443_nl00</name>
	<version>1.0</version>
	<description>spi443_nl00 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>10</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>SPI_CLEAR_INT_REG</name>
	<description>SPI clear interrupt register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_CLEAR_INT</name>
	<description>Writing any value to this register will clear the SPI_CTRL_REG[SPI_INT_BIT]
Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_CTRL_REG</name>
	<description>SPI control register 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_EN_CTRL</name>
	<description>0 = SPI_EN pin disabled in slave mode. Pin SPI_EN is don't care.
1 = SPI_EN pin enabled in slave mode. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_MINT</name>
	<description>0 = Disable SPI_INT_BIT to the Interrupt Controller
1 = Enable SPI_INT_BIT to the Interrupt Controller</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_INT_BIT</name>
	<description>0 = RX Register or FIFO is empty.
1 = SPI interrupt. Data has been transmitted and receivedMust be reset by SW by writing to SPI_CLEAR_INT_REG. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_DI</name>
	<description>Returns the actual value of pin SPI_DIN (delayed with two internal SPI clock cycles) </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_TXH</name>
	<description>0 = TX-FIFO is not full, data can be written.
1 = TX-FIFO is full, data can not be written. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_FORCE_DO</name>
	<description>0 = normal operation
1 = Force SPIDO output level to value of SPI_DO. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_RST</name>
	<description>0 = normal operation
1 = Reset SPI. Same function as SPI_ON except that internal clock remain active. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_WORD</name>
	<description>00 = 8 bits mode, only SPI_RX_TX_REG0 used
01 = 16 bit mode, only SPI_RX_TX_REG0 used
10 = 32 bits mode, SPI_RX_TX_REG0 &amp; SPI_RX_TX_REG1 used
11 = 9 bits mode. Only valid in master mode. </description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_SMN</name>
	<description>Master/slave mode
0 = Master,
1 = Slave(SPI1 only) </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DO</name>
	<description>Pin SPI_DO output level when SPI is idle or when SPI_FORCE_DO=1 </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK</name>
	<description>Select SPI_CLK clock frequency in master mode:00 = (XTAL) / (CLK_PER_REG *8)
01 = (XTAL) / (CLK_PER_REG *4)
10 = (XTAL) / (CLK_PER_REG *2)
11 = (XTAL) / (CLK_PER_REG *14) </description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_POL</name>
	<description>Select SPI_CLK polarity.
0 = SPI_CLK is initially low.
1 = SPI_CLK is initially high. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_PHA</name>
	<description>Select SPI_CLK phase. See functional timing diagrams in SPI chapter</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ON</name>
	<description>0 = SPI Module switched off (power saving). Everything is reset except SPI_CTRL_REG0 and SPI_CTRL_REG1. When this bit is cleared the SPI will remain active in master mode until the shift register and holding register are both empty.
1 = SPI Module switched on. Should only be set after all control bits have their desired values. So two writes are needed! </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CTRL_REG1</name>
	<description>SPI control register 1</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_9BIT_VAL</name>
	<description>Determines the value of the first bit in 9 bits SPI mode. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_BUSY</name>
	<description>0 = The SPI is not busy with a transfer. This means that either no TX-data is available or that the transfers have been suspended due to a full RX-FIFO. The SPIx_CTRL_REG0[SPI_INT_BIT] can be used to distinguish between these situations.
1 = The SPI is busy with a transfer. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_PRIORITY</name>
	<description>0 = The SPI has low priority, the DMA request signals are reset after the corresponding acknowledge.
1 = The SPI has high priority, DMA request signals remain
active until the FIFOS are filled/emptied, so the DMA holds the AHB bus. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_FIFO_MODE</name>
	<description>0: TX-FIFO and RX-FIFO used (Bidirectional mode).
1: RX-FIFO used (Read Only Mode) TX-FIFO single depth, no flow control
2: TX-FIFO used (Write Only Mode), RX-FIFO single depth, no flow control
3: No FIFOs used (backwards compatible mode) </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_RX_TX_REG0</name>
	<description>SPI RX/TX register0</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_DATA0</name>
	<description>Write: SPI_TX_REG0 output register 0 (TX-FIFO)
Read: SPI_RX_REG0 input register 0 (RX-FIFO)
In 8 or 9 bits mode bits 15 to 8 are not used, they contain old data. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_RX_TX_REG1</name>
	<description>SPI RX/TX register1</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_DATA1</name>
	<description>Write: SPI_TX_REG1 output register 1 (MSB's of TX-FIFO)
Read: SPI_RX_REG1 input register 1 (MSB's of RX-FIFO)
In 8 or 9 or 16 bits mode bits this register is not used. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>tmr580_nl01</name>
	<version>1.0</version>
	<description>tmr580_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>18</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>PWM2_DUTY_CYCLE</name>
	<description>Duty Cycle for PWM2</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>DUTY_CYCLE</name>
	<description>duty cycle for PWM </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM3_DUTY_CYCLE</name>
	<description>Duty Cycle for PWM3</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>DUTY_CYCLE</name>
	<description>duty cycle for PWM </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PWM4_DUTY_CYCLE</name>
	<description>Duty Cycle for PWM4</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>DUTY_CYCLE</name>
	<description>duty cycle for PWM </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_CTRL_REG</name>
	<description>Timer0 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PWM_MODE</name>
	<description>0 = PWM signals are '1' during high time.
1 = PWM signals send out the (fast) clock divided by 2 during high time. So it will be in the range of 1 to 8 MHz. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CLK_DIV</name>
	<description>1 = Timer0 uses selected clock frequency as is.
0 = Timer0 uses selected clock frequency divided by 10.
Note that this applies only to the ON-counter.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CLK_SEL</name>
	<description>1 = Timer0 uses 16, 8, 4 or 2 MHz (fast) clock frequency.
0 = Timer0 uses 32 kHz (slow) clock frequency. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM0_CTRL</name>
	<description>0 = Timer0 is off and in reset state.
1 = Timer0 is running. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER0_ON_REG</name>
	<description>Timer0 on control register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_ON</name>
	<description>Timer0 On reload value:
If read the actual counter value ON_CNTer is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER0_RELOAD_M_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_M</name>
	<description>Timer0 'high' reload valueIf read the actual counter value T0_CNTer is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER0_RELOAD_N_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>TIM0_N</name>
	<description>Timer0 'low' reload value:
If read the actual counter value T0_CNTer is returned </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TRIPLE_PWM_CTRL_REG</name>
	<description>PWM 2 3 4 Control</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>HW_PAUSE_EN</name>
	<description>'1' = HW can pause PWM 2,3,4 </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SW_PAUSE_EN</name>
	<description>'1' = PWM 2 3 4 is paused </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIPLE_PWM_ENABLE</name>
	<description>'1' = PWM 2 3 4 is enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TRIPLE_PWM_FREQUENCY</name>
	<description>Frequency for PWM 2,3 and 4</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>FREQ</name>
	<description>Freq for PWM 2 3 4 </description>
	<bitRange>[13:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART1</name>
	<version>1.0</version>
	<description>UART1 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>254</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART_CPR_REG</name>
	<description>Component Parameter Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CPR</name>
	<description>Component Parameter Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are implemented and not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IER_DLH_REG</name>
	<description>Interrupt Enable Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[7] of the 8 bit DLH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[3] of the 8 bit DLH register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[2] of the 8 bit DLH register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[1] of the 8 bit DLH register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled Divisor Latch (High): Bit[0] of the 8 bit DLH register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IIR_FCR</name>
	<description>Interrupt Identification Register, reading this register; FIFO Control Register, writing to this register. Interrupt Identification Register: Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled. Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types: 0000 = modem status. 0001 = no interrupt pending. 0010 = THR empty. 0100 = received data available. 0110 = receiver line status. 0111 = busy detect. 1100 = character timeout. Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1 Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit. Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit. Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select.
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable.
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LPDLH_REG</name>
	<description>Low Power Divisor Latch High</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_LPDLH</name>
	<description>This register makes up the upper 8-bits of a 16-bit, read/write, Low Power Divisor Latch register that contains the baud rate divisor for the UART, which must give a baud rate of 115.2K. This is required for SIR Low Power (minimum pulse width) detection at the receiver. This register may be accessed only when the DLAB bit (LCR[7]) is set.
The output low-power baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
Low power baud rate = (serial clock frequency)/(16* divisor) Therefore, a divisor must be selected to give a baud rate of 115.2K.
NOTE: When the Low Power Divisor Latch registers (LPDLL and LPDLH) are set to 0, the low-power baud clock is disabled and no low-power pulse detection (or any pulse detection) occurs at the receiver. Also, once the LPDLH is set, at least eight clock cycles of the slowest UART Ctrl clock should be allowed to pass before transmitting or receiving data. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LPDLL_REG</name>
	<description>Low Power Divisor Latch Low</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_LPDLL</name>
	<description>This register makes up the lower 8-bits of a 16-bit, read/write, Low Power Divisor Latch register that contains the baud rate divisor for the UART, which must give a baud rate of 115.2K. This is required for SIR Low Power (minimum pulse width) detection at the receiver. This register may be accessed only when the DLAB bit (LCR[7]) is set.
The output low-power baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
Low power baud rate = (serial clock frequency)/(16* divisor)
Therefore, a divisor must be selected to give a baud rate of 115.2K.
NOTE: When the Low Power Divisor Latch registers (LPDLL and LPDLH) are set to 0, the low-power baud clock is disabled and no low-power pulse detection (or any pulse detection) occurs at the receiver. Also, once the LPDLL is set, at least eight clock cycles of the slowest UART Ctrl clock should be allowed to pass before transmitting or receiving data. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_B1</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SIRE</name>
	<description>SIR Mode Enable.
This is used to enable/disable the IrDA SIR Mode features as described in &quot;IrDA 1.0 SIR Protocol&quot; on page 53.
0 = IrDA SIR Mode disabled
1 = IrDA SIR Mode enabled </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, hardware Auto Flow Control is enabled via CTS and RTS.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_OUT2</name>
	<description>OUT2.
This is used to directly control the user-designated Output2 (out2_n) output. The value written to this location is inverted and driven out on out2_n, that is:
0 = out2_n de-asserted (logic 1)
1 = out2_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out2_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_OUT1</name>
	<description>OUT1.
This is used to directly control the user-designated Output1 (out1_n) output. The value written to this location is inverted and driven out on out1_n, that is:
0 = out1_n de-asserted (logic 1)
1 = out1_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out1_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto Flow Control is disabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high. When Auto Flow Control is enabled (MCR[5] set to one) and FIFOs are enabled (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive (high) while the value of this location is internally looped back to an input. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DCD</name>
	<description>Data Carrier Detect.
This is used to indicate the current state of the modem control line dcd_n. This bit is the complement of dcd_n. When the Data Carrier Detect input (dcd_n) is asserted it is an indication that the carrier has been detected by the modem or data set.
0 = dcd_n input is de-asserted (logic 1)
1 = dcd_n input is asserted (logic 0)
In Loopback Mode (MCR[4] set to one), DCD is the same as MCR[3] (Out2). </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_R1</name>
	<description>Ring Indicator.
This is used to indicate the current state of the modem control line ri_n. This bit is the complement of ri_n. When the Ring Indicator input (ri_n) is asserted it is an indication that a telephone ringing signal has been received by the modem or data set.
0 = ri_n input is de-asserted (logic 1)
1 = ri_n input is asserted (logic 0)
In Loopback Mode (MCR[4] set to one), RI is the same as MCR[2] (Out1). </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DDCD</name>
	<description>Delta Data Carrier Detect.
This is used to indicate that the modem control line dcd_n has changed since the last time the MSR was read.
0 = no change on dcd_n since last read of MSR
1 = change on dcd_n since last read of MSR
Reading the MSR clears the DDCD bit. In Loopback Mode (MCR[4] = 1), DDCD reflects changes on MCR[3] (Out2).
Note, if the DDCD bit is not set and the dcd_n signal is asserted (low) and a reset occurs (software or otherwise), then the DDCD bit is set when the reset is removed if the dcd_n signal remains asserted. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TERI</name>
	<description>Trailing Edge of Ring Indicator.
This is used to indicate that a change on the input ri_n (from an active-low to an inactive-high state) has occurred since the last time the MSR was read.
0 = no change on ri_n since last read of MSR
1 = change on ri_n since last read of MSR
Reading the MSR clears the TERI bit. In Loopback Mode (MCR[4] = 1), TERI reflects when MCR[2] (Out1) has changed state from a high to a low. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DCTS</name>
	<description>Delta Clear to Send.
This is used to indicate that the modem control line cts_n has changed since the last time the MSR was read.
0 = no change on cts_n since last read of MSR
1 = change on cts_n since last read of MSR
Reading the MSR clears the DCTS bit. In Loopback Mode (MCR[4] = 1), DCTS reflects changes on MCR[1] (RTS).
Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed if the cts_n signal remains asserted. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Transmit Holding Register: This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. Divisor Latch (Low): This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor) Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_RFL_REG</name>
	<description>Receive FIFO Level.</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to perform a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto Flow Control is disabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
When Auto Flow Control is enabled (MCR[5] = 1) and FIFOs are enabled (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#194;&#188; full
10 = FIFO &#194;&#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#194;&#188; full
11 = FIFO &#194;&#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x3330382a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART2</name>
	<version>1.0</version>
	<description>UART2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>254</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>UART2_CPR_REG</name>
	<description>Component Parameter Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CPR</name>
	<description>Component Parameter Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are implemented and not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IER_DLH_REG</name>
	<description>Interrupt Enable Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[7] of the 8 bit DLH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[3] of the 8 bit DLH register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[2] of the 8 bit DLH register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled Divisor Latch (High): Bit[1] of the 8 bit DLH register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled Divisor Latch (High): Bit[0] of the 8 bit DLH register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IIR_FCR</name>
	<description>Interrupt Identification Register, reading this register; FIFO Control Register, writing to this register. Interrupt Identification Register: Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled. Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types: 0000 = modem status. 0001 = no interrupt pending. 0010 = THR empty. 0100 = received data available. 0110 = receiver line status. 0111 = busy detect. 1100 = character timeout. Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1 Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit. Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit. Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select.
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable.
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LPDLH_REG</name>
	<description>Low Power Divisor Latch High</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_LPDLH</name>
	<description>This register makes up the upper 8-bits of a 16-bit, read/write, Low Power Divisor Latch register that contains the baud rate divisor for the UART, which must give a baud rate of 115.2K. This is required for SIR Low Power (minimum pulse width) detection at the receiver. This register may be accessed only when the DLAB bit (LCR[7]) is set.
The output low-power baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
Low power baud rate = (serial clock frequency)/(16* divisor) Therefore, a divisor must be selected to give a baud rate of 115.2K.
NOTE: When the Low Power Divisor Latch registers (LPDLL and LPDLH) are set to 0, the low-power baud clock is disabled and no low-power pulse detection (or any pulse detection) occurs at the receiver. Also, once the LPDLH is set, at least eight clock cycles of the slowest UART Ctrl clock should be allowed to pass before transmitting or receiving data. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LPDLL_REG</name>
	<description>Low Power Divisor Latch Low</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_LPDLL</name>
	<description>This register makes up the lower 8-bits of a 16-bit, read/write, Low Power Divisor Latch register that contains the baud rate divisor for the UART, which must give a baud rate of 115.2K. This is required for SIR Low Power (minimum pulse width) detection at the receiver. This register may be accessed only when the DLAB bit (LCR[7]) is set.
The output low-power baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
Low power baud rate = (serial clock frequency)/(16* divisor)
Therefore, a divisor must be selected to give a baud rate of 115.2K.
NOTE: When the Low Power Divisor Latch registers (LPDLL and LPDLH) are set to 0, the low-power baud clock is disabled and no low-power pulse detection (or any pulse detection) occurs at the receiver. Also, once the LPDLL is set, at least eight clock cycles of the slowest UART Ctrl clock should be allowed to pass before transmitting or receiving data. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_B1</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SIRE</name>
	<description>SIR Mode Enable.
This is used to enable/disable the IrDA SIR Mode features as described in &quot;IrDA 1.0 SIR Protocol&quot; on page 53.
0 = IrDA SIR Mode disabled
1 = IrDA SIR Mode enabled </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, hardware Auto Flow Control is enabled via CTS and RTS.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_OUT2</name>
	<description>OUT2.
This is used to directly control the user-designated Output2 (out2_n) output. The value written to this location is inverted and driven out on out2_n, that is:
0 = out2_n de-asserted (logic 1)
1 = out2_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out2_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_OUT1</name>
	<description>OUT1.
This is used to directly control the user-designated Output1 (out1_n) output. The value written to this location is inverted and driven out on out1_n, that is:
0 = out1_n de-asserted (logic 1)
1 = out1_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out1_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto Flow Control is disabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high. When Auto Flow Control is enabled (MCR[5] set to one) and FIFOs are enabled (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive (high) while the value of this location is internally looped back to an input. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_DCD</name>
	<description>Data Carrier Detect.
This is used to indicate the current state of the modem control line dcd_n. This bit is the complement of dcd_n. When the Data Carrier Detect input (dcd_n) is asserted it is an indication that the carrier has been detected by the modem or data set.
0 = dcd_n input is de-asserted (logic 1)
1 = dcd_n input is asserted (logic 0)
In Loopback Mode (MCR[4] set to one), DCD is the same as MCR[3] (Out2). </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_R1</name>
	<description>Ring Indicator.
This is used to indicate the current state of the modem control line ri_n. This bit is the complement of ri_n. When the Ring Indicator input (ri_n) is asserted it is an indication that a telephone ringing signal has been received by the modem or data set.
0 = ri_n input is de-asserted (logic 1)
1 = ri_n input is asserted (logic 0)
In Loopback Mode (MCR[4] set to one), RI is the same as MCR[2] (Out1). </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DDCD</name>
	<description>Delta Data Carrier Detect.
This is used to indicate that the modem control line dcd_n has changed since the last time the MSR was read.
0 = no change on dcd_n since last read of MSR
1 = change on dcd_n since last read of MSR
Reading the MSR clears the DDCD bit. In Loopback Mode (MCR[4] = 1), DDCD reflects changes on MCR[3] (Out2).
Note, if the DDCD bit is not set and the dcd_n signal is asserted (low) and a reset occurs (software or otherwise), then the DDCD bit is set when the reset is removed if the dcd_n signal remains asserted. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TERI</name>
	<description>Trailing Edge of Ring Indicator.
This is used to indicate that a change on the input ri_n (from an active-low to an inactive-high state) has occurred since the last time the MSR was read.
0 = no change on ri_n since last read of MSR
1 = change on ri_n since last read of MSR
Reading the MSR clears the TERI bit. In Loopback Mode (MCR[4] = 1), TERI reflects when MCR[2] (Out1) has changed state from a high to a low. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DCTS</name>
	<description>Delta Clear to Send.
This is used to indicate that the modem control line cts_n has changed since the last time the MSR was read.
0 = no change on cts_n since last read of MSR
1 = change on cts_n since last read of MSR
Reading the MSR clears the DCTS bit. In Loopback Mode (MCR[4] = 1), DCTS reflects changes on MCR[1] (RTS).
Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed if the cts_n signal remains asserted. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Transmit Holding Register: This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. Divisor Latch (Low): This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (serial clock freq) / (16 * divisor) Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RFL_REG</name>
	<description>Receive FIFO Level.</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to perform a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto Flow Control is disabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
When Auto Flow Control is enabled (MCR[5] = 1) and FIFOs are enabled (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#194;&#188; full
10 = FIFO &#194;&#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#194;&#188; full
11 = FIFO &#194;&#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x3330382a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UCV</name>
	<description>Component Version </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>wkup580_nl01</name>
	<version>1.0</version>
	<description>wkup580_nl01 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>26</size>
	<usage>registers</usage>
</addressBlock>
	
	<registers>
	<register>
	<name>WKUP_COMPARE_REG</name>
	<description>Number of events before wakeup interrupt</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>COMPARE</name>
	<description>The number of events that have to be counted before the wakeup interrupt will be given </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_COUNTER_REG</name>
	<description>Actual number of events of the wakeup counter</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>EVENT_VALUE</name>
	<description>This value represents the number of events that have been counted so far. It will be reset by resetting the interrupt. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register>
<register>
	<name>WKUP_CTRL_REG</name>
	<description>Control register for the wakeup counter</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000c0ff</resetMask>
	<fields><field>
	<name>WKUP_ENABLE_IRQ</name>
	<description>0: no interrupt will be enabled
1: if the event counter reaches the value set by WKUP_COMPARE_REG an IRQ will be generated </description>
	<bitRange>[7:7]</bitRange>
    <enumeratedValues>
    <name>ENUM</name>
    </enumeratedValues>
	<access>read-write</access>
	</field>
    
    <field>
	<name>WKUP_SFT_KEYHIT</name>
	<description>0: no effect
1: emulate key hit. The event counter will increment by 1 (after debouncing if enabled). First make this bit 0 before any new key hit can be sensed. </description>
	<bitRange>[6:6]</bitRange>
    <enumeratedValues>
    <name>ENUM</name>
    </enumeratedValues>

	<access>read-write</access>
	</field>
    <field>
	<name>WKUP_DEB_VALUE</name>
	<description>Keyboard debounce time (N*1 ms with N = 1 to 63).
0x0: no debouncing
0x1 to 0x3F: 1 ms to 63 ms debounce time</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P0_REG</name>
	<description>Select the sensitivity polarity for each P0 input</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>WKUP_POL_P0</name>
	<description>0: enabled input P0x will increment the event counter if that input goes high
1: enabled input P0x will increment the event counter if that input goes low</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P1_REG</name>
	<description>Select the sensitivity polarity for each P1 input</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>WKUP_POL_P1</name>
	<description>0: enabled input P1x will increment the event counter if that input goes high
1: enabled input P1x will increment the event counter if that input goes low</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P2_REG</name>
	<description>Select the sensitivity polarity for each P2 input</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>WKUP_POL_P2</name>
	<description>0: enabled input P2x will increment the event counter if that input goes high
1: enabled input P2x will increment the event counter if that input goes low</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P3_REG</name>
	<description>Select the sensitivity polarity for each P3 input</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>WKUP_POL_P3</name>
	<description>0: enabled input P3x will increment the event counter if that input goes high
1: enabled input P3x will increment the event counter if that input goes low</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_RESET_CNTR_REG</name>
	<description>Reset the event counter</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_CNTR_RST</name>
	<description>writing any value to this register will reset the event counter</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_RESET_IRQ_REG</name>
	<description>Reset wakeup interrupt</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_IRQ_RST</name>
	<description>writing any value to this register will reset the interrupt. reading always returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P0_REG</name>
	<description>Select which inputs from P0 port can trigger wkup counter</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P0</name>
	<description>0: input P0x is not enabled for wakeup event counter
1: input P0x is enabled for wakeup event counter</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P1_REG</name>
	<description>Select which inputs from P1 port can trigger wkup counter</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P1</name>
	<description>0: input P1x is not enabled for wakeup event counter
1: input P1x is enabled for wakeup event counter</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P2_REG</name>
	<description>Select which inputs from P2 port can trigger wkup counter</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P2</name>
	<description>0: input P2x is not enabled for wakeup event counter
1: input P2x is enabled for wakeup event counter</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P3_REG</name>
	<description>Select which inputs from P3 port can trigger wkup counter</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P3</name>
	<description>0: input P3x is not enabled for wakeup event counter
1: input P3x is enabled for wakeup event counter</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register>
</registers>
		<interrupt>
			<name>BLE_WAKEUP_LP</name>
			<description>Wake-up from Low Power (Extended Sleep) interrupt from BLE</description>
			<value>0</value>
		</interrupt>
		<interrupt>
			<name>BLE_GEN</name>
			<description>BLE Interrupt from various BLE sources.</description>
			<value>1</value>
		</interrupt>
		<interrupt>
			<name>UART</name>
			<description>UART interrupt</description>
			<value>2</value>
		</interrupt>
		<interrupt>
			<name>UART2</name>
			<description>UART2 interrupt</description>
			<value>3</value>
		</interrupt>
		<interrupt>
			<name>I2C</name>
			<description>I2C interrupt</description>
			<value>4</value>
		</interrupt>
		<interrupt>
			<name>SPI</name>
			<description>SPI interrupt</description>
			<value>5</value>
		</interrupt>
		<interrupt>
			<name>ADC</name>
			<description>Analog-Digital Converter interrupt.</description>
			<value>6</value>
		</interrupt>
		<interrupt>
			<name>KEYBRD</name>
			<description>Keyboard interrupt.</description>
			<value>7</value>
		</interrupt>
		<interrupt>
			<name>BLE_RF_DIAG</name>
			<description>Baseband or Radio Diagnostics Interrupt</description>
			<value>8</value>
		</interrupt>
		<interrupt>
			<name>RF_CAL</name>
			<description>RF Calibration Interrupt</description>
			<value>9</value>
		</interrupt>
		<interrupt>
			<name>GPIO0</name>
			<description>GPIO0 interrupt through debounce</description>
			<value>10</value>
		</interrupt>
		<interrupt>
			<name>GPIO1</name>
			<description>GPIO1 interrupt through debounce</description>
			<value>11</value>
		</interrupt>
		<interrupt>
			<name>GPIO2</name>
			<description>GPIO2 interrupt through debounce</description>
			<value>12</value>
		</interrupt>
		<interrupt>
			<name>GPIO3</name>
			<description>GPIO3 interrupt through debounce</description>
			<value>13</value>
		</interrupt>
		<interrupt>
			<name>GPIO4</name>
			<description>GPIO4 interrupt through debounce</description>
			<value>14</value>
		</interrupt>
		<interrupt>
			<name>SWTIM</name>
			<description>Software Timer interrupt</description>
			<value>15</value>
		</interrupt>
		<interrupt>
			<name>WKUP_QUADEC</name>
			<description>Combines the Wake up Capture Timer interrupt, the GPIO interrupt and the QuadDecoder interrupt</description>
			<value>16</value>
		</interrupt
		><interrupt>
			<name>PCM</name>
			<description>PCM interrupt</description>
			<value>17</value>
		</interrupt>
		<interrupt>
			<name>SRC_IN</name>
			<description>Sample rate converter input interrupt</description>
			<value>18</value>
		</interrupt>
		<interrupt>
			<name>SRC_OUT</name>
			<description>Sample rate converter output interrupt</description>
			<value>19</value>
		</interrupt>
		<interrupt>
			<name>DMA</name>
			<description>DMA interrupt</description>
			<value>20</value>
		</interrupt>
    </peripheral>
</peripherals>
</device>
